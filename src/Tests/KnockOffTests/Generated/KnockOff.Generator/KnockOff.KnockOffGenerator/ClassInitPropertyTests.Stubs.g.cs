// <auto-generated/>
#nullable enable

namespace KnockOffTests;

partial class ClassInitPropertyTests
{
	/// <summary>Contains stub implementations for inline stub pattern.</summary>
	public static class Stubs
	{
		/// <summary>Interceptor for EntityBaseWithVirtualInit.Id.</summary>
		public sealed class EntityBaseWithVirtualInit_IdInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value instead of base.</summary>
			public global::System.Func<Stubs.EntityBaseWithVirtualInit, string>? OnGet { get; set; }

			/// <summary>Number of times the setter was accessed.</summary>
			public int SetCount { get; private set; }

			/// <summary>The last value passed to the setter.</summary>
			public string? LastSetValue { get; private set; }

			/// <summary>Callback for setter. If set, called instead of base.</summary>
			public global::System.Action<Stubs.EntityBaseWithVirtualInit, string>? OnSet { get; set; }

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Records a setter access.</summary>
			public void RecordSet(string? value) { SetCount++; LastSetValue = value; }

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; SetCount = 0; LastSetValue = default; OnSet = null; }
		}

		/// <summary>Stub for global::KnockOffTests.EntityBaseWithVirtualInit via composition.</summary>
		public class EntityBaseWithVirtualInit
		{
			/// <summary>Interceptor for Id.</summary>
			public EntityBaseWithVirtualInit_IdInterceptor Id { get; } = new();

			/// <summary>The global::KnockOffTests.EntityBaseWithVirtualInit instance. Pass this to code expecting the target class.</summary>
			public global::KnockOffTests.EntityBaseWithVirtualInit Object { get; }

			public EntityBaseWithVirtualInit()
			{
				Object = new Impl(this);
			}

			/// <summary>Resets all interceptor state.</summary>
			public void ResetInterceptors()
			{
				Id.Reset();
			}

			/// <summary>Internal implementation that inherits from global::KnockOffTests.EntityBaseWithVirtualInit.</summary>
			private sealed class Impl : global::KnockOffTests.EntityBaseWithVirtualInit
			{
				private readonly EntityBaseWithVirtualInit _stub;

				public Impl(EntityBaseWithVirtualInit stub) : base()
				{
					_stub = stub;
				}

				/// <inheritdoc />
				public override string Id
				{
					get
					{
						_stub?.Id.RecordGet();
						if (_stub?.Id.OnGet is { } onGet) return onGet(_stub);
						return base.Id;
					}
					init
					{
						_stub?.Id.RecordSet(value);
						if (_stub?.Id.OnSet is { } onSet) onSet(_stub, value);
						else base.Id = value;
					}
				}

			}
		}

		/// <summary>Interceptor for EntityBaseWithAbstractInit.Id.</summary>
		public sealed class EntityBaseWithAbstractInit_IdInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value instead of base.</summary>
			public global::System.Func<Stubs.EntityBaseWithAbstractInit, string>? OnGet { get; set; }

			/// <summary>Number of times the setter was accessed.</summary>
			public int SetCount { get; private set; }

			/// <summary>The last value passed to the setter.</summary>
			public string? LastSetValue { get; private set; }

			/// <summary>Callback for setter. If set, called instead of base.</summary>
			public global::System.Action<Stubs.EntityBaseWithAbstractInit, string>? OnSet { get; set; }

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Records a setter access.</summary>
			public void RecordSet(string? value) { SetCount++; LastSetValue = value; }

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; SetCount = 0; LastSetValue = default; OnSet = null; }
		}

		/// <summary>Stub for global::KnockOffTests.EntityBaseWithAbstractInit via composition.</summary>
		public class EntityBaseWithAbstractInit
		{
			/// <summary>Interceptor for Id.</summary>
			public EntityBaseWithAbstractInit_IdInterceptor Id { get; } = new();

			/// <summary>The global::KnockOffTests.EntityBaseWithAbstractInit instance. Pass this to code expecting the target class.</summary>
			public global::KnockOffTests.EntityBaseWithAbstractInit Object { get; }

			public EntityBaseWithAbstractInit()
			{
				Object = new Impl(this);
			}

			/// <summary>Resets all interceptor state.</summary>
			public void ResetInterceptors()
			{
				Id.Reset();
			}

			/// <summary>Internal implementation that inherits from global::KnockOffTests.EntityBaseWithAbstractInit.</summary>
			private sealed class Impl : global::KnockOffTests.EntityBaseWithAbstractInit
			{
				private readonly EntityBaseWithAbstractInit _stub;

				public Impl(EntityBaseWithAbstractInit stub) : base()
				{
					_stub = stub;
				}

				/// <inheritdoc />
				public override string Id
				{
					get
					{
						_stub?.Id.RecordGet();
						if (_stub?.Id.OnGet is { } onGet) return onGet(_stub);
						return default!;
					}
					init
					{
						_stub?.Id.RecordSet(value);
						if (_stub?.Id.OnSet is { } onSet) onSet(_stub, value);
					}
				}

			}
		}

		/// <summary>Interceptor for EntityBaseWithMixedInit.Id.</summary>
		public sealed class EntityBaseWithMixedInit_IdInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value instead of base.</summary>
			public global::System.Func<Stubs.EntityBaseWithMixedInit, string>? OnGet { get; set; }

			/// <summary>Number of times the setter was accessed.</summary>
			public int SetCount { get; private set; }

			/// <summary>The last value passed to the setter.</summary>
			public string? LastSetValue { get; private set; }

			/// <summary>Callback for setter. If set, called instead of base.</summary>
			public global::System.Action<Stubs.EntityBaseWithMixedInit, string>? OnSet { get; set; }

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Records a setter access.</summary>
			public void RecordSet(string? value) { SetCount++; LastSetValue = value; }

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; SetCount = 0; LastSetValue = default; OnSet = null; }
		}

		/// <summary>Interceptor for EntityBaseWithMixedInit.Name.</summary>
		public sealed class EntityBaseWithMixedInit_NameInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value instead of base.</summary>
			public global::System.Func<Stubs.EntityBaseWithMixedInit, string>? OnGet { get; set; }

			/// <summary>Number of times the setter was accessed.</summary>
			public int SetCount { get; private set; }

			/// <summary>The last value passed to the setter.</summary>
			public string? LastSetValue { get; private set; }

			/// <summary>Callback for setter. If set, called instead of base.</summary>
			public global::System.Action<Stubs.EntityBaseWithMixedInit, string>? OnSet { get; set; }

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Records a setter access.</summary>
			public void RecordSet(string? value) { SetCount++; LastSetValue = value; }

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; SetCount = 0; LastSetValue = default; OnSet = null; }
		}

		/// <summary>Interceptor for EntityBaseWithMixedInit.Version.</summary>
		public sealed class EntityBaseWithMixedInit_VersionInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value instead of base.</summary>
			public global::System.Func<Stubs.EntityBaseWithMixedInit, int>? OnGet { get; set; }

			/// <summary>Number of times the setter was accessed.</summary>
			public int SetCount { get; private set; }

			/// <summary>The last value passed to the setter.</summary>
			public int? LastSetValue { get; private set; }

			/// <summary>Callback for setter. If set, called instead of base.</summary>
			public global::System.Action<Stubs.EntityBaseWithMixedInit, int>? OnSet { get; set; }

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Records a setter access.</summary>
			public void RecordSet(int? value) { SetCount++; LastSetValue = value; }

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; SetCount = 0; LastSetValue = default; OnSet = null; }
		}

		/// <summary>Stub for global::KnockOffTests.EntityBaseWithMixedInit via composition.</summary>
		public class EntityBaseWithMixedInit
		{
			/// <summary>Interceptor for Id.</summary>
			public EntityBaseWithMixedInit_IdInterceptor Id { get; } = new();
			/// <summary>Interceptor for Name.</summary>
			public EntityBaseWithMixedInit_NameInterceptor Name { get; } = new();
			/// <summary>Interceptor for Version.</summary>
			public EntityBaseWithMixedInit_VersionInterceptor Version { get; } = new();

			/// <summary>The global::KnockOffTests.EntityBaseWithMixedInit instance. Pass this to code expecting the target class.</summary>
			public global::KnockOffTests.EntityBaseWithMixedInit Object { get; }

			public EntityBaseWithMixedInit()
			{
				Object = new Impl(this);
			}

			/// <summary>Resets all interceptor state.</summary>
			public void ResetInterceptors()
			{
				Id.Reset();
				Name.Reset();
				Version.Reset();
			}

			/// <summary>Internal implementation that inherits from global::KnockOffTests.EntityBaseWithMixedInit.</summary>
			private sealed class Impl : global::KnockOffTests.EntityBaseWithMixedInit
			{
				private readonly EntityBaseWithMixedInit _stub;

				public Impl(EntityBaseWithMixedInit stub) : base()
				{
					_stub = stub;
				}

				/// <inheritdoc />
				public override string Id
				{
					get
					{
						_stub?.Id.RecordGet();
						if (_stub?.Id.OnGet is { } onGet) return onGet(_stub);
						return base.Id;
					}
					init
					{
						_stub?.Id.RecordSet(value);
						if (_stub?.Id.OnSet is { } onSet) onSet(_stub, value);
						else base.Id = value;
					}
				}

				/// <inheritdoc />
				public override string Name
				{
					get
					{
						_stub?.Name.RecordGet();
						if (_stub?.Name.OnGet is { } onGet) return onGet(_stub);
						return base.Name;
					}
					set
					{
						_stub?.Name.RecordSet(value);
						if (_stub?.Name.OnSet is { } onSet) onSet(_stub, value);
						else base.Name = value;
					}
				}

				/// <inheritdoc />
				public override int Version
				{
					get
					{
						_stub?.Version.RecordGet();
						if (_stub?.Version.OnGet is { } onGet) return onGet(_stub);
						return default!;
					}
					init
					{
						_stub?.Version.RecordSet(value);
						if (_stub?.Version.OnSet is { } onSet) onSet(_stub, value);
					}
				}

			}
		}

		/// <summary>Interceptor for EntityBaseWithRequiredProperty.Id.</summary>
		public sealed class EntityBaseWithRequiredProperty_IdInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value instead of base.</summary>
			public global::System.Func<Stubs.EntityBaseWithRequiredProperty, string>? OnGet { get; set; }

			/// <summary>Number of times the setter was accessed.</summary>
			public int SetCount { get; private set; }

			/// <summary>The last value passed to the setter.</summary>
			public string? LastSetValue { get; private set; }

			/// <summary>Callback for setter. If set, called instead of base.</summary>
			public global::System.Action<Stubs.EntityBaseWithRequiredProperty, string>? OnSet { get; set; }

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Records a setter access.</summary>
			public void RecordSet(string? value) { SetCount++; LastSetValue = value; }

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; SetCount = 0; LastSetValue = default; OnSet = null; }
		}

		/// <summary>Stub for global::KnockOffTests.EntityBaseWithRequiredProperty via composition.</summary>
		public class EntityBaseWithRequiredProperty
		{
			/// <summary>Interceptor for Id.</summary>
			public EntityBaseWithRequiredProperty_IdInterceptor Id { get; } = new();

			/// <summary>The global::KnockOffTests.EntityBaseWithRequiredProperty instance. Pass this to code expecting the target class.</summary>
			public global::KnockOffTests.EntityBaseWithRequiredProperty Object { get; }

			public EntityBaseWithRequiredProperty()
			{
				Object = new Impl(this);
			}

			/// <summary>Resets all interceptor state.</summary>
			public void ResetInterceptors()
			{
				Id.Reset();
			}

#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor
			/// <summary>Internal implementation that inherits from global::KnockOffTests.EntityBaseWithRequiredProperty.</summary>
			private sealed class Impl : global::KnockOffTests.EntityBaseWithRequiredProperty
			{
				private readonly EntityBaseWithRequiredProperty _stub;

				[global::System.Diagnostics.CodeAnalysis.SetsRequiredMembers]
				public Impl(EntityBaseWithRequiredProperty stub) : base()
				{
					Id = default!;
					_stub = stub;
				}

				/// <inheritdoc />
				required public override string Id
				{
					get
					{
						_stub?.Id.RecordGet();
						if (_stub?.Id.OnGet is { } onGet) return onGet(_stub);
						return base.Id;
					}
					set
					{
						_stub?.Id.RecordSet(value);
						if (_stub?.Id.OnSet is { } onSet) onSet(_stub, value);
						else base.Id = value;
					}
				}

			}
#pragma warning restore CS8618
		}

		/// <summary>Interceptor for EntityBaseWithRequiredInit.Id.</summary>
		public sealed class EntityBaseWithRequiredInit_IdInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value instead of base.</summary>
			public global::System.Func<Stubs.EntityBaseWithRequiredInit, string>? OnGet { get; set; }

			/// <summary>Number of times the setter was accessed.</summary>
			public int SetCount { get; private set; }

			/// <summary>The last value passed to the setter.</summary>
			public string? LastSetValue { get; private set; }

			/// <summary>Callback for setter. If set, called instead of base.</summary>
			public global::System.Action<Stubs.EntityBaseWithRequiredInit, string>? OnSet { get; set; }

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Records a setter access.</summary>
			public void RecordSet(string? value) { SetCount++; LastSetValue = value; }

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; SetCount = 0; LastSetValue = default; OnSet = null; }
		}

		/// <summary>Stub for global::KnockOffTests.EntityBaseWithRequiredInit via composition.</summary>
		public class EntityBaseWithRequiredInit
		{
			/// <summary>Interceptor for Id.</summary>
			public EntityBaseWithRequiredInit_IdInterceptor Id { get; } = new();

			/// <summary>The global::KnockOffTests.EntityBaseWithRequiredInit instance. Pass this to code expecting the target class.</summary>
			public global::KnockOffTests.EntityBaseWithRequiredInit Object { get; }

			public EntityBaseWithRequiredInit()
			{
				Object = new Impl(this);
			}

			/// <summary>Resets all interceptor state.</summary>
			public void ResetInterceptors()
			{
				Id.Reset();
			}

#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor
			/// <summary>Internal implementation that inherits from global::KnockOffTests.EntityBaseWithRequiredInit.</summary>
			private sealed class Impl : global::KnockOffTests.EntityBaseWithRequiredInit
			{
				private readonly EntityBaseWithRequiredInit _stub;

				[global::System.Diagnostics.CodeAnalysis.SetsRequiredMembers]
				public Impl(EntityBaseWithRequiredInit stub) : base()
				{
					Id = default!;
					_stub = stub;
				}

				/// <inheritdoc />
				required public override string Id
				{
					get
					{
						_stub?.Id.RecordGet();
						if (_stub?.Id.OnGet is { } onGet) return onGet(_stub);
						return base.Id;
					}
					init
					{
						_stub?.Id.RecordSet(value);
						if (_stub?.Id.OnSet is { } onSet) onSet(_stub, value);
						else base.Id = value;
					}
				}

			}
#pragma warning restore CS8618
		}

		/// <summary>Interceptor for EntityBaseWithMultipleRequired.Id.</summary>
		public sealed class EntityBaseWithMultipleRequired_IdInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value instead of base.</summary>
			public global::System.Func<Stubs.EntityBaseWithMultipleRequired, string>? OnGet { get; set; }

			/// <summary>Number of times the setter was accessed.</summary>
			public int SetCount { get; private set; }

			/// <summary>The last value passed to the setter.</summary>
			public string? LastSetValue { get; private set; }

			/// <summary>Callback for setter. If set, called instead of base.</summary>
			public global::System.Action<Stubs.EntityBaseWithMultipleRequired, string>? OnSet { get; set; }

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Records a setter access.</summary>
			public void RecordSet(string? value) { SetCount++; LastSetValue = value; }

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; SetCount = 0; LastSetValue = default; OnSet = null; }
		}

		/// <summary>Interceptor for EntityBaseWithMultipleRequired.Name.</summary>
		public sealed class EntityBaseWithMultipleRequired_NameInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value instead of base.</summary>
			public global::System.Func<Stubs.EntityBaseWithMultipleRequired, string>? OnGet { get; set; }

			/// <summary>Number of times the setter was accessed.</summary>
			public int SetCount { get; private set; }

			/// <summary>The last value passed to the setter.</summary>
			public string? LastSetValue { get; private set; }

			/// <summary>Callback for setter. If set, called instead of base.</summary>
			public global::System.Action<Stubs.EntityBaseWithMultipleRequired, string>? OnSet { get; set; }

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Records a setter access.</summary>
			public void RecordSet(string? value) { SetCount++; LastSetValue = value; }

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; SetCount = 0; LastSetValue = default; OnSet = null; }
		}

		/// <summary>Interceptor for EntityBaseWithMultipleRequired.Version.</summary>
		public sealed class EntityBaseWithMultipleRequired_VersionInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value instead of base.</summary>
			public global::System.Func<Stubs.EntityBaseWithMultipleRequired, int>? OnGet { get; set; }

			/// <summary>Number of times the setter was accessed.</summary>
			public int SetCount { get; private set; }

			/// <summary>The last value passed to the setter.</summary>
			public int? LastSetValue { get; private set; }

			/// <summary>Callback for setter. If set, called instead of base.</summary>
			public global::System.Action<Stubs.EntityBaseWithMultipleRequired, int>? OnSet { get; set; }

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Records a setter access.</summary>
			public void RecordSet(int? value) { SetCount++; LastSetValue = value; }

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; SetCount = 0; LastSetValue = default; OnSet = null; }
		}

		/// <summary>Stub for global::KnockOffTests.EntityBaseWithMultipleRequired via composition.</summary>
		public class EntityBaseWithMultipleRequired
		{
			/// <summary>Interceptor for Id.</summary>
			public EntityBaseWithMultipleRequired_IdInterceptor Id { get; } = new();
			/// <summary>Interceptor for Name.</summary>
			public EntityBaseWithMultipleRequired_NameInterceptor Name { get; } = new();
			/// <summary>Interceptor for Version.</summary>
			public EntityBaseWithMultipleRequired_VersionInterceptor Version { get; } = new();

			/// <summary>The global::KnockOffTests.EntityBaseWithMultipleRequired instance. Pass this to code expecting the target class.</summary>
			public global::KnockOffTests.EntityBaseWithMultipleRequired Object { get; }

			public EntityBaseWithMultipleRequired()
			{
				Object = new Impl(this);
			}

			/// <summary>Resets all interceptor state.</summary>
			public void ResetInterceptors()
			{
				Id.Reset();
				Name.Reset();
				Version.Reset();
			}

#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor
			/// <summary>Internal implementation that inherits from global::KnockOffTests.EntityBaseWithMultipleRequired.</summary>
			private sealed class Impl : global::KnockOffTests.EntityBaseWithMultipleRequired
			{
				private readonly EntityBaseWithMultipleRequired _stub;

				[global::System.Diagnostics.CodeAnalysis.SetsRequiredMembers]
				public Impl(EntityBaseWithMultipleRequired stub) : base()
				{
					Id = default!;
					Name = default!;
					_stub = stub;
				}

				/// <inheritdoc />
				required public override string Id
				{
					get
					{
						_stub?.Id.RecordGet();
						if (_stub?.Id.OnGet is { } onGet) return onGet(_stub);
						return base.Id;
					}
					init
					{
						_stub?.Id.RecordSet(value);
						if (_stub?.Id.OnSet is { } onSet) onSet(_stub, value);
						else base.Id = value;
					}
				}

				/// <inheritdoc />
				required public override string Name
				{
					get
					{
						_stub?.Name.RecordGet();
						if (_stub?.Name.OnGet is { } onGet) return onGet(_stub);
						return base.Name;
					}
					set
					{
						_stub?.Name.RecordSet(value);
						if (_stub?.Name.OnSet is { } onSet) onSet(_stub, value);
						else base.Name = value;
					}
				}

				/// <inheritdoc />
				public override int Version
				{
					get
					{
						_stub?.Version.RecordGet();
						if (_stub?.Version.OnGet is { } onGet) return onGet(_stub);
						return base.Version;
					}
					set
					{
						_stub?.Version.RecordSet(value);
						if (_stub?.Version.OnSet is { } onSet) onSet(_stub, value);
						else base.Version = value;
					}
				}

			}
#pragma warning restore CS8618
		}

	}
}
