// <auto-generated/>
#nullable enable

namespace KnockOff.Documentation.Samples.Guides;

partial class BpComplexInterfaceTests
{
	/// <summary>Contains stub implementations for inline stub pattern.</summary>
	public static class Stubs
	{
		/// <summary>Interceptor for IBpEditBase.IsValid.</summary>
		public sealed class IBpEditBase_IsValidInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<Stubs.IBpEditBase, bool>? OnGet { get; set; }

			/// <summary>Value returned by getter when OnGet is not set.</summary>
			public bool Value { get; set; } = default!;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; Value = default!; }
		}

		/// <summary>Interceptor for IBpEditBase.IsSelfValid.</summary>
		public sealed class IBpEditBase_IsSelfValidInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<Stubs.IBpEditBase, bool>? OnGet { get; set; }

			/// <summary>Value returned by getter when OnGet is not set.</summary>
			public bool Value { get; set; } = default!;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; Value = default!; }
		}

		/// <summary>Interceptor for IBpEditBase.IsDirty.</summary>
		public sealed class IBpEditBase_IsDirtyInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<Stubs.IBpEditBase, bool>? OnGet { get; set; }

			/// <summary>Value returned by getter when OnGet is not set.</summary>
			public bool Value { get; set; } = default!;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; Value = default!; }
		}

		/// <summary>Interceptor for IBpEditBase.IsSelfDirty.</summary>
		public sealed class IBpEditBase_IsSelfDirtyInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<Stubs.IBpEditBase, bool>? OnGet { get; set; }

			/// <summary>Value returned by getter when OnGet is not set.</summary>
			public bool Value { get; set; } = default!;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; Value = default!; }
		}

		/// <summary>Interceptor for IBpEditBase.IsDeleted.</summary>
		public sealed class IBpEditBase_IsDeletedInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<Stubs.IBpEditBase, bool>? OnGet { get; set; }

			/// <summary>Value returned by getter when OnGet is not set.</summary>
			public bool Value { get; set; } = default!;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; Value = default!; }
		}

		/// <summary>Interceptor for IBpEditBase.IsNew.</summary>
		public sealed class IBpEditBase_IsNewInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<Stubs.IBpEditBase, bool>? OnGet { get; set; }

			/// <summary>Value returned by getter when OnGet is not set.</summary>
			public bool Value { get; set; } = default!;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; Value = default!; }
		}

		/// <summary>Interceptor for IBpEditBase.IsSavable.</summary>
		public sealed class IBpEditBase_IsSavableInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<Stubs.IBpEditBase, bool>? OnGet { get; set; }

			/// <summary>Value returned by getter when OnGet is not set.</summary>
			public bool Value { get; set; } = default!;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; Value = default!; }
		}

		/// <summary>Interceptor for IBpEditBase.Id.</summary>
		public sealed class IBpEditBase_IdInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<Stubs.IBpEditBase, int>? OnGet { get; set; }

			/// <summary>Number of times the setter was accessed.</summary>
			public int SetCount { get; private set; }

			/// <summary>The last value passed to the setter.</summary>
			public int? LastSetValue { get; private set; }

			/// <summary>Callback for setter.</summary>
			public global::System.Action<Stubs.IBpEditBase, int>? OnSet { get; set; }

			/// <summary>Value returned by getter when OnGet is not set.</summary>
			public int Value { get; set; } = default!;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Records a setter access.</summary>
			public void RecordSet(int? value) { SetCount++; LastSetValue = value; }

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; SetCount = 0; LastSetValue = default; OnSet = null; Value = default!; }
		}

		/// <summary>Interceptor for IBpEditBase.Name.</summary>
		public sealed class IBpEditBase_NameInterceptor
		{
			/// <summary>Number of times the getter was accessed.</summary>
			public int GetCount { get; private set; }

			/// <summary>Callback for getter. If set, returns its value.</summary>
			public global::System.Func<Stubs.IBpEditBase, string>? OnGet { get; set; }

			/// <summary>Number of times the setter was accessed.</summary>
			public int SetCount { get; private set; }

			/// <summary>The last value passed to the setter.</summary>
			public string? LastSetValue { get; private set; }

			/// <summary>Callback for setter.</summary>
			public global::System.Action<Stubs.IBpEditBase, string>? OnSet { get; set; }

			/// <summary>Value returned by getter when OnGet is not set.</summary>
			public string Value { get; set; } = default!;

			/// <summary>Records a getter access.</summary>
			public void RecordGet() => GetCount++;

			/// <summary>Records a setter access.</summary>
			public void RecordSet(string? value) { SetCount++; LastSetValue = value; }

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { GetCount = 0; OnGet = null; SetCount = 0; LastSetValue = default; OnSet = null; Value = default!; }
		}

		/// <summary>Tracks and configures behavior for BeginEdit.</summary>
		public sealed class IBpEditBase_BeginEditInterceptor
		{
			private readonly global::System.Collections.Generic.List<(global::System.Action<Stubs.IBpEditBase> Callback, global::KnockOff.Times Times, MethodTrackingImpl Tracking)> _sequence = new();
			private int _sequenceIndex;
			private int _unconfiguredCallCount;

			/// <summary>Total number of times this method was called (across all OnCall registrations).</summary>
			public int CallCount { get { int sum = _unconfiguredCallCount; foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>Whether this method was called at least once.</summary>
			public bool WasCalled => CallCount > 0;


			/// <summary>Configures callback that repeats forever. Returns tracking interface.</summary>
			public global::KnockOff.IMethodTracking OnCall(global::System.Action<Stubs.IBpEditBase> callback)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, global::KnockOff.Times.Forever, tracking));
				_sequenceIndex = 0;
				return tracking;
			}

			/// <summary>Configures callback with Times constraint. Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>> OnCall(global::System.Action<Stubs.IBpEditBase> callback, global::KnockOff.Times times)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, times, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(Stubs.IBpEditBase ko)
			{
				if (_sequence.Count == 0)
				{
					_unconfiguredCallCount++;
					if (ko.Strict) throw global::KnockOff.StubException.NotConfigured("", "BeginEdit");
					return;
				}

				var (callback, times, tracking) = _sequence[_sequenceIndex];
				tracking.RecordCall();

				if (!times.IsForever && tracking.CallCount >= times.Count)
				{
					if (_sequenceIndex < _sequence.Count - 1)
						_sequenceIndex++;
					else if (tracking.CallCount > times.Count)
						throw global::KnockOff.StubException.SequenceExhausted("BeginEdit");
				}

				callback(ko);
			}

			/// <summary>Resets all tracking state.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				foreach (var (_, _, tracking) in _sequence)
					tracking.Reset();
				_sequenceIndex = 0;
			}

			/// <summary>Verifies all Times constraints were satisfied. For Forever, verifies called at least once.</summary>
			public bool Verify()
			{
				foreach (var (_, times, tracking) in _sequence)
				{
					if (times.IsForever)
					{
						if (!tracking.WasCalled)
							return false;
					}
					else if (!times.Verify(tracking.CallCount))
						return false;
				}
				return true;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking
			{

				/// <summary>Number of times this callback was invoked.</summary>
				public int CallCount { get; private set; }

				/// <summary>True if CallCount > 0.</summary>
				public bool WasCalled => CallCount > 0;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>>
			{
				private readonly IBpEditBase_BeginEditInterceptor _interceptor;

				public MethodSequenceImpl(IBpEditBase_BeginEditInterceptor interceptor) => _interceptor = interceptor;

				/// <summary>Total calls across all callbacks in sequence.</summary>
				public int TotalCallCount
				{
					get
					{
						var total = 0;
						foreach (var (_, _, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Add another callback to the sequence.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>> ThenCall(global::System.Action<Stubs.IBpEditBase> callback, global::KnockOff.Times times)
				{
					var tracking = new MethodTrackingImpl();
					_interceptor._sequence.Add((callback, times, tracking));
					return this;
				}

				/// <summary>Verify all Times constraints in the sequence were satisfied.</summary>
				public bool Verify()
				{
					foreach (var (_, times, tracking) in _interceptor._sequence)
					{
						if (!times.Verify(tracking.CallCount))
							return false;
					}
					return true;
				}

				/// <summary>Reset all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();
			}

		}

		/// <summary>Tracks and configures behavior for CancelEdit.</summary>
		public sealed class IBpEditBase_CancelEditInterceptor
		{
			private readonly global::System.Collections.Generic.List<(global::System.Action<Stubs.IBpEditBase> Callback, global::KnockOff.Times Times, MethodTrackingImpl Tracking)> _sequence = new();
			private int _sequenceIndex;
			private int _unconfiguredCallCount;

			/// <summary>Total number of times this method was called (across all OnCall registrations).</summary>
			public int CallCount { get { int sum = _unconfiguredCallCount; foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>Whether this method was called at least once.</summary>
			public bool WasCalled => CallCount > 0;


			/// <summary>Configures callback that repeats forever. Returns tracking interface.</summary>
			public global::KnockOff.IMethodTracking OnCall(global::System.Action<Stubs.IBpEditBase> callback)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, global::KnockOff.Times.Forever, tracking));
				_sequenceIndex = 0;
				return tracking;
			}

			/// <summary>Configures callback with Times constraint. Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>> OnCall(global::System.Action<Stubs.IBpEditBase> callback, global::KnockOff.Times times)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, times, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(Stubs.IBpEditBase ko)
			{
				if (_sequence.Count == 0)
				{
					_unconfiguredCallCount++;
					if (ko.Strict) throw global::KnockOff.StubException.NotConfigured("", "CancelEdit");
					return;
				}

				var (callback, times, tracking) = _sequence[_sequenceIndex];
				tracking.RecordCall();

				if (!times.IsForever && tracking.CallCount >= times.Count)
				{
					if (_sequenceIndex < _sequence.Count - 1)
						_sequenceIndex++;
					else if (tracking.CallCount > times.Count)
						throw global::KnockOff.StubException.SequenceExhausted("CancelEdit");
				}

				callback(ko);
			}

			/// <summary>Resets all tracking state.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				foreach (var (_, _, tracking) in _sequence)
					tracking.Reset();
				_sequenceIndex = 0;
			}

			/// <summary>Verifies all Times constraints were satisfied. For Forever, verifies called at least once.</summary>
			public bool Verify()
			{
				foreach (var (_, times, tracking) in _sequence)
				{
					if (times.IsForever)
					{
						if (!tracking.WasCalled)
							return false;
					}
					else if (!times.Verify(tracking.CallCount))
						return false;
				}
				return true;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking
			{

				/// <summary>Number of times this callback was invoked.</summary>
				public int CallCount { get; private set; }

				/// <summary>True if CallCount > 0.</summary>
				public bool WasCalled => CallCount > 0;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>>
			{
				private readonly IBpEditBase_CancelEditInterceptor _interceptor;

				public MethodSequenceImpl(IBpEditBase_CancelEditInterceptor interceptor) => _interceptor = interceptor;

				/// <summary>Total calls across all callbacks in sequence.</summary>
				public int TotalCallCount
				{
					get
					{
						var total = 0;
						foreach (var (_, _, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Add another callback to the sequence.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>> ThenCall(global::System.Action<Stubs.IBpEditBase> callback, global::KnockOff.Times times)
				{
					var tracking = new MethodTrackingImpl();
					_interceptor._sequence.Add((callback, times, tracking));
					return this;
				}

				/// <summary>Verify all Times constraints in the sequence were satisfied.</summary>
				public bool Verify()
				{
					foreach (var (_, times, tracking) in _interceptor._sequence)
					{
						if (!times.Verify(tracking.CallCount))
							return false;
					}
					return true;
				}

				/// <summary>Reset all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();
			}

		}

		/// <summary>Tracks and configures behavior for ApplyEdit.</summary>
		public sealed class IBpEditBase_ApplyEditInterceptor
		{
			private readonly global::System.Collections.Generic.List<(global::System.Action<Stubs.IBpEditBase> Callback, global::KnockOff.Times Times, MethodTrackingImpl Tracking)> _sequence = new();
			private int _sequenceIndex;
			private int _unconfiguredCallCount;

			/// <summary>Total number of times this method was called (across all OnCall registrations).</summary>
			public int CallCount { get { int sum = _unconfiguredCallCount; foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>Whether this method was called at least once.</summary>
			public bool WasCalled => CallCount > 0;


			/// <summary>Configures callback that repeats forever. Returns tracking interface.</summary>
			public global::KnockOff.IMethodTracking OnCall(global::System.Action<Stubs.IBpEditBase> callback)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, global::KnockOff.Times.Forever, tracking));
				_sequenceIndex = 0;
				return tracking;
			}

			/// <summary>Configures callback with Times constraint. Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>> OnCall(global::System.Action<Stubs.IBpEditBase> callback, global::KnockOff.Times times)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, times, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(Stubs.IBpEditBase ko)
			{
				if (_sequence.Count == 0)
				{
					_unconfiguredCallCount++;
					if (ko.Strict) throw global::KnockOff.StubException.NotConfigured("", "ApplyEdit");
					return;
				}

				var (callback, times, tracking) = _sequence[_sequenceIndex];
				tracking.RecordCall();

				if (!times.IsForever && tracking.CallCount >= times.Count)
				{
					if (_sequenceIndex < _sequence.Count - 1)
						_sequenceIndex++;
					else if (tracking.CallCount > times.Count)
						throw global::KnockOff.StubException.SequenceExhausted("ApplyEdit");
				}

				callback(ko);
			}

			/// <summary>Resets all tracking state.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				foreach (var (_, _, tracking) in _sequence)
					tracking.Reset();
				_sequenceIndex = 0;
			}

			/// <summary>Verifies all Times constraints were satisfied. For Forever, verifies called at least once.</summary>
			public bool Verify()
			{
				foreach (var (_, times, tracking) in _sequence)
				{
					if (times.IsForever)
					{
						if (!tracking.WasCalled)
							return false;
					}
					else if (!times.Verify(tracking.CallCount))
						return false;
				}
				return true;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking
			{

				/// <summary>Number of times this callback was invoked.</summary>
				public int CallCount { get; private set; }

				/// <summary>True if CallCount > 0.</summary>
				public bool WasCalled => CallCount > 0;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>>
			{
				private readonly IBpEditBase_ApplyEditInterceptor _interceptor;

				public MethodSequenceImpl(IBpEditBase_ApplyEditInterceptor interceptor) => _interceptor = interceptor;

				/// <summary>Total calls across all callbacks in sequence.</summary>
				public int TotalCallCount
				{
					get
					{
						var total = 0;
						foreach (var (_, _, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Add another callback to the sequence.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>> ThenCall(global::System.Action<Stubs.IBpEditBase> callback, global::KnockOff.Times times)
				{
					var tracking = new MethodTrackingImpl();
					_interceptor._sequence.Add((callback, times, tracking));
					return this;
				}

				/// <summary>Verify all Times constraints in the sequence were satisfied.</summary>
				public bool Verify()
				{
					foreach (var (_, times, tracking) in _interceptor._sequence)
					{
						if (!times.Verify(tracking.CallCount))
							return false;
					}
					return true;
				}

				/// <summary>Reset all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();
			}

		}

		/// <summary>Tracks and configures behavior for MarkDeleted.</summary>
		public sealed class IBpEditBase_MarkDeletedInterceptor
		{
			private readonly global::System.Collections.Generic.List<(global::System.Action<Stubs.IBpEditBase> Callback, global::KnockOff.Times Times, MethodTrackingImpl Tracking)> _sequence = new();
			private int _sequenceIndex;
			private int _unconfiguredCallCount;

			/// <summary>Total number of times this method was called (across all OnCall registrations).</summary>
			public int CallCount { get { int sum = _unconfiguredCallCount; foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>Whether this method was called at least once.</summary>
			public bool WasCalled => CallCount > 0;


			/// <summary>Configures callback that repeats forever. Returns tracking interface.</summary>
			public global::KnockOff.IMethodTracking OnCall(global::System.Action<Stubs.IBpEditBase> callback)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, global::KnockOff.Times.Forever, tracking));
				_sequenceIndex = 0;
				return tracking;
			}

			/// <summary>Configures callback with Times constraint. Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>> OnCall(global::System.Action<Stubs.IBpEditBase> callback, global::KnockOff.Times times)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, times, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(Stubs.IBpEditBase ko)
			{
				if (_sequence.Count == 0)
				{
					_unconfiguredCallCount++;
					if (ko.Strict) throw global::KnockOff.StubException.NotConfigured("", "MarkDeleted");
					return;
				}

				var (callback, times, tracking) = _sequence[_sequenceIndex];
				tracking.RecordCall();

				if (!times.IsForever && tracking.CallCount >= times.Count)
				{
					if (_sequenceIndex < _sequence.Count - 1)
						_sequenceIndex++;
					else if (tracking.CallCount > times.Count)
						throw global::KnockOff.StubException.SequenceExhausted("MarkDeleted");
				}

				callback(ko);
			}

			/// <summary>Resets all tracking state.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				foreach (var (_, _, tracking) in _sequence)
					tracking.Reset();
				_sequenceIndex = 0;
			}

			/// <summary>Verifies all Times constraints were satisfied. For Forever, verifies called at least once.</summary>
			public bool Verify()
			{
				foreach (var (_, times, tracking) in _sequence)
				{
					if (times.IsForever)
					{
						if (!tracking.WasCalled)
							return false;
					}
					else if (!times.Verify(tracking.CallCount))
						return false;
				}
				return true;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking
			{

				/// <summary>Number of times this callback was invoked.</summary>
				public int CallCount { get; private set; }

				/// <summary>True if CallCount > 0.</summary>
				public bool WasCalled => CallCount > 0;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>>
			{
				private readonly IBpEditBase_MarkDeletedInterceptor _interceptor;

				public MethodSequenceImpl(IBpEditBase_MarkDeletedInterceptor interceptor) => _interceptor = interceptor;

				/// <summary>Total calls across all callbacks in sequence.</summary>
				public int TotalCallCount
				{
					get
					{
						var total = 0;
						foreach (var (_, _, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Add another callback to the sequence.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>> ThenCall(global::System.Action<Stubs.IBpEditBase> callback, global::KnockOff.Times times)
				{
					var tracking = new MethodTrackingImpl();
					_interceptor._sequence.Add((callback, times, tracking));
					return this;
				}

				/// <summary>Verify all Times constraints in the sequence were satisfied.</summary>
				public bool Verify()
				{
					foreach (var (_, times, tracking) in _interceptor._sequence)
					{
						if (!times.Verify(tracking.CallCount))
							return false;
					}
					return true;
				}

				/// <summary>Reset all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();
			}

		}

		/// <summary>Tracks and configures behavior for MarkNew.</summary>
		public sealed class IBpEditBase_MarkNewInterceptor
		{
			private readonly global::System.Collections.Generic.List<(global::System.Action<Stubs.IBpEditBase> Callback, global::KnockOff.Times Times, MethodTrackingImpl Tracking)> _sequence = new();
			private int _sequenceIndex;
			private int _unconfiguredCallCount;

			/// <summary>Total number of times this method was called (across all OnCall registrations).</summary>
			public int CallCount { get { int sum = _unconfiguredCallCount; foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>Whether this method was called at least once.</summary>
			public bool WasCalled => CallCount > 0;


			/// <summary>Configures callback that repeats forever. Returns tracking interface.</summary>
			public global::KnockOff.IMethodTracking OnCall(global::System.Action<Stubs.IBpEditBase> callback)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, global::KnockOff.Times.Forever, tracking));
				_sequenceIndex = 0;
				return tracking;
			}

			/// <summary>Configures callback with Times constraint. Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>> OnCall(global::System.Action<Stubs.IBpEditBase> callback, global::KnockOff.Times times)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, times, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(Stubs.IBpEditBase ko)
			{
				if (_sequence.Count == 0)
				{
					_unconfiguredCallCount++;
					if (ko.Strict) throw global::KnockOff.StubException.NotConfigured("", "MarkNew");
					return;
				}

				var (callback, times, tracking) = _sequence[_sequenceIndex];
				tracking.RecordCall();

				if (!times.IsForever && tracking.CallCount >= times.Count)
				{
					if (_sequenceIndex < _sequence.Count - 1)
						_sequenceIndex++;
					else if (tracking.CallCount > times.Count)
						throw global::KnockOff.StubException.SequenceExhausted("MarkNew");
				}

				callback(ko);
			}

			/// <summary>Resets all tracking state.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				foreach (var (_, _, tracking) in _sequence)
					tracking.Reset();
				_sequenceIndex = 0;
			}

			/// <summary>Verifies all Times constraints were satisfied. For Forever, verifies called at least once.</summary>
			public bool Verify()
			{
				foreach (var (_, times, tracking) in _sequence)
				{
					if (times.IsForever)
					{
						if (!tracking.WasCalled)
							return false;
					}
					else if (!times.Verify(tracking.CallCount))
						return false;
				}
				return true;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking
			{

				/// <summary>Number of times this callback was invoked.</summary>
				public int CallCount { get; private set; }

				/// <summary>True if CallCount > 0.</summary>
				public bool WasCalled => CallCount > 0;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>>
			{
				private readonly IBpEditBase_MarkNewInterceptor _interceptor;

				public MethodSequenceImpl(IBpEditBase_MarkNewInterceptor interceptor) => _interceptor = interceptor;

				/// <summary>Total calls across all callbacks in sequence.</summary>
				public int TotalCallCount
				{
					get
					{
						var total = 0;
						foreach (var (_, _, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Add another callback to the sequence.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>> ThenCall(global::System.Action<Stubs.IBpEditBase> callback, global::KnockOff.Times times)
				{
					var tracking = new MethodTrackingImpl();
					_interceptor._sequence.Add((callback, times, tracking));
					return this;
				}

				/// <summary>Verify all Times constraints in the sequence were satisfied.</summary>
				public bool Verify()
				{
					foreach (var (_, times, tracking) in _interceptor._sequence)
					{
						if (!times.Verify(tracking.CallCount))
							return false;
					}
					return true;
				}

				/// <summary>Reset all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();
			}

		}

		/// <summary>Tracks and configures behavior for MarkOld.</summary>
		public sealed class IBpEditBase_MarkOldInterceptor
		{
			private readonly global::System.Collections.Generic.List<(global::System.Action<Stubs.IBpEditBase> Callback, global::KnockOff.Times Times, MethodTrackingImpl Tracking)> _sequence = new();
			private int _sequenceIndex;
			private int _unconfiguredCallCount;

			/// <summary>Total number of times this method was called (across all OnCall registrations).</summary>
			public int CallCount { get { int sum = _unconfiguredCallCount; foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>Whether this method was called at least once.</summary>
			public bool WasCalled => CallCount > 0;


			/// <summary>Configures callback that repeats forever. Returns tracking interface.</summary>
			public global::KnockOff.IMethodTracking OnCall(global::System.Action<Stubs.IBpEditBase> callback)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, global::KnockOff.Times.Forever, tracking));
				_sequenceIndex = 0;
				return tracking;
			}

			/// <summary>Configures callback with Times constraint. Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>> OnCall(global::System.Action<Stubs.IBpEditBase> callback, global::KnockOff.Times times)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, times, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(Stubs.IBpEditBase ko)
			{
				if (_sequence.Count == 0)
				{
					_unconfiguredCallCount++;
					if (ko.Strict) throw global::KnockOff.StubException.NotConfigured("", "MarkOld");
					return;
				}

				var (callback, times, tracking) = _sequence[_sequenceIndex];
				tracking.RecordCall();

				if (!times.IsForever && tracking.CallCount >= times.Count)
				{
					if (_sequenceIndex < _sequence.Count - 1)
						_sequenceIndex++;
					else if (tracking.CallCount > times.Count)
						throw global::KnockOff.StubException.SequenceExhausted("MarkOld");
				}

				callback(ko);
			}

			/// <summary>Resets all tracking state.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				foreach (var (_, _, tracking) in _sequence)
					tracking.Reset();
				_sequenceIndex = 0;
			}

			/// <summary>Verifies all Times constraints were satisfied. For Forever, verifies called at least once.</summary>
			public bool Verify()
			{
				foreach (var (_, times, tracking) in _sequence)
				{
					if (times.IsForever)
					{
						if (!tracking.WasCalled)
							return false;
					}
					else if (!times.Verify(tracking.CallCount))
						return false;
				}
				return true;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking
			{

				/// <summary>Number of times this callback was invoked.</summary>
				public int CallCount { get; private set; }

				/// <summary>True if CallCount > 0.</summary>
				public bool WasCalled => CallCount > 0;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>>
			{
				private readonly IBpEditBase_MarkOldInterceptor _interceptor;

				public MethodSequenceImpl(IBpEditBase_MarkOldInterceptor interceptor) => _interceptor = interceptor;

				/// <summary>Total calls across all callbacks in sequence.</summary>
				public int TotalCallCount
				{
					get
					{
						var total = 0;
						foreach (var (_, _, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Add another callback to the sequence.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase>> ThenCall(global::System.Action<Stubs.IBpEditBase> callback, global::KnockOff.Times times)
				{
					var tracking = new MethodTrackingImpl();
					_interceptor._sequence.Add((callback, times, tracking));
					return this;
				}

				/// <summary>Verify all Times constraints in the sequence were satisfied.</summary>
				public bool Verify()
				{
					foreach (var (_, times, tracking) in _interceptor._sequence)
					{
						if (!times.Verify(tracking.CallCount))
							return false;
					}
					return true;
				}

				/// <summary>Reset all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();
			}

		}

		/// <summary>Tracks and configures behavior for AddRule.</summary>
		public sealed class IBpEditBase_AddRuleInterceptor
		{
			private readonly global::System.Collections.Generic.List<(global::System.Action<Stubs.IBpEditBase, string, global::System.Func<bool>> Callback, global::KnockOff.Times Times, MethodTrackingImpl Tracking)> _sequence = new();
			private int _sequenceIndex;
			private int _unconfiguredCallCount;
			private (string property, global::System.Func<bool> rule)? _unconfiguredLastArgs;

			/// <summary>Total number of times this method was called (across all OnCall registrations).</summary>
			public int CallCount { get { int sum = _unconfiguredCallCount; foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>Whether this method was called at least once.</summary>
			public bool WasCalled => CallCount > 0;

			/// <summary>The arguments from the last call (from most recently called registration).</summary>
			public (string property, global::System.Func<bool> rule)? LastCallArgs { get { for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArgs; return _unconfiguredCallCount > 0 ? _unconfiguredLastArgs : default; } }


			/// <summary>Configures callback that repeats forever. Returns tracking interface.</summary>
			public global::KnockOff.IMethodTrackingArgs<(string property, global::System.Func<bool> rule)> OnCall(global::System.Action<Stubs.IBpEditBase, string, global::System.Func<bool>> callback)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, global::KnockOff.Times.Forever, tracking));
				_sequenceIndex = 0;
				return tracking;
			}

			/// <summary>Configures callback with Times constraint. Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase, string, global::System.Func<bool>>> OnCall(global::System.Action<Stubs.IBpEditBase, string, global::System.Func<bool>> callback, global::KnockOff.Times times)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, times, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(Stubs.IBpEditBase ko, string property, global::System.Func<bool> rule)
			{
				if (_sequence.Count == 0)
				{
					_unconfiguredCallCount++;
					_unconfiguredLastArgs = ((property, rule));
					if (ko.Strict) throw global::KnockOff.StubException.NotConfigured("", "AddRule");
					return;
				}

				var (callback, times, tracking) = _sequence[_sequenceIndex];
				tracking.RecordCall((property, rule));

				if (!times.IsForever && tracking.CallCount >= times.Count)
				{
					if (_sequenceIndex < _sequence.Count - 1)
						_sequenceIndex++;
					else if (tracking.CallCount > times.Count)
						throw global::KnockOff.StubException.SequenceExhausted("AddRule");
				}

				callback(ko, property, rule);
			}

			/// <summary>Resets all tracking state.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArgs = default;
				foreach (var (_, _, tracking) in _sequence)
					tracking.Reset();
				_sequenceIndex = 0;
			}

			/// <summary>Verifies all Times constraints were satisfied. For Forever, verifies called at least once.</summary>
			public bool Verify()
			{
				foreach (var (_, times, tracking) in _sequence)
				{
					if (times.IsForever)
					{
						if (!tracking.WasCalled)
							return false;
					}
					else if (!times.Verify(tracking.CallCount))
						return false;
				}
				return true;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTrackingArgs<(string property, global::System.Func<bool> rule)>
			{
				private (string property, global::System.Func<bool> rule) _lastArgs;

				/// <summary>Number of times this callback was invoked.</summary>
				public int CallCount { get; private set; }

				/// <summary>True if CallCount > 0.</summary>
				public bool WasCalled => CallCount > 0;

				/// <summary>Last arguments passed to this callback. Default if never called.</summary>
				public (string property, global::System.Func<bool> rule) LastArgs => _lastArgs;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall((string property, global::System.Func<bool> rule) args) { CallCount++; _lastArgs = args; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArgs = default; }
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase, string, global::System.Func<bool>>>
			{
				private readonly IBpEditBase_AddRuleInterceptor _interceptor;

				public MethodSequenceImpl(IBpEditBase_AddRuleInterceptor interceptor) => _interceptor = interceptor;

				/// <summary>Total calls across all callbacks in sequence.</summary>
				public int TotalCallCount
				{
					get
					{
						var total = 0;
						foreach (var (_, _, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Add another callback to the sequence.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase, string, global::System.Func<bool>>> ThenCall(global::System.Action<Stubs.IBpEditBase, string, global::System.Func<bool>> callback, global::KnockOff.Times times)
				{
					var tracking = new MethodTrackingImpl();
					_interceptor._sequence.Add((callback, times, tracking));
					return this;
				}

				/// <summary>Verify all Times constraints in the sequence were satisfied.</summary>
				public bool Verify()
				{
					foreach (var (_, times, tracking) in _interceptor._sequence)
					{
						if (!times.Verify(tracking.CallCount))
							return false;
					}
					return true;
				}

				/// <summary>Reset all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();
			}

		}

		/// <summary>Tracks and configures behavior for RemoveRule.</summary>
		public sealed class IBpEditBase_RemoveRuleInterceptor
		{
			private readonly global::System.Collections.Generic.List<(global::System.Action<Stubs.IBpEditBase, string> Callback, global::KnockOff.Times Times, MethodTrackingImpl Tracking)> _sequence = new();
			private int _sequenceIndex;
			private int _unconfiguredCallCount;
			private string? _unconfiguredLastArg;

			/// <summary>Total number of times this method was called (across all OnCall registrations).</summary>
			public int CallCount { get { int sum = _unconfiguredCallCount; foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>Whether this method was called at least once.</summary>
			public bool WasCalled => CallCount > 0;

			/// <summary>The argument from the last call (from most recently called registration).</summary>
			public string? LastCallArg { get { for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArg; return _unconfiguredCallCount > 0 ? _unconfiguredLastArg : default; } }


			/// <summary>Configures callback that repeats forever. Returns tracking interface.</summary>
			public global::KnockOff.IMethodTracking<string> OnCall(global::System.Action<Stubs.IBpEditBase, string> callback)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, global::KnockOff.Times.Forever, tracking));
				_sequenceIndex = 0;
				return tracking;
			}

			/// <summary>Configures callback with Times constraint. Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase, string>> OnCall(global::System.Action<Stubs.IBpEditBase, string> callback, global::KnockOff.Times times)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, times, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(Stubs.IBpEditBase ko, string property)
			{
				if (_sequence.Count == 0)
				{
					_unconfiguredCallCount++;
					_unconfiguredLastArg = property;
					if (ko.Strict) throw global::KnockOff.StubException.NotConfigured("", "RemoveRule");
					return;
				}

				var (callback, times, tracking) = _sequence[_sequenceIndex];
				tracking.RecordCall(property);

				if (!times.IsForever && tracking.CallCount >= times.Count)
				{
					if (_sequenceIndex < _sequence.Count - 1)
						_sequenceIndex++;
					else if (tracking.CallCount > times.Count)
						throw global::KnockOff.StubException.SequenceExhausted("RemoveRule");
				}

				callback(ko, property);
			}

			/// <summary>Resets all tracking state.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArg = default;
				foreach (var (_, _, tracking) in _sequence)
					tracking.Reset();
				_sequenceIndex = 0;
			}

			/// <summary>Verifies all Times constraints were satisfied. For Forever, verifies called at least once.</summary>
			public bool Verify()
			{
				foreach (var (_, times, tracking) in _sequence)
				{
					if (times.IsForever)
					{
						if (!tracking.WasCalled)
							return false;
					}
					else if (!times.Verify(tracking.CallCount))
						return false;
				}
				return true;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking<string>
			{
				private string _lastArg = default!;

				/// <summary>Number of times this callback was invoked.</summary>
				public int CallCount { get; private set; }

				/// <summary>True if CallCount > 0.</summary>
				public bool WasCalled => CallCount > 0;

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public string LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(string property) { CallCount++; _lastArg = property; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase, string>>
			{
				private readonly IBpEditBase_RemoveRuleInterceptor _interceptor;

				public MethodSequenceImpl(IBpEditBase_RemoveRuleInterceptor interceptor) => _interceptor = interceptor;

				/// <summary>Total calls across all callbacks in sequence.</summary>
				public int TotalCallCount
				{
					get
					{
						var total = 0;
						foreach (var (_, _, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Add another callback to the sequence.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase, string>> ThenCall(global::System.Action<Stubs.IBpEditBase, string> callback, global::KnockOff.Times times)
				{
					var tracking = new MethodTrackingImpl();
					_interceptor._sequence.Add((callback, times, tracking));
					return this;
				}

				/// <summary>Verify all Times constraints in the sequence were satisfied.</summary>
				public bool Verify()
				{
					foreach (var (_, times, tracking) in _interceptor._sequence)
					{
						if (!times.Verify(tracking.CallCount))
							return false;
					}
					return true;
				}

				/// <summary>Reset all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();
			}

		}

		/// <summary>Tracks and configures behavior for GetBrokenRules.</summary>
		public sealed class IBpEditBase_GetBrokenRulesInterceptor
		{
			/// <summary>Delegate for GetBrokenRules.</summary>
			public delegate global::System.Collections.Generic.IEnumerable<string> GetBrokenRulesDelegate(Stubs.IBpEditBase ko);

			private readonly global::System.Collections.Generic.List<(GetBrokenRulesDelegate Callback, global::KnockOff.Times Times, MethodTrackingImpl Tracking)> _sequence = new();
			private int _sequenceIndex;
			private int _unconfiguredCallCount;

			/// <summary>Total number of times this method was called (across all OnCall registrations).</summary>
			public int CallCount { get { int sum = _unconfiguredCallCount; foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>Whether this method was called at least once.</summary>
			public bool WasCalled => CallCount > 0;


			/// <summary>Configures callback that repeats forever. Returns tracking interface.</summary>
			public global::KnockOff.IMethodTracking OnCall(GetBrokenRulesDelegate callback)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, global::KnockOff.Times.Forever, tracking));
				_sequenceIndex = 0;
				return tracking;
			}

			/// <summary>Configures callback with Times constraint. Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<GetBrokenRulesDelegate> OnCall(GetBrokenRulesDelegate callback, global::KnockOff.Times times)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, times, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal global::System.Collections.Generic.IEnumerable<string> Invoke(Stubs.IBpEditBase ko)
			{
				if (_sequence.Count == 0)
				{
					_unconfiguredCallCount++;
					if (ko.Strict) throw global::KnockOff.StubException.NotConfigured("", "GetBrokenRules");
					throw new global::System.InvalidOperationException("No implementation provided for GetBrokenRules. Configure via OnCall.");
				}

				var (callback, times, tracking) = _sequence[_sequenceIndex];
				tracking.RecordCall();

				if (!times.IsForever && tracking.CallCount >= times.Count)
				{
					if (_sequenceIndex < _sequence.Count - 1)
						_sequenceIndex++;
					else if (tracking.CallCount > times.Count)
						throw global::KnockOff.StubException.SequenceExhausted("GetBrokenRules");
				}

				return callback(ko);
			}

			/// <summary>Resets all tracking state.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				foreach (var (_, _, tracking) in _sequence)
					tracking.Reset();
				_sequenceIndex = 0;
			}

			/// <summary>Verifies all Times constraints were satisfied. For Forever, verifies called at least once.</summary>
			public bool Verify()
			{
				foreach (var (_, times, tracking) in _sequence)
				{
					if (times.IsForever)
					{
						if (!tracking.WasCalled)
							return false;
					}
					else if (!times.Verify(tracking.CallCount))
						return false;
				}
				return true;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking
			{

				/// <summary>Number of times this callback was invoked.</summary>
				public int CallCount { get; private set; }

				/// <summary>True if CallCount > 0.</summary>
				public bool WasCalled => CallCount > 0;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<GetBrokenRulesDelegate>
			{
				private readonly IBpEditBase_GetBrokenRulesInterceptor _interceptor;

				public MethodSequenceImpl(IBpEditBase_GetBrokenRulesInterceptor interceptor) => _interceptor = interceptor;

				/// <summary>Total calls across all callbacks in sequence.</summary>
				public int TotalCallCount
				{
					get
					{
						var total = 0;
						foreach (var (_, _, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Add another callback to the sequence.</summary>
				public global::KnockOff.IMethodSequence<GetBrokenRulesDelegate> ThenCall(GetBrokenRulesDelegate callback, global::KnockOff.Times times)
				{
					var tracking = new MethodTrackingImpl();
					_interceptor._sequence.Add((callback, times, tracking));
					return this;
				}

				/// <summary>Verify all Times constraints in the sequence were satisfied.</summary>
				public bool Verify()
				{
					foreach (var (_, times, tracking) in _interceptor._sequence)
					{
						if (!times.Verify(tracking.CallCount))
							return false;
					}
					return true;
				}

				/// <summary>Reset all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();
			}

		}

		/// <summary>Tracks and configures behavior for AddChild.</summary>
		public sealed class IBpEditBase_AddChildInterceptor
		{
			private readonly global::System.Collections.Generic.List<(global::System.Action<Stubs.IBpEditBase, object> Callback, global::KnockOff.Times Times, MethodTrackingImpl Tracking)> _sequence = new();
			private int _sequenceIndex;
			private int _unconfiguredCallCount;
			private object? _unconfiguredLastArg;

			/// <summary>Total number of times this method was called (across all OnCall registrations).</summary>
			public int CallCount { get { int sum = _unconfiguredCallCount; foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>Whether this method was called at least once.</summary>
			public bool WasCalled => CallCount > 0;

			/// <summary>The argument from the last call (from most recently called registration).</summary>
			public object? LastCallArg { get { for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArg; return _unconfiguredCallCount > 0 ? _unconfiguredLastArg : default; } }


			/// <summary>Configures callback that repeats forever. Returns tracking interface.</summary>
			public global::KnockOff.IMethodTracking<object> OnCall(global::System.Action<Stubs.IBpEditBase, object> callback)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, global::KnockOff.Times.Forever, tracking));
				_sequenceIndex = 0;
				return tracking;
			}

			/// <summary>Configures callback with Times constraint. Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase, object>> OnCall(global::System.Action<Stubs.IBpEditBase, object> callback, global::KnockOff.Times times)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, times, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(Stubs.IBpEditBase ko, object child)
			{
				if (_sequence.Count == 0)
				{
					_unconfiguredCallCount++;
					_unconfiguredLastArg = child;
					if (ko.Strict) throw global::KnockOff.StubException.NotConfigured("", "AddChild");
					return;
				}

				var (callback, times, tracking) = _sequence[_sequenceIndex];
				tracking.RecordCall(child);

				if (!times.IsForever && tracking.CallCount >= times.Count)
				{
					if (_sequenceIndex < _sequence.Count - 1)
						_sequenceIndex++;
					else if (tracking.CallCount > times.Count)
						throw global::KnockOff.StubException.SequenceExhausted("AddChild");
				}

				callback(ko, child);
			}

			/// <summary>Resets all tracking state.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArg = default;
				foreach (var (_, _, tracking) in _sequence)
					tracking.Reset();
				_sequenceIndex = 0;
			}

			/// <summary>Verifies all Times constraints were satisfied. For Forever, verifies called at least once.</summary>
			public bool Verify()
			{
				foreach (var (_, times, tracking) in _sequence)
				{
					if (times.IsForever)
					{
						if (!tracking.WasCalled)
							return false;
					}
					else if (!times.Verify(tracking.CallCount))
						return false;
				}
				return true;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking<object>
			{
				private object _lastArg = default!;

				/// <summary>Number of times this callback was invoked.</summary>
				public int CallCount { get; private set; }

				/// <summary>True if CallCount > 0.</summary>
				public bool WasCalled => CallCount > 0;

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public object LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(object child) { CallCount++; _lastArg = child; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase, object>>
			{
				private readonly IBpEditBase_AddChildInterceptor _interceptor;

				public MethodSequenceImpl(IBpEditBase_AddChildInterceptor interceptor) => _interceptor = interceptor;

				/// <summary>Total calls across all callbacks in sequence.</summary>
				public int TotalCallCount
				{
					get
					{
						var total = 0;
						foreach (var (_, _, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Add another callback to the sequence.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase, object>> ThenCall(global::System.Action<Stubs.IBpEditBase, object> callback, global::KnockOff.Times times)
				{
					var tracking = new MethodTrackingImpl();
					_interceptor._sequence.Add((callback, times, tracking));
					return this;
				}

				/// <summary>Verify all Times constraints in the sequence were satisfied.</summary>
				public bool Verify()
				{
					foreach (var (_, times, tracking) in _interceptor._sequence)
					{
						if (!times.Verify(tracking.CallCount))
							return false;
					}
					return true;
				}

				/// <summary>Reset all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();
			}

		}

		/// <summary>Tracks and configures behavior for RemoveChild.</summary>
		public sealed class IBpEditBase_RemoveChildInterceptor
		{
			private readonly global::System.Collections.Generic.List<(global::System.Action<Stubs.IBpEditBase, object> Callback, global::KnockOff.Times Times, MethodTrackingImpl Tracking)> _sequence = new();
			private int _sequenceIndex;
			private int _unconfiguredCallCount;
			private object? _unconfiguredLastArg;

			/// <summary>Total number of times this method was called (across all OnCall registrations).</summary>
			public int CallCount { get { int sum = _unconfiguredCallCount; foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>Whether this method was called at least once.</summary>
			public bool WasCalled => CallCount > 0;

			/// <summary>The argument from the last call (from most recently called registration).</summary>
			public object? LastCallArg { get { for (int i = _sequence.Count - 1; i >= 0; i--) if (_sequence[i].Tracking.CallCount > 0) return _sequence[i].Tracking.LastArg; return _unconfiguredCallCount > 0 ? _unconfiguredLastArg : default; } }


			/// <summary>Configures callback that repeats forever. Returns tracking interface.</summary>
			public global::KnockOff.IMethodTracking<object> OnCall(global::System.Action<Stubs.IBpEditBase, object> callback)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, global::KnockOff.Times.Forever, tracking));
				_sequenceIndex = 0;
				return tracking;
			}

			/// <summary>Configures callback with Times constraint. Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase, object>> OnCall(global::System.Action<Stubs.IBpEditBase, object> callback, global::KnockOff.Times times)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, times, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal void Invoke(Stubs.IBpEditBase ko, object child)
			{
				if (_sequence.Count == 0)
				{
					_unconfiguredCallCount++;
					_unconfiguredLastArg = child;
					if (ko.Strict) throw global::KnockOff.StubException.NotConfigured("", "RemoveChild");
					return;
				}

				var (callback, times, tracking) = _sequence[_sequenceIndex];
				tracking.RecordCall(child);

				if (!times.IsForever && tracking.CallCount >= times.Count)
				{
					if (_sequenceIndex < _sequence.Count - 1)
						_sequenceIndex++;
					else if (tracking.CallCount > times.Count)
						throw global::KnockOff.StubException.SequenceExhausted("RemoveChild");
				}

				callback(ko, child);
			}

			/// <summary>Resets all tracking state.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				_unconfiguredLastArg = default;
				foreach (var (_, _, tracking) in _sequence)
					tracking.Reset();
				_sequenceIndex = 0;
			}

			/// <summary>Verifies all Times constraints were satisfied. For Forever, verifies called at least once.</summary>
			public bool Verify()
			{
				foreach (var (_, times, tracking) in _sequence)
				{
					if (times.IsForever)
					{
						if (!tracking.WasCalled)
							return false;
					}
					else if (!times.Verify(tracking.CallCount))
						return false;
				}
				return true;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking<object>
			{
				private object _lastArg = default!;

				/// <summary>Number of times this callback was invoked.</summary>
				public int CallCount { get; private set; }

				/// <summary>True if CallCount > 0.</summary>
				public bool WasCalled => CallCount > 0;

				/// <summary>Last argument passed to this callback. Default if never called.</summary>
				public object LastArg => _lastArg;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall(object child) { CallCount++; _lastArg = child; }

				/// <summary>Resets tracking state.</summary>
				public void Reset() { CallCount = 0; _lastArg = default!; }
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase, object>>
			{
				private readonly IBpEditBase_RemoveChildInterceptor _interceptor;

				public MethodSequenceImpl(IBpEditBase_RemoveChildInterceptor interceptor) => _interceptor = interceptor;

				/// <summary>Total calls across all callbacks in sequence.</summary>
				public int TotalCallCount
				{
					get
					{
						var total = 0;
						foreach (var (_, _, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Add another callback to the sequence.</summary>
				public global::KnockOff.IMethodSequence<global::System.Action<Stubs.IBpEditBase, object>> ThenCall(global::System.Action<Stubs.IBpEditBase, object> callback, global::KnockOff.Times times)
				{
					var tracking = new MethodTrackingImpl();
					_interceptor._sequence.Add((callback, times, tracking));
					return this;
				}

				/// <summary>Verify all Times constraints in the sequence were satisfied.</summary>
				public bool Verify()
				{
					foreach (var (_, times, tracking) in _interceptor._sequence)
					{
						if (!times.Verify(tracking.CallCount))
							return false;
					}
					return true;
				}

				/// <summary>Reset all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();
			}

		}

		/// <summary>Tracks and configures behavior for GetChildren.</summary>
		public sealed class IBpEditBase_GetChildrenInterceptor
		{
			/// <summary>Delegate for GetChildren.</summary>
			public delegate global::System.Collections.Generic.IEnumerable<object> GetChildrenDelegate(Stubs.IBpEditBase ko);

			private readonly global::System.Collections.Generic.List<(GetChildrenDelegate Callback, global::KnockOff.Times Times, MethodTrackingImpl Tracking)> _sequence = new();
			private int _sequenceIndex;
			private int _unconfiguredCallCount;

			/// <summary>Total number of times this method was called (across all OnCall registrations).</summary>
			public int CallCount { get { int sum = _unconfiguredCallCount; foreach (var s in _sequence) sum += s.Tracking.CallCount; return sum; } }

			/// <summary>Whether this method was called at least once.</summary>
			public bool WasCalled => CallCount > 0;


			/// <summary>Configures callback that repeats forever. Returns tracking interface.</summary>
			public global::KnockOff.IMethodTracking OnCall(GetChildrenDelegate callback)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, global::KnockOff.Times.Forever, tracking));
				_sequenceIndex = 0;
				return tracking;
			}

			/// <summary>Configures callback with Times constraint. Returns sequence for ThenCall chaining.</summary>
			public global::KnockOff.IMethodSequence<GetChildrenDelegate> OnCall(GetChildrenDelegate callback, global::KnockOff.Times times)
			{
				var tracking = new MethodTrackingImpl();
				_sequence.Clear();
				_sequence.Add((callback, times, tracking));
				_sequenceIndex = 0;
				return new MethodSequenceImpl(this);
			}

			/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>
			internal global::System.Collections.Generic.IEnumerable<object> Invoke(Stubs.IBpEditBase ko)
			{
				if (_sequence.Count == 0)
				{
					_unconfiguredCallCount++;
					if (ko.Strict) throw global::KnockOff.StubException.NotConfigured("", "GetChildren");
					throw new global::System.InvalidOperationException("No implementation provided for GetChildren. Configure via OnCall.");
				}

				var (callback, times, tracking) = _sequence[_sequenceIndex];
				tracking.RecordCall();

				if (!times.IsForever && tracking.CallCount >= times.Count)
				{
					if (_sequenceIndex < _sequence.Count - 1)
						_sequenceIndex++;
					else if (tracking.CallCount > times.Count)
						throw global::KnockOff.StubException.SequenceExhausted("GetChildren");
				}

				return callback(ko);
			}

			/// <summary>Resets all tracking state.</summary>
			public void Reset()
			{
				_unconfiguredCallCount = 0;
				foreach (var (_, _, tracking) in _sequence)
					tracking.Reset();
				_sequenceIndex = 0;
			}

			/// <summary>Verifies all Times constraints were satisfied. For Forever, verifies called at least once.</summary>
			public bool Verify()
			{
				foreach (var (_, times, tracking) in _sequence)
				{
					if (times.IsForever)
					{
						if (!tracking.WasCalled)
							return false;
					}
					else if (!times.Verify(tracking.CallCount))
						return false;
				}
				return true;
			}

			/// <summary>Tracks invocations for this callback registration.</summary>
			private sealed class MethodTrackingImpl : global::KnockOff.IMethodTracking
			{

				/// <summary>Number of times this callback was invoked.</summary>
				public int CallCount { get; private set; }

				/// <summary>True if CallCount > 0.</summary>
				public bool WasCalled => CallCount > 0;

				/// <summary>Records a call to this callback.</summary>
				public void RecordCall() => CallCount++;

				/// <summary>Resets tracking state.</summary>
				public void Reset() => CallCount = 0;
			}

			/// <summary>Sequence implementation for ThenCall chaining.</summary>
			private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<GetChildrenDelegate>
			{
				private readonly IBpEditBase_GetChildrenInterceptor _interceptor;

				public MethodSequenceImpl(IBpEditBase_GetChildrenInterceptor interceptor) => _interceptor = interceptor;

				/// <summary>Total calls across all callbacks in sequence.</summary>
				public int TotalCallCount
				{
					get
					{
						var total = 0;
						foreach (var (_, _, tracking) in _interceptor._sequence)
							total += tracking.CallCount;
						return total;
					}
				}

				/// <summary>Add another callback to the sequence.</summary>
				public global::KnockOff.IMethodSequence<GetChildrenDelegate> ThenCall(GetChildrenDelegate callback, global::KnockOff.Times times)
				{
					var tracking = new MethodTrackingImpl();
					_interceptor._sequence.Add((callback, times, tracking));
					return this;
				}

				/// <summary>Verify all Times constraints in the sequence were satisfied.</summary>
				public bool Verify()
				{
					foreach (var (_, times, tracking) in _interceptor._sequence)
					{
						if (!times.Verify(tracking.CallCount))
							return false;
					}
					return true;
				}

				/// <summary>Reset all tracking in the sequence.</summary>
				public void Reset() => _interceptor.Reset();
			}

		}

		/// <summary>Interceptor for IBpEditBase.PropertyChanged event.</summary>
		public sealed class IBpEditBase_PropertyChangedInterceptor
		{
			/// <summary>Number of times the event was subscribed to.</summary>
			public int AddCount { get; private set; }

			/// <summary>Number of times the event was unsubscribed from.</summary>
			public int RemoveCount { get; private set; }

			/// <summary>The backing delegate for raising the event.</summary>
			public global::System.EventHandler? Handler { get; private set; }

			/// <summary>Records an event subscription.</summary>
			public void RecordAdd(global::System.EventHandler? handler) { AddCount++; Handler = (global::System.EventHandler?)global::System.Delegate.Combine(Handler, handler); }

			/// <summary>Records an event unsubscription.</summary>
			public void RecordRemove(global::System.EventHandler? handler) { RemoveCount++; Handler = (global::System.EventHandler?)global::System.Delegate.Remove(Handler, handler); }

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { AddCount = 0; RemoveCount = 0; Handler = null; }
		}

		/// <summary>Interceptor for IBpEditBase.Saving event.</summary>
		public sealed class IBpEditBase_SavingInterceptor
		{
			/// <summary>Number of times the event was subscribed to.</summary>
			public int AddCount { get; private set; }

			/// <summary>Number of times the event was unsubscribed from.</summary>
			public int RemoveCount { get; private set; }

			/// <summary>The backing delegate for raising the event.</summary>
			public global::System.EventHandler? Handler { get; private set; }

			/// <summary>Records an event subscription.</summary>
			public void RecordAdd(global::System.EventHandler? handler) { AddCount++; Handler = (global::System.EventHandler?)global::System.Delegate.Combine(Handler, handler); }

			/// <summary>Records an event unsubscription.</summary>
			public void RecordRemove(global::System.EventHandler? handler) { RemoveCount++; Handler = (global::System.EventHandler?)global::System.Delegate.Remove(Handler, handler); }

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { AddCount = 0; RemoveCount = 0; Handler = null; }
		}

		/// <summary>Interceptor for IBpEditBase.Saved event.</summary>
		public sealed class IBpEditBase_SavedInterceptor
		{
			/// <summary>Number of times the event was subscribed to.</summary>
			public int AddCount { get; private set; }

			/// <summary>Number of times the event was unsubscribed from.</summary>
			public int RemoveCount { get; private set; }

			/// <summary>The backing delegate for raising the event.</summary>
			public global::System.EventHandler? Handler { get; private set; }

			/// <summary>Records an event subscription.</summary>
			public void RecordAdd(global::System.EventHandler? handler) { AddCount++; Handler = (global::System.EventHandler?)global::System.Delegate.Combine(Handler, handler); }

			/// <summary>Records an event unsubscription.</summary>
			public void RecordRemove(global::System.EventHandler? handler) { RemoveCount++; Handler = (global::System.EventHandler?)global::System.Delegate.Remove(Handler, handler); }

			/// <summary>Resets all tracking state.</summary>
			public void Reset() { AddCount = 0; RemoveCount = 0; Handler = null; }
		}

		/// <summary>Stub implementation of global::KnockOff.Documentation.Samples.Guides.IBpEditBase.</summary>
		public class IBpEditBase : global::KnockOff.Documentation.Samples.Guides.IBpEditBase, global::KnockOff.IKnockOffStub
		{
			/// <summary>Interceptor for IsValid.</summary>
			public IBpEditBase_IsValidInterceptor IsValid { get; } = new();

			/// <summary>Interceptor for IsSelfValid.</summary>
			public IBpEditBase_IsSelfValidInterceptor IsSelfValid { get; } = new();

			/// <summary>Interceptor for IsDirty.</summary>
			public IBpEditBase_IsDirtyInterceptor IsDirty { get; } = new();

			/// <summary>Interceptor for IsSelfDirty.</summary>
			public IBpEditBase_IsSelfDirtyInterceptor IsSelfDirty { get; } = new();

			/// <summary>Interceptor for IsDeleted.</summary>
			public IBpEditBase_IsDeletedInterceptor IsDeleted { get; } = new();

			/// <summary>Interceptor for IsNew.</summary>
			public IBpEditBase_IsNewInterceptor IsNew { get; } = new();

			/// <summary>Interceptor for IsSavable.</summary>
			public IBpEditBase_IsSavableInterceptor IsSavable { get; } = new();

			/// <summary>Interceptor for Id.</summary>
			public IBpEditBase_IdInterceptor Id { get; } = new();

			/// <summary>Interceptor for Name.</summary>
			public IBpEditBase_NameInterceptor Name { get; } = new();

			/// <summary>Interceptor for BeginEdit.</summary>
			public IBpEditBase_BeginEditInterceptor BeginEdit { get; } = new();

			/// <summary>Interceptor for CancelEdit.</summary>
			public IBpEditBase_CancelEditInterceptor CancelEdit { get; } = new();

			/// <summary>Interceptor for ApplyEdit.</summary>
			public IBpEditBase_ApplyEditInterceptor ApplyEdit { get; } = new();

			/// <summary>Interceptor for MarkDeleted.</summary>
			public IBpEditBase_MarkDeletedInterceptor MarkDeleted { get; } = new();

			/// <summary>Interceptor for MarkNew.</summary>
			public IBpEditBase_MarkNewInterceptor MarkNew { get; } = new();

			/// <summary>Interceptor for MarkOld.</summary>
			public IBpEditBase_MarkOldInterceptor MarkOld { get; } = new();

			/// <summary>Interceptor for AddRule.</summary>
			public IBpEditBase_AddRuleInterceptor AddRule { get; } = new();

			/// <summary>Interceptor for RemoveRule.</summary>
			public IBpEditBase_RemoveRuleInterceptor RemoveRule { get; } = new();

			/// <summary>Interceptor for GetBrokenRules.</summary>
			public IBpEditBase_GetBrokenRulesInterceptor GetBrokenRules { get; } = new();

			/// <summary>Interceptor for AddChild.</summary>
			public IBpEditBase_AddChildInterceptor AddChild { get; } = new();

			/// <summary>Interceptor for RemoveChild.</summary>
			public IBpEditBase_RemoveChildInterceptor RemoveChild { get; } = new();

			/// <summary>Interceptor for GetChildren.</summary>
			public IBpEditBase_GetChildrenInterceptor GetChildren { get; } = new();

			/// <summary>Interceptor for PropertyChanged event.</summary>
			public IBpEditBase_PropertyChangedInterceptor PropertyChangedInterceptor { get; } = new();

			/// <summary>Interceptor for Saving event.</summary>
			public IBpEditBase_SavingInterceptor SavingInterceptor { get; } = new();

			/// <summary>Interceptor for Saved event.</summary>
			public IBpEditBase_SavedInterceptor SavedInterceptor { get; } = new();

			bool global::KnockOff.Documentation.Samples.Guides.IBpEditBase.IsValid
			{
				get
				{
					IsValid.RecordGet();
					if (IsValid.OnGet is { } onGet) return onGet(this);
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IBpEditBase", "IsValid");
					return IsValid.Value;
				}
			}

			bool global::KnockOff.Documentation.Samples.Guides.IBpEditBase.IsSelfValid
			{
				get
				{
					IsSelfValid.RecordGet();
					if (IsSelfValid.OnGet is { } onGet) return onGet(this);
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IBpEditBase", "IsSelfValid");
					return IsSelfValid.Value;
				}
			}

			bool global::KnockOff.Documentation.Samples.Guides.IBpEditBase.IsDirty
			{
				get
				{
					IsDirty.RecordGet();
					if (IsDirty.OnGet is { } onGet) return onGet(this);
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IBpEditBase", "IsDirty");
					return IsDirty.Value;
				}
			}

			bool global::KnockOff.Documentation.Samples.Guides.IBpEditBase.IsSelfDirty
			{
				get
				{
					IsSelfDirty.RecordGet();
					if (IsSelfDirty.OnGet is { } onGet) return onGet(this);
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IBpEditBase", "IsSelfDirty");
					return IsSelfDirty.Value;
				}
			}

			bool global::KnockOff.Documentation.Samples.Guides.IBpEditBase.IsDeleted
			{
				get
				{
					IsDeleted.RecordGet();
					if (IsDeleted.OnGet is { } onGet) return onGet(this);
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IBpEditBase", "IsDeleted");
					return IsDeleted.Value;
				}
			}

			bool global::KnockOff.Documentation.Samples.Guides.IBpEditBase.IsNew
			{
				get
				{
					IsNew.RecordGet();
					if (IsNew.OnGet is { } onGet) return onGet(this);
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IBpEditBase", "IsNew");
					return IsNew.Value;
				}
			}

			bool global::KnockOff.Documentation.Samples.Guides.IBpEditBase.IsSavable
			{
				get
				{
					IsSavable.RecordGet();
					if (IsSavable.OnGet is { } onGet) return onGet(this);
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IBpEditBase", "IsSavable");
					return IsSavable.Value;
				}
			}

			int global::KnockOff.Documentation.Samples.Guides.IBpEditBase.Id
			{
				get
				{
					Id.RecordGet();
					if (Id.OnGet is { } onGet) return onGet(this);
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IBpEditBase", "Id");
					return Id.Value;
				}
				set
				{
					Id.RecordSet(value);
					if (Id.OnSet is { } onSet) { onSet(this, value); return; }
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IBpEditBase", "Id");
					Id.Value = value;
				}
			}

			string global::KnockOff.Documentation.Samples.Guides.IBpEditBase.Name
			{
				get
				{
					Name.RecordGet();
					if (Name.OnGet is { } onGet) return onGet(this);
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IBpEditBase", "Name");
					return Name.Value;
				}
				set
				{
					Name.RecordSet(value);
					if (Name.OnSet is { } onSet) { onSet(this, value); return; }
					if (Strict) throw global::KnockOff.StubException.NotConfigured("IBpEditBase", "Name");
					Name.Value = value;
				}
			}

			void global::KnockOff.Documentation.Samples.Guides.IBpEditBase.BeginEdit()
			{
				BeginEdit.Invoke(this);
			}

			void global::KnockOff.Documentation.Samples.Guides.IBpEditBase.CancelEdit()
			{
				CancelEdit.Invoke(this);
			}

			void global::KnockOff.Documentation.Samples.Guides.IBpEditBase.ApplyEdit()
			{
				ApplyEdit.Invoke(this);
			}

			void global::KnockOff.Documentation.Samples.Guides.IBpEditBase.MarkDeleted()
			{
				MarkDeleted.Invoke(this);
			}

			void global::KnockOff.Documentation.Samples.Guides.IBpEditBase.MarkNew()
			{
				MarkNew.Invoke(this);
			}

			void global::KnockOff.Documentation.Samples.Guides.IBpEditBase.MarkOld()
			{
				MarkOld.Invoke(this);
			}

			void global::KnockOff.Documentation.Samples.Guides.IBpEditBase.AddRule(string property, global::System.Func<bool> rule)
			{
				AddRule.Invoke(this, property, rule);
			}

			void global::KnockOff.Documentation.Samples.Guides.IBpEditBase.RemoveRule(string property)
			{
				RemoveRule.Invoke(this, property);
			}

			global::System.Collections.Generic.IEnumerable<string> global::KnockOff.Documentation.Samples.Guides.IBpEditBase.GetBrokenRules()
			{
				return GetBrokenRules.Invoke(this);
			}

			void global::KnockOff.Documentation.Samples.Guides.IBpEditBase.AddChild(object child)
			{
				AddChild.Invoke(this, child);
			}

			void global::KnockOff.Documentation.Samples.Guides.IBpEditBase.RemoveChild(object child)
			{
				RemoveChild.Invoke(this, child);
			}

			global::System.Collections.Generic.IEnumerable<object> global::KnockOff.Documentation.Samples.Guides.IBpEditBase.GetChildren()
			{
				return GetChildren.Invoke(this);
			}

			event global::System.EventHandler? global::KnockOff.Documentation.Samples.Guides.IBpEditBase.PropertyChanged
			{
				add => PropertyChangedInterceptor.RecordAdd(value);
				remove => PropertyChangedInterceptor.RecordRemove(value);
			}

			event global::System.EventHandler? global::KnockOff.Documentation.Samples.Guides.IBpEditBase.Saving
			{
				add => SavingInterceptor.RecordAdd(value);
				remove => SavingInterceptor.RecordRemove(value);
			}

			event global::System.EventHandler? global::KnockOff.Documentation.Samples.Guides.IBpEditBase.Saved
			{
				add => SavedInterceptor.RecordAdd(value);
				remove => SavedInterceptor.RecordRemove(value);
			}

			/// <summary>The global::KnockOff.Documentation.Samples.Guides.IBpEditBase instance. Use for passing to code expecting the interface.</summary>
			public global::KnockOff.Documentation.Samples.Guides.IBpEditBase Object => this;

			/// <summary>When true, unconfigured method calls throw StubException instead of returning default.</summary>
			public bool Strict { get; set; } = false;

			/// <summary>Creates a new instance of the stub.</summary>
			/// <param name="strict">When true, unconfigured method calls throw StubException.</param>
			public IBpEditBase(bool strict = false)
			{
				Strict = strict;
			}

		}

	}
}
