// <auto-generated/> - Partial class extracted from KnockOffGenerator.cs
#nullable enable
using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;

namespace KnockOff;

public partial class KnockOffGenerator
{
	#region Class Stub Generation

	/// <summary>
	/// Generates a class stub using composition pattern (wrapper + nested Impl class).
	/// </summary>
	private static void GenerateClassStubClass(
		System.Text.StringBuilder sb,
		ClassStubInfo cls)
	{
		var stubClassName = cls.Name;

		// Group methods by name for overload handling
		var methodGroups = GroupClassMethodsByName(cls.Members.Where(m => !m.IsProperty && !m.IsIndexer));

		// Count indexers to determine naming strategy
		var indexerCount = SymbolHelpers.CountClassIndexers(cls.Members);

		// Generate interceptor classes for properties/indexers
		foreach (var member in cls.Members)
		{
			if (member.IsProperty || member.IsIndexer)
			{
				GenerateClassMemberInterceptorClass(sb, member, cls.Name, indexerCount);
			}
		}

		// Generate interceptor classes for method groups
		foreach (var group in methodGroups.Values)
		{
			GenerateClassMethodGroupInterceptorClass(sb, group, cls.Name);
		}

		// Generate interceptor classes for events
		foreach (var evt in cls.Events)
		{
			GenerateInlineStubEventHandlerClass(sb, evt, cls.Name);
		}

		// Generate the wrapper stub class (no inheritance from target)
		sb.AppendLine($"\t\t/// <summary>Stub for {cls.FullName} via composition.</summary>");
		sb.AppendLine($"\t\tpublic class {stubClassName}");
		sb.AppendLine("\t\t{");

		// Direct interceptor properties on wrapper (no container)
		foreach (var member in cls.Members)
		{
			if (member.IsProperty || member.IsIndexer)
			{
				// For indexers, compute name based on count (single: Indexer, multiple: IndexerString, IndexerInt)
				var memberName = member.IsIndexer
					? SymbolHelpers.GetIndexerName(indexerCount, member.IndexerTypeSuffix)
					: member.Name;
				var interceptorType = $"{cls.Name}_{memberName}Interceptor";
				sb.AppendLine($"\t\t\t/// <summary>Interceptor for {memberName}.</summary>");
				sb.AppendLine($"\t\t\tpublic {interceptorType} {memberName} {{ get; }} = new();");
			}
		}

		foreach (var group in methodGroups.Values)
		{
			var hasOverloads = group.Members.Count > 1;
			for (int i = 0; i < group.Members.Count; i++)
			{
				var handlerName = hasOverloads ? $"{group.Name}{i + 1}" : group.Name;
				var interceptorType = hasOverloads
					? $"{cls.Name}_{group.Name}{i + 1}Interceptor"
					: $"{cls.Name}_{group.Name}Interceptor";
				sb.AppendLine($"\t\t\t/// <summary>Interceptor for {group.Name}.</summary>");
				sb.AppendLine($"\t\t\tpublic {interceptorType} {handlerName} {{ get; }} = new();");
			}
		}

		foreach (var evt in cls.Events)
		{
			var interceptorType = $"{cls.Name}_{evt.Name}Interceptor";
			sb.AppendLine($"\t\t\t/// <summary>Interceptor for {evt.Name}.</summary>");
			sb.AppendLine($"\t\t\tpublic {interceptorType} {evt.Name} {{ get; }} = new();");
		}

		sb.AppendLine();

		// .Object property - returns the Impl instance as target class type
		sb.AppendLine($"\t\t\t/// <summary>The {cls.FullName} instance. Pass this to code expecting the target class.</summary>");
		sb.AppendLine($"\t\t\tpublic {cls.FullName} Object {{ get; }}");
		sb.AppendLine();

		// Generate constructors that create Impl instance
		foreach (var ctor in cls.Constructors)
		{
			GenerateClassWrapperConstructor(sb, ctor, stubClassName, cls.FullName);
		}

		// ResetInterceptors method
		sb.AppendLine("\t\t\t/// <summary>Resets all interceptor state.</summary>");
		sb.AppendLine("\t\t\tpublic void ResetInterceptors()");
		sb.AppendLine("\t\t\t{");

		foreach (var member in cls.Members)
		{
			if (member.IsProperty || member.IsIndexer)
			{
				// For indexers, compute name based on count (single: Indexer, multiple: IndexerString, IndexerInt)
				var memberName = member.IsIndexer
					? SymbolHelpers.GetIndexerName(indexerCount, member.IndexerTypeSuffix)
					: member.Name;
				sb.AppendLine($"\t\t\t\t{memberName}.Reset();");
			}
		}

		foreach (var group in methodGroups.Values)
		{
			var hasOverloads = group.Members.Count > 1;
			for (int i = 0; i < group.Members.Count; i++)
			{
				var handlerName = hasOverloads ? $"{group.Name}{i + 1}" : group.Name;
				sb.AppendLine($"\t\t\t\t{handlerName}.Reset();");
			}
		}

		foreach (var evt in cls.Events)
		{
			sb.AppendLine($"\t\t\t\t{evt.Name}.Reset();");
		}

		sb.AppendLine("\t\t\t}");
		sb.AppendLine();

		// Generate nested Impl class that inherits from target
		GenerateClassImplClass(sb, cls, methodGroups, stubClassName, indexerCount);

		sb.AppendLine("\t\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates the nested Impl class that inherits from the target class.
	/// </summary>
	private static void GenerateClassImplClass(
		System.Text.StringBuilder sb,
		ClassStubInfo cls,
		Dictionary<string, ClassMethodGroupInfo> methodGroups,
		string stubClassName,
		int indexerCount)
	{
		// Check if class has any required properties - need [SetsRequiredMembers] on constructor
		var requiredMembers = cls.Members.Where(m => m.IsProperty && m.IsRequired).ToList();
		var hasRequiredMembers = requiredMembers.Count > 0;

		// Suppress CS8618 for classes with required members - the [SetsRequiredMembers] attribute
		// handles the required constraint, but nullability analysis still complains
		if (hasRequiredMembers)
		{
			sb.AppendLine("#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor");
		}

		sb.AppendLine($"\t\t\t/// <summary>Internal implementation that inherits from {cls.FullName}.</summary>");
		sb.AppendLine($"\t\t\tprivate sealed class Impl : {cls.FullName}");
		sb.AppendLine("\t\t\t{");

		// Reference to the wrapper
		sb.AppendLine($"\t\t\t\tprivate readonly {stubClassName} _stub;");
		sb.AppendLine();

		// Generate constructors that chain to base
		foreach (var ctor in cls.Constructors)
		{
			GenerateClassImplConstructor(sb, ctor, stubClassName, cls.FullName, hasRequiredMembers, requiredMembers);
		}

		// Generate overrides for properties
		foreach (var member in cls.Members)
		{
			if (member.IsProperty && !member.IsIndexer)
			{
				GenerateClassImplPropertyOverride(sb, member, cls.Name);
			}
			else if (member.IsIndexer)
			{
				GenerateClassImplIndexerOverride(sb, member, cls.Name, indexerCount);
			}
		}

		// Generate overrides for methods
		foreach (var group in methodGroups.Values)
		{
			var hasOverloads = group.Members.Count > 1;
			for (int i = 0; i < group.Members.Count; i++)
			{
				var member = group.Members.GetArray()![i];
				var handlerName = hasOverloads ? $"{group.Name}{i + 1}" : group.Name;
				GenerateClassImplMethodOverride(sb, member, cls.Name, handlerName);
			}
		}

		// Generate overrides for events
		foreach (var evt in cls.Events)
		{
			GenerateClassImplEventOverride(sb, evt, cls.Name);
		}

		sb.AppendLine("\t\t\t}");

		// Restore the warning if we disabled it
		if (hasRequiredMembers)
		{
			sb.AppendLine("#pragma warning restore CS8618");
		}
	}

	/// <summary>
	/// Groups class methods by name for overload handling.
	/// </summary>
	private static Dictionary<string, ClassMethodGroupInfo> GroupClassMethodsByName(IEnumerable<ClassMemberInfo> methods)
	{
		// First, group into lists by method name
		var tempGroups = new Dictionary<string, List<ClassMemberInfo>>();

		foreach (var method in methods)
		{
			if (!tempGroups.TryGetValue(method.Name, out var list))
			{
				list = new List<ClassMemberInfo>();
				tempGroups[method.Name] = list;
			}
			list.Add(method);
		}

		// Convert to ClassMethodGroupInfo
		return tempGroups.ToDictionary(
			kvp => kvp.Key,
			kvp =>
			{
				var first = kvp.Value[0];
				return new ClassMethodGroupInfo(
					kvp.Key,
					first.ReturnType,
					first.ReturnType == "void",
					first.IsNullable,
					kvp.Value);
			});
	}

	/// <summary>
	/// Generates an interceptor class for a property or indexer.
	/// </summary>
	private static void GenerateClassMemberInterceptorClass(
		System.Text.StringBuilder sb,
		ClassMemberInfo member,
		string className,
		int indexerCount)
	{
		// For indexers, compute name based on count (single: Indexer, multiple: IndexerString, IndexerInt)
		var memberName = member.IsIndexer
			? SymbolHelpers.GetIndexerName(indexerCount, member.IndexerTypeSuffix)
			: member.Name;
		var interceptClassName = $"{className}_{memberName}Interceptor";
		var stubClassName = $"Stubs.{className}";

		sb.AppendLine($"\t\t/// <summary>Interceptor for {className}.{memberName}.</summary>");
		sb.AppendLine($"\t\tpublic sealed class {interceptClassName}");
		sb.AppendLine("\t\t{");

		if (member.IsIndexer)
		{
			GenerateClassIndexerMembers(sb, member, stubClassName);
		}
		else
		{
			// Property interceptor
			if (member.HasGetter)
			{
				sb.AppendLine("\t\t\t/// <summary>Number of times the getter was accessed.</summary>");
				sb.AppendLine("\t\t\tpublic int GetCount { get; private set; }");
				sb.AppendLine();
				sb.AppendLine($"\t\t\t/// <summary>Callback for getter. If set, returns its value instead of base.</summary>");
				sb.AppendLine($"\t\t\tpublic global::System.Func<{stubClassName}, {member.ReturnType}>? OnGet {{ get; set; }}");
				sb.AppendLine();
			}

			if (member.HasSetter)
			{
				sb.AppendLine("\t\t\t/// <summary>Number of times the setter was accessed.</summary>");
				sb.AppendLine("\t\t\tpublic int SetCount { get; private set; }");
				sb.AppendLine();
				var nullableType = MakeNullable(member.ReturnType);
				sb.AppendLine($"\t\t\t/// <summary>The last value passed to the setter.</summary>");
				sb.AppendLine($"\t\t\tpublic {nullableType} LastSetValue {{ get; private set; }}");
				sb.AppendLine();
				sb.AppendLine($"\t\t\t/// <summary>Callback for setter. If set, called instead of base.</summary>");
				sb.AppendLine($"\t\t\tpublic global::System.Action<{stubClassName}, {member.ReturnType}>? OnSet {{ get; set; }}");
				sb.AppendLine();
			}

			// RecordGet/RecordSet
			if (member.HasGetter)
			{
				sb.AppendLine("\t\t\t/// <summary>Records a getter access.</summary>");
				sb.AppendLine("\t\t\tpublic void RecordGet() => GetCount++;");
				sb.AppendLine();
			}
			if (member.HasSetter)
			{
				var nullableType = MakeNullable(member.ReturnType);
				sb.AppendLine("\t\t\t/// <summary>Records a setter access.</summary>");
				sb.AppendLine($"\t\t\tpublic void RecordSet({nullableType} value) {{ SetCount++; LastSetValue = value; }}");
				sb.AppendLine();
			}

			// Reset method
			sb.AppendLine("\t\t\t/// <summary>Resets all tracking state.</summary>");
			sb.Append("\t\t\tpublic void Reset() { ");
			if (member.HasGetter) sb.Append("GetCount = 0; OnGet = null; ");
			if (member.HasSetter) sb.Append("SetCount = 0; LastSetValue = default; OnSet = null; ");
			sb.AppendLine("}");
		}

		sb.AppendLine("\t\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates indexer interceptor members.
	/// </summary>
	private static void GenerateClassIndexerMembers(
		System.Text.StringBuilder sb,
		ClassMemberInfo member,
		string stubClassName)
	{
		var keyType = member.IndexerParameters.Count == 1
			? member.IndexerParameters.GetArray()![0].Type
			: $"({string.Join(", ", member.IndexerParameters.Select(p => $"{p.Type} {p.Name}"))})";

		if (member.HasGetter)
		{
			sb.AppendLine("\t\t\t/// <summary>Number of times the getter was accessed.</summary>");
			sb.AppendLine("\t\t\tpublic int GetCount { get; private set; }");
			sb.AppendLine();

			var nullableKeyType = MakeNullable(keyType);
			sb.AppendLine($"\t\t\t/// <summary>The last key used to access the getter.</summary>");
			sb.AppendLine($"\t\t\tpublic {nullableKeyType} LastGetKey {{ get; private set; }}");
			sb.AppendLine();

			var paramList = string.Join(", ", member.IndexerParameters.Select(p => p.Type));
			sb.AppendLine($"\t\t\t/// <summary>Callback for getter.</summary>");
			sb.AppendLine($"\t\t\tpublic global::System.Func<{stubClassName}, {paramList}, {member.ReturnType}>? OnGet {{ get; set; }}");
			sb.AppendLine();
		}

		if (member.HasSetter)
		{
			sb.AppendLine("\t\t\t/// <summary>Number of times the setter was accessed.</summary>");
			sb.AppendLine("\t\t\tpublic int SetCount { get; private set; }");
			sb.AppendLine();

			var entryType = $"({keyType} Key, {member.ReturnType} Value)";
			sb.AppendLine($"\t\t\t/// <summary>The last key-value pair passed to the setter.</summary>");
			sb.AppendLine($"\t\t\tpublic {entryType}? LastSetEntry {{ get; private set; }}");
			sb.AppendLine();

			var paramList = string.Join(", ", member.IndexerParameters.Select(p => p.Type));
			sb.AppendLine($"\t\t\t/// <summary>Callback for setter.</summary>");
			sb.AppendLine($"\t\t\tpublic global::System.Action<{stubClassName}, {paramList}, {member.ReturnType}>? OnSet {{ get; set; }}");
			sb.AppendLine();
		}

		// RecordGet/RecordSet
		if (member.HasGetter)
		{
			var paramSig = string.Join(", ", member.IndexerParameters.Select(p => $"{p.Type} {p.Name}"));
			var keyExpr = member.IndexerParameters.Count == 1
				? member.IndexerParameters.GetArray()![0].Name
				: $"({string.Join(", ", member.IndexerParameters.Select(p => p.Name))})";
			sb.AppendLine($"\t\t\t/// <summary>Records a getter access.</summary>");
			sb.AppendLine($"\t\t\tpublic void RecordGet({paramSig}) {{ GetCount++; LastGetKey = {keyExpr}; }}");
			sb.AppendLine();
		}
		if (member.HasSetter)
		{
			var paramSig = string.Join(", ", member.IndexerParameters.Select(p => $"{p.Type} {p.Name}"));
			var keyExpr = member.IndexerParameters.Count == 1
				? member.IndexerParameters.GetArray()![0].Name
				: $"({string.Join(", ", member.IndexerParameters.Select(p => p.Name))})";
			sb.AppendLine($"\t\t\t/// <summary>Records a setter access.</summary>");
			sb.AppendLine($"\t\t\tpublic void RecordSet({paramSig}, {member.ReturnType} value) {{ SetCount++; LastSetEntry = ({keyExpr}, value); }}");
			sb.AppendLine();
		}

		// Add Backing property inside the interceptor
		var singleKeyType = member.IndexerParameters.Count == 1
			? member.IndexerParameters.GetArray()![0].Type
			: keyType;
		sb.AppendLine($"\t\t\t/// <summary>Backing storage for this indexer.</summary>");
		sb.AppendLine($"\t\t\tpublic global::System.Collections.Generic.Dictionary<{singleKeyType}, {member.ReturnType}> Backing {{ get; }} = new();");
		sb.AppendLine();

		// Reset method
		sb.AppendLine("\t\t\t/// <summary>Resets all tracking state.</summary>");
		sb.Append("\t\t\tpublic void Reset() { ");
		if (member.HasGetter) sb.Append("GetCount = 0; LastGetKey = default; OnGet = null; ");
		if (member.HasSetter) sb.Append("SetCount = 0; LastSetEntry = default; OnSet = null; ");
		// Note: Backing dictionary is intentionally NOT cleared - pre-populated data is preserved
		sb.AppendLine("}");
	}

	/// <summary>
	/// Generates an interceptor class for a method group.
	/// </summary>
	private static void GenerateClassMethodGroupInterceptorClass(
		System.Text.StringBuilder sb,
		ClassMethodGroupInfo group,
		string className)
	{
		var hasOverloads = group.Members.Count > 1;

		for (int i = 0; i < group.Members.Count; i++)
		{
			var member = group.Members.GetArray()![i];
			var interceptClassName = hasOverloads
				? $"{className}_{group.Name}{i + 1}Interceptor"
				: $"{className}_{group.Name}Interceptor";
			var stubClassName = $"Stubs.{className}";

			var inputParams = GetInputParameters(member.Parameters).ToArray();

			sb.AppendLine($"\t\t/// <summary>Interceptor for {className}.{group.Name}.</summary>");
			sb.AppendLine($"\t\tpublic sealed class {interceptClassName}");
			sb.AppendLine("\t\t{");

			// Delegate type for OnCall
			var delegateParamTypes = string.Join(", ", inputParams.Select(p => p.Type));
			var delegateParams = string.IsNullOrEmpty(delegateParamTypes)
				? stubClassName
				: $"{stubClassName}, {delegateParamTypes}";
			var isVoid = member.ReturnType == "void";
			var delegateType = isVoid
				? $"global::System.Action<{delegateParams}>"
				: $"global::System.Func<{delegateParams}, {member.ReturnType}>";

			sb.AppendLine("\t\t\t/// <summary>Number of times this method was called.</summary>");
			sb.AppendLine("\t\t\tpublic int CallCount { get; private set; }");
			sb.AppendLine();
			sb.AppendLine("\t\t\t/// <summary>Whether this method was called at least once.</summary>");
			sb.AppendLine("\t\t\tpublic bool WasCalled => CallCount > 0;");
			sb.AppendLine();

			// LastCallArg / LastCallArgs
			if (inputParams.Length == 1)
			{
				var param = inputParams[0];
				var nullableArgType = MakeNullable(param.Type);
				sb.AppendLine($"\t\t\t/// <summary>The argument from the last call.</summary>");
				sb.AppendLine($"\t\t\tpublic {nullableArgType} LastCallArg {{ get; private set; }}");
				sb.AppendLine();
			}
			else if (inputParams.Length > 1)
			{
				var tupleType = $"({string.Join(", ", inputParams.Select(p => $"{MakeNullable(p.Type)} {p.Name}"))})?";
				sb.AppendLine($"\t\t\t/// <summary>The arguments from the last call.</summary>");
				sb.AppendLine($"\t\t\tpublic {tupleType} LastCallArgs {{ get; private set; }}");
				sb.AppendLine();
			}

			// OnCall callback
			sb.AppendLine($"\t\t\t/// <summary>Callback invoked when method is called. If set, called instead of base.</summary>");
			sb.AppendLine($"\t\t\tpublic {delegateType}? OnCall {{ get; set; }}");
			sb.AppendLine();

			// RecordCall method
			var recordParams = string.Join(", ", inputParams.Select(p => $"{p.Type} {p.Name}"));
			sb.Append($"\t\t\tpublic void RecordCall({recordParams}) {{ CallCount++; ");
			if (inputParams.Length == 1)
			{
				sb.Append($"LastCallArg = {inputParams[0].Name}; ");
			}
			else if (inputParams.Length > 1)
			{
				sb.Append($"LastCallArgs = ({string.Join(", ", inputParams.Select(p => p.Name))}); ");
			}
			sb.AppendLine("}");
			sb.AppendLine();

			// Reset method
			sb.Append("\t\t\tpublic void Reset() { CallCount = 0; ");
			if (inputParams.Length == 1)
			{
				sb.Append("LastCallArg = default; ");
			}
			else if (inputParams.Length > 1)
			{
				sb.Append("LastCallArgs = default; ");
			}
			sb.AppendLine("OnCall = null; }");

			sb.AppendLine("\t\t}");
			sb.AppendLine();
		}
	}

	/// <summary>
	/// Generates a wrapper constructor that creates the Impl instance.
	/// </summary>
	private static void GenerateClassWrapperConstructor(
		System.Text.StringBuilder sb,
		ClassConstructorInfo ctor,
		string stubClassName,
		string baseClassName)
	{
		var paramList = string.Join(", ", ctor.Parameters.Select(p => $"{p.Type} {p.Name}"));
		var argList = string.Join(", ", ctor.Parameters.Select(p => p.Name));

		sb.AppendLine($"\t\t\tpublic {stubClassName}({paramList})");
		sb.AppendLine("\t\t\t{");
		if (argList.Length > 0)
		{
			sb.AppendLine($"\t\t\t\tObject = new Impl(this, {argList});");
		}
		else
		{
			sb.AppendLine($"\t\t\t\tObject = new Impl(this);");
		}
		sb.AppendLine("\t\t\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates an Impl constructor that stores the wrapper and chains to base.
	/// </summary>
	private static void GenerateClassImplConstructor(
		System.Text.StringBuilder sb,
		ClassConstructorInfo ctor,
		string stubClassName,
		string baseClassName,
		bool hasRequiredMembers,
		IEnumerable<ClassMemberInfo>? requiredMembers = null)
	{
		var paramList = ctor.Parameters.Count > 0
			? $"{stubClassName} stub, " + string.Join(", ", ctor.Parameters.Select(p => $"{p.Type} {p.Name}"))
			: $"{stubClassName} stub";
		var argList = string.Join(", ", ctor.Parameters.Select(p => p.Name));

		// Add [SetsRequiredMembers] if the base class has required properties
		// This allows creating the Impl without providing required values in object initializer
		if (hasRequiredMembers)
		{
			sb.AppendLine("\t\t\t\t[global::System.Diagnostics.CodeAnalysis.SetsRequiredMembers]");
		}
		sb.AppendLine($"\t\t\t\tpublic Impl({paramList}) : base({argList})");
		sb.AppendLine("\t\t\t\t{");

		// Initialize required members FIRST while _stub is still null
		// This prevents RecordSet from being called during initialization
		// The [SetsRequiredMembers] attribute tells the compiler we handle them
		if (requiredMembers != null)
		{
			foreach (var member in requiredMembers)
			{
				if (member.IsRequired && member.IsProperty && !member.IsIndexer)
				{
					sb.AppendLine($"\t\t\t\t\t{member.Name} = default!;");
				}
			}
		}

		// Set _stub AFTER required member initialization so setter recording is skipped
		sb.AppendLine("\t\t\t\t\t_stub = stub;");
		sb.AppendLine("\t\t\t\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates a property override for the Impl class.
	/// Note: _stub may be null during base constructor calls, so we add null checks.
	/// </summary>
	private static void GenerateClassImplPropertyOverride(
		System.Text.StringBuilder sb,
		ClassMemberInfo member,
		string className)
	{
		var requiredKeyword = member.IsRequired ? "required " : "";
		sb.AppendLine($"\t\t\t\t/// <inheritdoc />");
		sb.AppendLine($"\t\t\t\t{requiredKeyword}{member.AccessModifier} override {member.ReturnType} {member.Name}");
		sb.AppendLine("\t\t\t\t{");

		if (member.HasGetter)
		{
			sb.AppendLine("\t\t\t\t\tget");
			sb.AppendLine("\t\t\t\t\t{");
			// Handle calls from base constructor when _stub is null
			sb.AppendLine($"\t\t\t\t\t\t_stub?.{member.Name}.RecordGet();");
			sb.AppendLine($"\t\t\t\t\t\tif (_stub?.{member.Name}.OnGet is {{ }} onGet) return onGet(_stub);");
			if (member.IsAbstract)
			{
				sb.AppendLine($"\t\t\t\t\t\treturn default!;");
			}
			else
			{
				sb.AppendLine($"\t\t\t\t\t\treturn base.{member.Name};");
			}
			sb.AppendLine("\t\t\t\t\t}");
		}

		if (member.HasSetter)
		{
			var setterKeyword = member.IsInitOnly ? "init" : "set";
			sb.AppendLine($"\t\t\t\t\t{setterKeyword}");
			sb.AppendLine("\t\t\t\t\t{");
			// Handle calls from base constructor when _stub is null
			sb.AppendLine($"\t\t\t\t\t\t_stub?.{member.Name}.RecordSet(value);");
			sb.AppendLine($"\t\t\t\t\t\tif (_stub?.{member.Name}.OnSet is {{ }} onSet) onSet(_stub, value);");
			if (member.IsAbstract)
			{
				// Abstract - no base to call
			}
			else
			{
				sb.AppendLine($"\t\t\t\t\t\telse base.{member.Name} = value;");
			}
			sb.AppendLine("\t\t\t\t\t}");
		}

		sb.AppendLine("\t\t\t\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates an indexer override for the Impl class.
	/// Note: _stub may be null during base constructor calls, so we add null checks.
	/// </summary>
	private static void GenerateClassImplIndexerOverride(
		System.Text.StringBuilder sb,
		ClassMemberInfo member,
		string className,
		int indexerCount)
	{
		var paramList = string.Join(", ", member.IndexerParameters.Select(p => $"{p.Type} {p.Name}"));
		var argList = string.Join(", ", member.IndexerParameters.Select(p => p.Name));
		var keyArg = member.IndexerParameters.Count == 1
			? member.IndexerParameters.GetArray()![0].Name
			: $"({argList})";

		// Compute indexer name based on count (single: Indexer, multiple: IndexerString, IndexerInt)
		var indexerName = SymbolHelpers.GetIndexerName(indexerCount, member.IndexerTypeSuffix);

		sb.AppendLine($"\t\t\t\t/// <inheritdoc />");
		sb.AppendLine($"\t\t\t\t{member.AccessModifier} override {member.ReturnType} this[{paramList}]");
		sb.AppendLine("\t\t\t\t{");

		if (member.HasGetter)
		{
			sb.AppendLine("\t\t\t\t\tget");
			sb.AppendLine("\t\t\t\t\t{");
			// Handle calls from base constructor when _stub is null
			sb.AppendLine($"\t\t\t\t\t\t_stub?.{indexerName}.RecordGet({argList});");
			sb.AppendLine($"\t\t\t\t\t\tif (_stub?.{indexerName}.OnGet is {{ }} onGet) return onGet(_stub, {argList});");
			if (member.IsAbstract)
			{
				var defaultExpr = member.IsNullable ? "default" : GetDefaultForType(member.ReturnType, member.DefaultStrategy, member.ConcreteTypeForNew);
				sb.AppendLine($"\t\t\t\t\t\tif (_stub?.{indexerName}.Backing.TryGetValue({keyArg}, out var v) == true) return v;");
				sb.AppendLine($"\t\t\t\t\t\treturn {defaultExpr};");
			}
			else
			{
				sb.AppendLine($"\t\t\t\t\t\treturn base[{argList}];");
			}
			sb.AppendLine("\t\t\t\t\t}");
		}

		if (member.HasSetter)
		{
			sb.AppendLine("\t\t\t\t\tset");
			sb.AppendLine("\t\t\t\t\t{");
			// Handle calls from base constructor when _stub is null
			sb.AppendLine($"\t\t\t\t\t\t_stub?.{indexerName}.RecordSet({argList}, value);");
			sb.AppendLine($"\t\t\t\t\t\tif (_stub?.{indexerName}.OnSet is {{ }} onSet) onSet(_stub, {argList}, value);");
			if (member.IsAbstract)
			{
				sb.AppendLine($"\t\t\t\t\t\telse if (_stub is not null) _stub.{indexerName}.Backing[{keyArg}] = value;");
			}
			else
			{
				sb.AppendLine($"\t\t\t\t\t\telse base[{argList}] = value;");
			}
			sb.AppendLine("\t\t\t\t\t}");
		}

		sb.AppendLine("\t\t\t\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates a method override for the Impl class.
	/// Note: _stub may be null during base constructor calls, so we add null checks.
	/// </summary>
	private static void GenerateClassImplMethodOverride(
		System.Text.StringBuilder sb,
		ClassMemberInfo member,
		string className,
		string handlerName)
	{
		var paramList = string.Join(", ", member.Parameters.Select(p => FormatParameter(p)));
		var argList = string.Join(", ", member.Parameters.Select(p => FormatArgument(p)));
		var inputParams = GetInputParameters(member.Parameters).ToArray();
		var inputArgList = string.Join(", ", inputParams.Select(p => p.Name));

		var isVoid = member.ReturnType == "void";
		var isTask = member.ReturnType == "global::System.Threading.Tasks.Task";
		var isValueTask = member.ReturnType == "global::System.Threading.Tasks.ValueTask";

		sb.AppendLine($"\t\t\t\t/// <inheritdoc />");
		sb.AppendLine($"\t\t\t\t{member.AccessModifier} override {member.ReturnType} {member.Name}({paramList})");
		sb.AppendLine("\t\t\t\t{");

		// Record the call (null check for calls during base constructor)
		if (inputParams.Length > 0)
		{
			sb.AppendLine($"\t\t\t\t\t_stub?.{handlerName}.RecordCall({inputArgList});");
		}
		else
		{
			sb.AppendLine($"\t\t\t\t\t_stub?.{handlerName}.RecordCall();");
		}

		// Check for OnCall callback (null check for calls during base constructor)
		var onCallArgs = inputParams.Length > 0 ? $"_stub, {inputArgList}" : "_stub";
		if (isVoid || isTask || isValueTask)
		{
			sb.AppendLine($"\t\t\t\t\tif (_stub?.{handlerName}.OnCall is {{ }} onCall) {{ onCall({onCallArgs}); return; }}");
		}
		else
		{
			sb.AppendLine($"\t\t\t\t\tif (_stub?.{handlerName}.OnCall is {{ }} onCall) return onCall({onCallArgs});");
		}

		// Default behavior - delegate to base or return default for abstract
		if (member.IsAbstract)
		{
			// Abstract - return default
			if (isVoid)
			{
				// void - nothing to return
			}
			else if (isTask)
			{
				sb.AppendLine($"\t\t\t\t\treturn global::System.Threading.Tasks.Task.CompletedTask;");
			}
			else if (isValueTask)
			{
				sb.AppendLine($"\t\t\t\t\treturn default;");
			}
			else
			{
				sb.AppendLine($"\t\t\t\t\treturn default!;");
			}
		}
		else
		{
			// Virtual - delegate to base
			if (isVoid)
			{
				sb.AppendLine($"\t\t\t\t\tbase.{member.Name}({argList});");
			}
			else
			{
				sb.AppendLine($"\t\t\t\t\treturn base.{member.Name}({argList});");
			}
		}

		sb.AppendLine("\t\t\t\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates an event override for the Impl class.
	/// Note: _stub may be null during base constructor calls, so we add null checks.
	/// </summary>
	private static void GenerateClassImplEventOverride(
		System.Text.StringBuilder sb,
		EventMemberInfo evt,
		string className)
	{
		sb.AppendLine($"\t\t\t\t/// <inheritdoc />");
		sb.AppendLine($"\t\t\t\tpublic override event {evt.FullDelegateTypeName}? {evt.Name}");
		sb.AppendLine("\t\t\t\t{");
		// Null check for calls during base constructor
		sb.AppendLine($"\t\t\t\t\tadd => _stub?.{evt.Name}.RecordAdd(value);");
		sb.AppendLine($"\t\t\t\t\tremove => _stub?.{evt.Name}.RecordRemove(value);");
		sb.AppendLine("\t\t\t\t}");
		sb.AppendLine();
	}

	#endregion
}
