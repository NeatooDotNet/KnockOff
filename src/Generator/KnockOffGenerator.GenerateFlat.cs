// <auto-generated/> - Partial class extracted from KnockOffGenerator.cs
#nullable enable
using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;

namespace KnockOff;

public partial class KnockOffGenerator
{
	#region Flat API Generation (v10.9+)

	/// <summary>
	/// Builds a map from member keys to collision-safe interceptor names.
	/// For example, if two interfaces both have "Value" property, they map to "Value" and "Value2".
	/// Also avoids conflicts with user-defined methods.
	/// </summary>
	private static Dictionary<string, string> BuildFlatNameMap(
		EquatableArray<InterfaceMemberInfo> flatMembers,
		EquatableArray<EventMemberInfo> flatEvents,
		EquatableArray<UserMethodInfo> userMethods)
	{
		var nameMap = new Dictionary<string, string>();
		var usedNames = new HashSet<string>();

		// Reserve names used by user methods to avoid conflicts
		foreach (var userMethod in userMethods)
		{
			usedNames.Add(userMethod.Name);
		}

		// Process properties and indexers
		foreach (var member in flatMembers)
		{
			if (member.IsProperty || member.IsIndexer)
			{
				var key = GetMemberKey(member);
				var baseName = member.Name;
				var finalName = GetUniqueInterceptorName(baseName, usedNames);
				nameMap[key] = finalName;
				usedNames.Add(finalName);
			}
		}

		// Process methods - group by name first
		var methodGroups = flatMembers
			.Where(m => !m.IsProperty && !m.IsIndexer)
			.GroupBy(m => m.Name)
			.ToDictionary(g => g.Key, g => g.ToList());

		foreach (var group in methodGroups)
		{
			var methodName = group.Key;
			var overloads = group.Value;

			// Check for mixed groups (both generic and non-generic overloads)
			var genericOverloads = overloads.Where(m => m.IsGenericMethod).ToList();
			var nonGenericOverloads = overloads.Where(m => !m.IsGenericMethod).ToList();
			var isMixed = genericOverloads.Count > 0 && nonGenericOverloads.Count > 0;

			if (isMixed)
			{
				// Mixed group: handle non-generic and generic overloads separately

				// Non-generic overloads get numbered suffixes if multiple, otherwise base name
				if (nonGenericOverloads.Count == 1)
				{
					var key = GetMemberKey(nonGenericOverloads[0]);
					var finalName = GetUniqueInterceptorName(methodName, usedNames);
					nameMap[key] = finalName;
					usedNames.Add(finalName);
				}
				else
				{
					for (int i = 0; i < nonGenericOverloads.Count; i++)
					{
						var key = GetMemberKey(nonGenericOverloads[i]);
						var suffix = (i + 1).ToString();
						var baseName = $"{methodName}{suffix}";
						var finalName = GetUniqueInterceptorName(baseName, usedNames);
						nameMap[key] = finalName;
						usedNames.Add(finalName);
					}
				}

				// Generic overloads use a handler with Generic suffix
				var genericName = methodName + GenericSuffix;
				var genericKey = $"method:{methodName}()_generic";
				var genericFinalName = GetUniqueInterceptorName(genericName, usedNames);
				nameMap[genericKey] = genericFinalName;
				usedNames.Add(genericFinalName);

				// Also map each generic overload to the generic handler
				foreach (var overload in genericOverloads)
				{
					var key = GetMemberKey(overload);
					nameMap[key] = genericFinalName;
				}
			}
			else if (genericOverloads.Count > 0)
			{
				// All generic - use a single base handler with Of<T>() pattern
				var genericKey = $"method:{methodName}()_generic";
				var finalName = GetUniqueInterceptorName(methodName, usedNames);
				nameMap[genericKey] = finalName;
				usedNames.Add(finalName);

				// Also add entries for each overload (for implementation lookup)
				foreach (var overload in overloads)
				{
					var key = GetMemberKey(overload);
					nameMap[key] = finalName; // All overloads use same base interceptor name
				}
			}
			else if (overloads.Count == 1)
			{
				// Single method - no overload suffix
				var key = GetMemberKey(overloads[0]);
				var finalName = GetUniqueInterceptorName(methodName, usedNames);
				nameMap[key] = finalName;
				usedNames.Add(finalName);
			}
			else
			{
				// Multiple overloads - use numbered suffixes
				for (int i = 0; i < overloads.Count; i++)
				{
					var key = GetMemberKey(overloads[i]);
					var suffix = (i + 1).ToString();
					var baseName = $"{methodName}{suffix}";
					var finalName = GetUniqueInterceptorName(baseName, usedNames);
					nameMap[key] = finalName;
					usedNames.Add(finalName);
				}
			}
		}

		// Process events
		foreach (var evt in flatEvents)
		{
			var key = $"event:{evt.Name}";
			var finalName = GetUniqueInterceptorName(evt.Name, usedNames);
			nameMap[key] = finalName;
			usedNames.Add(finalName);
		}

		return nameMap;
	}

	/// <summary>
	/// Gets a unique name that doesn't conflict with already used names.
	/// </summary>
	private static string GetUniqueInterceptorName(string baseName, HashSet<string> usedNames)
	{
		if (!usedNames.Contains(baseName))
			return baseName;

		int suffix = 2;
		while (usedNames.Contains($"{baseName}{suffix}"))
			suffix++;

		return $"{baseName}{suffix}";
	}

	/// <summary>
	/// Generate a flat interceptor class for property/indexer with custom name
	/// </summary>
	private static void GenerateFlatMemberInterceptorClass(
		System.Text.StringBuilder sb,
		InterfaceMemberInfo member,
		string knockOffClassName,
		string interceptorName)
	{
		var interceptClassName = $"{interceptorName}Interceptor";

		sb.AppendLine($"\t/// <summary>Tracks and configures behavior for {member.Name}.</summary>");
		sb.AppendLine($"\tpublic sealed class {interceptClassName}");
		sb.AppendLine("\t{");

		if (member.IsIndexer)
		{
			GenerateFlatIndexerInterceptorContent(sb, member, knockOffClassName);
		}
		else if (member.IsProperty)
		{
			if (member.HasGetter)
			{
				sb.AppendLine("\t\t/// <summary>Number of times the getter was accessed.</summary>");
				sb.AppendLine("\t\tpublic int GetCount { get; private set; }");
				sb.AppendLine();

				sb.AppendLine("\t\t/// <summary>Callback invoked when the getter is accessed. If set, its return value is used.</summary>");
				sb.AppendLine($"\t\tpublic global::System.Func<{knockOffClassName}, {member.ReturnType}>? OnGet {{ get; set; }}");
				sb.AppendLine();
			}

			if (member.HasSetter)
			{
				sb.AppendLine("\t\t/// <summary>Number of times the setter was accessed.</summary>");
				sb.AppendLine("\t\tpublic int SetCount { get; private set; }");
				sb.AppendLine();

				var nullableType = MakeNullable(member.ReturnType);
				sb.AppendLine("\t\t/// <summary>The value from the most recent setter call.</summary>");
				sb.AppendLine($"\t\tpublic {nullableType} LastSetValue {{ get; private set; }}");
				sb.AppendLine();

				sb.AppendLine("\t\t/// <summary>Callback invoked when the setter is accessed.</summary>");
				sb.AppendLine($"\t\tpublic global::System.Action<{knockOffClassName}, {member.ReturnType}>? OnSet {{ get; set; }}");
				sb.AppendLine();
			}

			// Value property for backing storage (matches inline stub pattern)
			sb.AppendLine("\t\t/// <summary>Value returned by getter when OnGet is not set.</summary>");
			sb.AppendLine($"\t\tpublic {member.ReturnType} Value {{ get; set; }}{GetDefaultValueForProperty(member)}");
			sb.AppendLine();

			if (member.HasGetter)
			{
				sb.AppendLine("\t\t/// <summary>Records a getter access.</summary>");
				sb.AppendLine("\t\tpublic void RecordGet() => GetCount++;");
				sb.AppendLine();
			}

			if (member.HasSetter)
			{
				var nullableType = MakeNullable(member.ReturnType);
				sb.AppendLine("\t\t/// <summary>Records a setter access.</summary>");
				sb.AppendLine($"\t\tpublic void RecordSet({nullableType} value) {{ SetCount++; LastSetValue = value; }}");
				sb.AppendLine();
			}

			sb.AppendLine("\t\t/// <summary>Resets all tracking state.</summary>");
			sb.Append("\t\tpublic void Reset() { ");
			if (member.HasGetter) sb.Append("GetCount = 0; OnGet = null; ");
			if (member.HasSetter) sb.Append("SetCount = 0; LastSetValue = default; OnSet = null; ");
			sb.Append("Value = default!; ");
			sb.AppendLine("}");
		}

		sb.AppendLine("\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generate flat indexer interceptor content
	/// </summary>
	private static void GenerateFlatIndexerInterceptorContent(
		System.Text.StringBuilder sb,
		InterfaceMemberInfo member,
		string knockOffClassName)
	{
		var keyType = member.IndexerParameters.Count > 0
			? member.IndexerParameters.GetArray()![0].Type
			: "object";
		var keyParamName = member.IndexerParameters.Count > 0
			? member.IndexerParameters.GetArray()![0].Name
			: "key";

		if (member.HasGetter)
		{
			var nullableKeyType = MakeNullable(keyType);

			sb.AppendLine("\t\t/// <summary>Number of times the getter was accessed.</summary>");
			sb.AppendLine("\t\tpublic int GetCount { get; private set; }");
			sb.AppendLine();

			sb.AppendLine("\t\t/// <summary>The key from the most recent getter access.</summary>");
			sb.AppendLine($"\t\tpublic {nullableKeyType} LastGetKey {{ get; private set; }}");
			sb.AppendLine();

			sb.AppendLine("\t\t/// <summary>Callback invoked when the getter is accessed.</summary>");
			sb.AppendLine($"\t\tpublic global::System.Func<{knockOffClassName}, {keyType}, {member.ReturnType}>? OnGet {{ get; set; }}");
			sb.AppendLine();
		}

		if (member.HasSetter)
		{
			var nullableKeyType = MakeNullable(keyType);
			var nullableValueType = MakeNullable(member.ReturnType);

			sb.AppendLine("\t\t/// <summary>Number of times the setter was accessed.</summary>");
			sb.AppendLine("\t\tpublic int SetCount { get; private set; }");
			sb.AppendLine();

			sb.AppendLine("\t\t/// <summary>The key and value from the most recent setter call.</summary>");
			sb.AppendLine($"\t\tpublic ({nullableKeyType} Key, {nullableValueType} Value)? LastSetEntry {{ get; private set; }}");
			sb.AppendLine();

			sb.AppendLine("\t\t/// <summary>Callback invoked when the setter is accessed.</summary>");
			sb.AppendLine($"\t\tpublic global::System.Action<{knockOffClassName}, {keyType}, {member.ReturnType}>? OnSet {{ get; set; }}");
			sb.AppendLine();
		}

		if (member.HasGetter)
		{
			var nullableKeyType = MakeNullable(keyType);
			sb.AppendLine("\t\t/// <summary>Records a getter access.</summary>");
			sb.AppendLine($"\t\tpublic void RecordGet({nullableKeyType} {keyParamName}) {{ GetCount++; LastGetKey = {keyParamName}; }}");
			sb.AppendLine();
		}

		if (member.HasSetter)
		{
			var nullableKeyType = MakeNullable(keyType);
			var nullableValueType = MakeNullable(member.ReturnType);
			sb.AppendLine("\t\t/// <summary>Records a setter access.</summary>");
			sb.AppendLine($"\t\tpublic void RecordSet({nullableKeyType} {keyParamName}, {nullableValueType} value) {{ SetCount++; LastSetEntry = ({keyParamName}, value); }}");
			sb.AppendLine();
		}

		sb.AppendLine("\t\t/// <summary>Resets all tracking state.</summary>");
		sb.Append("\t\tpublic void Reset() { ");
		if (member.HasGetter) sb.Append("GetCount = 0; LastGetKey = default; OnGet = null; ");
		if (member.HasSetter) sb.Append("SetCount = 0; LastSetEntry = null; OnSet = null; ");
		sb.AppendLine("}");
	}

	/// <summary>
	/// Generate flat method group interceptor class (no interface prefix)
	/// </summary>
	private static void GenerateFlatMethodGroupInterceptorClass(
		System.Text.StringBuilder sb,
		MethodGroupInfo group,
		string knockOffClassName)
	{
		var hasOverloads = group.Overloads.Count > 1;

		if (hasOverloads)
		{
			// Generate separate interceptor for each overload
			for (int i = 0; i < group.Overloads.Count; i++)
			{
				var overloadNumber = i + 1;
				var overload = group.Overloads.GetArray()![i];
				GenerateFlatSingleMethodInterceptorClass(sb, group.Name, overload, group, knockOffClassName, overloadNumber);
			}
		}
		else
		{
			// Single method - no suffix
			var overload = group.Overloads.GetArray()![0];
			GenerateFlatSingleMethodInterceptorClass(sb, group.Name, overload, group, knockOffClassName, null);
		}
	}

	/// <summary>
	/// Generate a single method interceptor class
	/// </summary>
	private static void GenerateFlatSingleMethodInterceptorClass(
		System.Text.StringBuilder sb,
		string methodName,
		MethodOverloadInfo overload,
		MethodGroupInfo group,
		string knockOffClassName,
		int? overloadNumber)
	{
		var suffix = overloadNumber.HasValue ? overloadNumber.Value.ToString() : "";
		var interceptClassName = $"{methodName}{suffix}Interceptor";

		var isGeneric = overload.IsGenericMethod;
		var typeParams = overload.TypeParameters;

		sb.AppendLine($"\t/// <summary>Tracks and configures behavior for {methodName}.</summary>");

		if (isGeneric)
		{
			var typeParamList = string.Join(", ", typeParams.Select(tp => tp.Name));
			sb.AppendLine($"\tpublic sealed class {interceptClassName}<{typeParamList}> : IGenericMethodCallTracker, IResettable");
		}
		else
		{
			sb.AppendLine($"\tpublic sealed class {interceptClassName}");
		}

		sb.AppendLine("\t{");

		// CallCount
		sb.AppendLine("\t\t/// <summary>Number of times this method was called.</summary>");
		sb.AppendLine("\t\tpublic int CallCount { get; private set; }");
		sb.AppendLine();

		// WasCalled
		sb.AppendLine("\t\t/// <summary>Whether this method was called at least once.</summary>");
		sb.AppendLine("\t\tpublic bool WasCalled => CallCount > 0;");
		sb.AppendLine();

		// LastCallArg/LastCallArgs
		var paramArray = overload.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();
		if (paramArray.Length == 1)
		{
			var param = paramArray[0];
			var nullableType = MakeNullable(param.Type);
			sb.AppendLine($"\t\t/// <summary>The argument from the most recent call.</summary>");
			sb.AppendLine($"\t\tpublic {nullableType} LastCallArg {{ get; private set; }}");
			sb.AppendLine();
		}
		else if (paramArray.Length > 1)
		{
			var tupleTypes = string.Join(", ", paramArray.Select(p => $"{MakeNullable(p.Type)} {EscapeIdentifier(p.Name)}"));
			sb.AppendLine($"\t\t/// <summary>The arguments from the most recent call.</summary>");
			sb.AppendLine($"\t\tpublic ({tupleTypes})? LastCallArgs {{ get; private set; }}");
			sb.AppendLine();
		}

		// OnCall delegate
		GenerateFlatOnCallDelegate(sb, knockOffClassName, overload, group);

		// RecordCall method
		GenerateFlatRecordCallMethod(sb, overload);

		// Reset method
		GenerateFlatResetMethod(sb, overload);

		sb.AppendLine("\t}");
		sb.AppendLine();
	}

	private static void GenerateFlatOnCallDelegate(
		System.Text.StringBuilder sb,
		string knockOffClassName,
		MethodOverloadInfo overload,
		MethodGroupInfo group)
	{
		var paramArray = overload.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();
		var paramTypes = string.Join(", ", paramArray.Select(p => p.Type));
		var fullParamTypes = paramArray.Length > 0 ? $"{knockOffClassName}, {paramTypes}" : knockOffClassName;

		sb.AppendLine("\t\t/// <summary>Callback invoked when this method is called.</summary>");
		if (group.IsVoid)
		{
			sb.AppendLine($"\t\tpublic global::System.Action<{fullParamTypes}>? OnCall {{ get; set; }}");
		}
		else
		{
			sb.AppendLine($"\t\tpublic global::System.Func<{fullParamTypes}, {group.ReturnType}>? OnCall {{ get; set; }}");
		}
		sb.AppendLine();
	}

	private static void GenerateFlatRecordCallMethod(System.Text.StringBuilder sb, MethodOverloadInfo overload)
	{
		var paramArray = overload.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();

		sb.AppendLine("\t\t/// <summary>Records a method call.</summary>");
		if (paramArray.Length == 0)
		{
			sb.AppendLine("\t\tpublic void RecordCall() => CallCount++;");
		}
		else if (paramArray.Length == 1)
		{
			var param = paramArray[0];
			var nullableType = MakeNullable(param.Type);
			sb.AppendLine($"\t\tpublic void RecordCall({nullableType} {EscapeIdentifier(param.Name)}) {{ CallCount++; LastCallArg = {EscapeIdentifier(param.Name)}; }}");
		}
		else
		{
			var paramDecls = string.Join(", ", paramArray.Select(p => $"{MakeNullable(p.Type)} {EscapeIdentifier(p.Name)}"));
			var tupleAssign = string.Join(", ", paramArray.Select(p => EscapeIdentifier(p.Name)));
			sb.AppendLine($"\t\tpublic void RecordCall({paramDecls}) {{ CallCount++; LastCallArgs = ({tupleAssign}); }}");
		}
		sb.AppendLine();
	}

	private static void GenerateFlatResetMethod(System.Text.StringBuilder sb, MethodOverloadInfo overload)
	{
		var paramArray = overload.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();

		sb.AppendLine("\t\t/// <summary>Resets all tracking state.</summary>");
		sb.Append("\t\tpublic void Reset() { CallCount = 0; ");
		if (paramArray.Length == 1)
			sb.Append("LastCallArg = default; ");
		else if (paramArray.Length > 1)
			sb.Append("LastCallArgs = null; ");
		sb.AppendLine("OnCall = null; }");
	}

	/// <summary>
	/// Generate flat event interceptor class (no interface prefix)
	/// </summary>
	private static void GenerateFlatEventInterceptorClass(
		System.Text.StringBuilder sb,
		EventMemberInfo evt,
		string knockOffClassName)
	{
		var interceptClassName = $"{evt.Name}Interceptor";
		// Strip trailing ? from delegate type since we add our own nullable marker
		var delegateType = evt.FullDelegateTypeName.TrimEnd('?');

		sb.AppendLine($"\t/// <summary>Interceptor for {evt.Name} event.</summary>");
		sb.AppendLine($"\tpublic sealed class {interceptClassName}");
		sb.AppendLine("\t{");

		// Backing field for subscribers
		sb.AppendLine($"\t\tprivate {delegateType}? _handler;");
		sb.AppendLine();

		// Add/Remove tracking
		sb.AppendLine("\t\t/// <summary>Number of times event was subscribed to.</summary>");
		sb.AppendLine("\t\tpublic int AddCount { get; private set; }");
		sb.AppendLine();

		sb.AppendLine("\t\t/// <summary>Number of times event subscription was removed.</summary>");
		sb.AppendLine("\t\tpublic int RemoveCount { get; private set; }");
		sb.AppendLine();

		sb.AppendLine("\t\t/// <summary>Whether any handlers are subscribed.</summary>");
		sb.AppendLine("\t\tpublic bool HasSubscribers => _handler != null;");
		sb.AppendLine();

		// RecordAdd/RecordRemove methods
		sb.AppendLine($"\t\t/// <summary>Records an event subscription.</summary>");
		sb.AppendLine($"\t\tpublic void RecordAdd({delegateType}? value) {{ AddCount++; _handler = ({delegateType}?)global::System.Delegate.Combine(_handler, value); }}");
		sb.AppendLine();

		sb.AppendLine($"\t\t/// <summary>Records an event unsubscription.</summary>");
		sb.AppendLine($"\t\tpublic void RecordRemove({delegateType}? value) {{ RemoveCount++; _handler = ({delegateType}?)global::System.Delegate.Remove(_handler, value); }}");
		sb.AppendLine();

		// Raise method based on delegate kind
		GenerateFlatEventRaiseMethod(sb, evt);

		// Reset method
		sb.AppendLine("\t\t/// <summary>Resets all tracking state.</summary>");
		sb.AppendLine("\t\tpublic void Reset() { AddCount = 0; RemoveCount = 0; _handler = null; }");

		sb.AppendLine("\t}");
		sb.AppendLine();
	}

	private static void GenerateFlatEventRaiseMethod(System.Text.StringBuilder sb, EventMemberInfo evt)
	{
		var paramArray = evt.DelegateParameters.GetArray() ?? Array.Empty<ParameterInfo>();

		switch (evt.DelegateKind)
		{
			case EventDelegateKind.EventHandler:
				sb.AppendLine("\t\t/// <summary>Raises the event with the specified arguments.</summary>");
				sb.AppendLine("\t\tpublic void Raise(object? sender, global::System.EventArgs e) => _handler?.Invoke(sender, e);");
				sb.AppendLine();
				break;

			case EventDelegateKind.EventHandlerOfT:
				var eventArgsType = paramArray.Length > 1 ? paramArray[1].Type : "global::System.EventArgs";
				sb.AppendLine("\t\t/// <summary>Raises the event with the specified arguments.</summary>");
				sb.AppendLine($"\t\tpublic void Raise(object? sender, {eventArgsType} e) => _handler?.Invoke(sender, e);");
				sb.AppendLine();
				break;

			case EventDelegateKind.Action:
				if (paramArray.Length == 0)
				{
					sb.AppendLine("\t\t/// <summary>Raises the event.</summary>");
					sb.AppendLine("\t\tpublic void Raise() => _handler?.Invoke();");
				}
				else
				{
					var paramDecls = string.Join(", ", paramArray.Select(p => $"{p.Type} {EscapeIdentifier(p.Name)}"));
					var paramNames = string.Join(", ", paramArray.Select(p => EscapeIdentifier(p.Name)));
					sb.AppendLine("\t\t/// <summary>Raises the event with the specified arguments.</summary>");
					sb.AppendLine($"\t\tpublic void Raise({paramDecls}) => _handler?.Invoke({paramNames});");
				}
				sb.AppendLine();
				break;

			case EventDelegateKind.Func:
				var funcParamDecls = string.Join(", ", paramArray.Select(p => $"{p.Type} {EscapeIdentifier(p.Name)}"));
				var funcParamNames = string.Join(", ", paramArray.Select(p => EscapeIdentifier(p.Name)));
				var returnType = evt.ReturnTypeName ?? "object";
				sb.AppendLine("\t\t/// <summary>Raises the event with the specified arguments and returns the result.</summary>");
				sb.AppendLine($"\t\tpublic {returnType} Raise({funcParamDecls}) => _handler != null ? _handler.Invoke({funcParamNames}) : default!;");
				sb.AppendLine();
				break;

			case EventDelegateKind.Custom:
			default:
				// For custom delegates, generate a generic Raise
				if (paramArray.Length == 0)
				{
					sb.AppendLine("\t\t/// <summary>Raises the event.</summary>");
					sb.AppendLine("\t\tpublic void Raise() => (_handler as global::System.Action)?.Invoke();");
				}
				else
				{
					var customParamDecls = string.Join(", ", paramArray.Select(p => $"{p.Type} {EscapeIdentifier(p.Name)}"));
					var customParamNames = string.Join(", ", paramArray.Select(p => EscapeIdentifier(p.Name)));
					sb.AppendLine("\t\t/// <summary>Invokes the handler if subscribed.</summary>");
					sb.AppendLine($"\t\tpublic void Raise({customParamDecls}) => _handler?.DynamicInvoke({customParamNames});");
				}
				sb.AppendLine();
				break;
		}
	}

	/// <summary>
	/// Generate flat indexer backing dictionary (no interface prefix)
	/// </summary>
	private static void GenerateFlatIndexerBackingDictionary(System.Text.StringBuilder sb, InterfaceMemberInfo member)
	{
		var keyType = member.IndexerParameters.Count > 0
			? member.IndexerParameters.GetArray()![0].Type
			: "object";
		var backingName = $"{member.Name}Backing";

		sb.AppendLine($"\t/// <summary>Backing storage for {member.Name} indexer.</summary>");
		sb.AppendLine($"\tpublic global::System.Collections.Generic.Dictionary<{keyType}, {member.ReturnType}> {backingName} {{ get; }} = new();");
		sb.AppendLine();
	}

	/// <summary>
	/// Generate flat method explicit interface implementation
	/// </summary>
	private static void GenerateFlatMethodImplementation(
		System.Text.StringBuilder sb,
		InterfaceMemberInfo member,
		KnockOffTypeInfo typeInfo,
		MethodGroupInfo group)
	{
		var ifaceName = member.DeclaringInterfaceFullName;
		var hasOverloads = group.Overloads.Count > 1;

		// Find which overload this member corresponds to
		int overloadIndex = FindOverloadIndex(member, group);
		var suffix = hasOverloads ? (overloadIndex + 1).ToString() : "";
		var interceptorName = $"{member.Name}{suffix}";

		var paramArray = member.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();
		var paramDecls = string.Join(", ", paramArray.Select(p => $"{p.Type} {EscapeIdentifier(p.Name)}"));
		var paramNames = string.Join(", ", paramArray.Select(p => EscapeIdentifier(p.Name)));

		// Handle generic methods
		var typeParamDecl = "";
		var typeParamList = "";
		var constraintClauses = "";
		if (member.IsGenericMethod && member.TypeParameters.Count > 0)
		{
			var tpArray = member.TypeParameters.GetArray() ?? Array.Empty<TypeParameterInfo>();
			typeParamDecl = $"<{string.Join(", ", tpArray.Select(tp => tp.Name))}>";
			typeParamList = typeParamDecl;
			// For explicit interface implementations, only class/struct constraints are allowed (CS0460)
			// Pass return type to determine if class constraint is needed for nullable returns
			constraintClauses = GetConstraintsForExplicitImpl(tpArray, member.ReturnType);
		}

		var returnType = member.ReturnType;
		var isVoid = returnType == "void";

		sb.AppendLine($"\t{returnType} {ifaceName}.{member.Name}{typeParamDecl}({paramDecls}){constraintClauses}");
		sb.AppendLine("\t{");

		// Record the call
		var recordArgs = paramNames.Length > 0 ? paramNames : "";
		sb.AppendLine($"\t\t{interceptorName}{typeParamList}.RecordCall({recordArgs});");

		// Check for user-defined method
		var userMethod = FindUserMethod(typeInfo.UserMethods, member);
		var onCallArgs = paramNames.Length > 0 ? $"this, {paramNames}" : "this";

		if (userMethod != null)
		{
			// OnCall callback takes priority, then user method
			// For generic methods, include type arguments in the call
			var userMethodTypeArgs = member.IsGenericMethod
				? $"<{string.Join(", ", member.TypeParameters.Select(tp => tp.Name))}>"
				: "";
			var userMethodCall = $"{member.Name}{userMethodTypeArgs}({paramNames})";
			if (isVoid)
			{
				sb.AppendLine($"\t\tif ({interceptorName}{typeParamList}.OnCall is {{ }} callback) {{ callback({onCallArgs}); return; }}");
				sb.AppendLine($"\t\t{userMethodCall};");
			}
			else
			{
				sb.AppendLine($"\t\tif ({interceptorName}{typeParamList}.OnCall is {{ }} callback) return callback({onCallArgs});");
				sb.AppendLine($"\t\treturn {userMethodCall};");
			}
		}
		else
		{
			// Use OnCall callback or default
			if (isVoid)
			{
				sb.AppendLine($"\t\t{interceptorName}{typeParamList}.OnCall?.Invoke({onCallArgs});");
			}
			else if (member.DefaultStrategy == DefaultValueStrategy.ThrowException)
			{
				// Non-nullable type without parameterless constructor - must throw
				sb.AppendLine($"\t\tif ({interceptorName}{typeParamList}.OnCall is {{ }} callback)");
				sb.AppendLine($"\t\t\treturn callback({onCallArgs});");
				sb.AppendLine($"\t\tthrow new global::System.InvalidOperationException(\"No implementation provided for {member.Name}. Set {interceptorName}.OnCall or define a protected method '{member.Name}' in your partial class.\");");
			}
			else
			{
				var defaultExpr = GetDefaultForType(returnType, member.DefaultStrategy, member.ConcreteTypeForNew);
				sb.AppendLine($"\t\treturn {interceptorName}{typeParamList}.OnCall?.Invoke({onCallArgs}) ?? {defaultExpr};");
			}
		}

		sb.AppendLine("\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generate flat event explicit interface implementation
	/// </summary>
	private static void GenerateFlatEventImplementation(System.Text.StringBuilder sb, EventMemberInfo evt)
	{
		var ifaceName = evt.DeclaringInterfaceFullName;
		// Property name is the event name (matches property generation above)
		var propertyName = evt.Name;
		// Strip trailing ? from delegate type since we add our own nullable marker
		var delegateType = evt.FullDelegateTypeName.TrimEnd('?');

		sb.AppendLine($"\tevent {delegateType}? {ifaceName}.{evt.Name}");
		sb.AppendLine("\t{");
		sb.AppendLine($"\t\tadd => {propertyName}.RecordAdd(value);");
		sb.AppendLine($"\t\tremove => {propertyName}.RecordRemove(value);");
		sb.AppendLine("\t}");
		sb.AppendLine();
	}

	// ===== WithName versions for flat API =====

	/// <summary>
	/// Generate flat indexer backing dictionary with custom name
	/// </summary>
	private static void GenerateFlatIndexerBackingDictionary(System.Text.StringBuilder sb, InterfaceMemberInfo member, string interceptorName)
	{
		var keyType = member.IndexerParameters.Count > 0
			? member.IndexerParameters.GetArray()![0].Type
			: "object";
		var backingName = $"{interceptorName}Backing";

		sb.AppendLine($"\t/// <summary>Backing storage for {member.Name} indexer.</summary>");
		sb.AppendLine($"\tpublic global::System.Collections.Generic.Dictionary<{keyType}, {member.ReturnType}> {backingName} {{ get; }} = new();");
		sb.AppendLine();
	}

	/// <summary>
	/// Generate flat property explicit interface implementation with custom name
	/// </summary>
	private static void GenerateFlatPropertyImplementationWithName(System.Text.StringBuilder sb, InterfaceMemberInfo member, string interceptorName)
	{
		var ifaceName = member.DeclaringInterfaceFullName;

		sb.AppendLine($"\t{member.ReturnType} {ifaceName}.{member.Name}");
		sb.AppendLine("\t{");

		if (member.HasGetter)
		{
			sb.AppendLine($"\t\tget {{ {interceptorName}.RecordGet(); return {interceptorName}.OnGet?.Invoke(this) ?? {interceptorName}.Value; }}");
		}

		if (member.HasSetter)
		{
			var pragmaDisable = GetSetterNullabilityAttribute(member);
			var pragmaRestore = GetSetterNullabilityRestore(member);
			if (!string.IsNullOrEmpty(pragmaDisable))
				sb.Append(pragmaDisable);
			sb.AppendLine($"\t\tset {{ {interceptorName}.RecordSet(value); if ({interceptorName}.OnSet != null) {interceptorName}.OnSet(this, value); else {interceptorName}.Value = value; }}");
			if (!string.IsNullOrEmpty(pragmaRestore))
				sb.AppendLine(pragmaRestore);
		}

		sb.AppendLine("\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generate flat indexer explicit interface implementation with custom name
	/// </summary>
	private static void GenerateFlatIndexerImplementationWithName(System.Text.StringBuilder sb, InterfaceMemberInfo member, string interceptorName)
	{
		var ifaceName = member.DeclaringInterfaceFullName;
		var backingName = $"{interceptorName}Backing";

		var keyType = member.IndexerParameters.Count > 0
			? member.IndexerParameters.GetArray()![0].Type
			: "object";
		var keyParam = member.IndexerParameters.Count > 0
			? member.IndexerParameters.GetArray()![0].Name
			: "key";

		sb.AppendLine($"\t{member.ReturnType} {ifaceName}.this[{keyType} {keyParam}]");
		sb.AppendLine("\t{");

		if (member.HasGetter)
		{
			var defaultExpr = member.IsNullable ? "default" : GetDefaultForType(member.ReturnType, member.DefaultStrategy, member.ConcreteTypeForNew);
			sb.AppendLine($"\t\tget {{ {interceptorName}.RecordGet({keyParam}); if ({interceptorName}.OnGet != null) return {interceptorName}.OnGet(this, {keyParam}); return {backingName}.TryGetValue({keyParam}, out var v) ? v : {defaultExpr}; }}");
		}

		if (member.HasSetter)
		{
			sb.AppendLine($"\t\tset {{ {interceptorName}.RecordSet({keyParam}, value); if ({interceptorName}.OnSet != null) {interceptorName}.OnSet(this, {keyParam}, value); else {backingName}[{keyParam}] = value; }}");
		}

		sb.AppendLine("\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generate flat method explicit interface implementation with name from map
	/// </summary>
	private static void GenerateFlatMethodImplementationWithName(
		System.Text.StringBuilder sb,
		InterfaceMemberInfo member,
		KnockOffTypeInfo typeInfo,
		MethodGroupInfo group,
		Dictionary<string, string> flatNameMap)
	{
		var ifaceName = member.DeclaringInterfaceFullName;
		var key = GetMemberKey(member);
		var interceptorName = flatNameMap[key];

		var paramArray = member.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();
		var paramDecls = string.Join(", ", paramArray.Select(p => FormatParameterWithRefKind(p)));
		var paramNames = string.Join(", ", paramArray.Select(p => FormatParameterNameWithRefKind(p)));

		// Handle generic methods
		var typeParamDecl = "";
		var ofTypeAccess = "";
		var constraintClauses = "";
		if (member.IsGenericMethod && member.TypeParameters.Count > 0)
		{
			var tpArray = member.TypeParameters.GetArray() ?? Array.Empty<TypeParameterInfo>();
			var typeParamNames = string.Join(", ", tpArray.Select(tp => tp.Name));
			typeParamDecl = $"<{typeParamNames}>";
			// Generic methods use .Of<T>() pattern
			ofTypeAccess = $".Of<{typeParamNames}>()";
			// For explicit interface implementations, only class/struct constraints are allowed (CS0460)
			// Pass return type to determine if class constraint is needed for nullable returns
			constraintClauses = GetConstraintsForExplicitImpl(tpArray, member.ReturnType);
		}

		var returnType = member.ReturnType;
		var isVoid = returnType == "void";

		sb.AppendLine($"\t{returnType} {ifaceName}.{member.Name}{typeParamDecl}({paramDecls}){constraintClauses}");
		sb.AppendLine("\t{");

		// Initialize out parameters
		foreach (var p in paramArray.Where(p => p.RefKind == RefKind.Out))
		{
			sb.AppendLine($"\t\t{EscapeIdentifier(p.Name)} = default!;");
		}

		// Build the interceptor access expression (with .Of<T>() for generic methods)
		var interceptorAccess = $"{interceptorName}{ofTypeAccess}";

		// For generic methods, only record non-generic parameters
		ParameterInfo[] recordParams;
		if (member.IsGenericMethod && member.TypeParameters.Count > 0)
		{
			var tpArray = member.TypeParameters.GetArray() ?? Array.Empty<TypeParameterInfo>();
			recordParams = paramArray
				.Where(p => p.RefKind != RefKind.Out)
				.Where(p => !tpArray.Any(tp => p.Type.Contains(tp.Name)))
				.ToArray();
		}
		else
		{
			recordParams = paramArray.Where(p => p.RefKind != RefKind.Out).ToArray();
		}

		var recordArgs = recordParams.Length > 0
			? string.Join(", ", recordParams.Select(p => EscapeIdentifier(p.Name)))
			: "";
		sb.AppendLine($"\t\t{interceptorAccess}.RecordCall({recordArgs});");

		// Check for user-defined method
		var userMethod = FindUserMethod(typeInfo.UserMethods, member);
		var hasRefOrOut = paramArray.Any(p => p.RefKind == RefKind.Ref || p.RefKind == RefKind.Out);
		var onCallArgs = hasRefOrOut
			? "this, " + string.Join(", ", paramArray.Select(p => FormatParameterNameWithRefKind(p)))
			: (paramArray.Length > 0 ? $"this, {string.Join(", ", paramArray.Select(p => EscapeIdentifier(p.Name)))}" : "this");

		if (userMethod != null)
		{
			// OnCall callback takes priority, then user method
			// For generic methods, include type arguments in the call
			var userMethodTypeArgs = member.IsGenericMethod
				? $"<{string.Join(", ", member.TypeParameters.Select(tp => tp.Name))}>"
				: "";
			var userMethodCall = $"{member.Name}{userMethodTypeArgs}({paramNames})";
			if (isVoid)
			{
				sb.AppendLine($"\t\tif ({interceptorAccess}.OnCall is {{ }} callback) {{ callback({onCallArgs}); return; }}");
				sb.AppendLine($"\t\t{userMethodCall};");
			}
			else
			{
				sb.AppendLine($"\t\tif ({interceptorAccess}.OnCall is {{ }} callback) return callback({onCallArgs});");
				sb.AppendLine($"\t\treturn {userMethodCall};");
			}
		}
		else
		{
			// Check for OnCall callback
			if (hasRefOrOut)
			{
				// For ref/out methods, we need to call the delegate and then return
				if (isVoid)
				{
					sb.AppendLine($"\t\tif ({interceptorAccess}.OnCall is {{ }} onCallCallback)");
					sb.AppendLine($"\t\t{{ onCallCallback({onCallArgs}); return; }}");
				}
				else
				{
					sb.AppendLine($"\t\tif ({interceptorAccess}.OnCall is {{ }} onCallCallback)");
					sb.AppendLine($"\t\t\treturn onCallCallback({onCallArgs});");
					if (member.IsGenericMethod && member.IsNullable)
					{
						sb.AppendLine($"\t\treturn default!;");
					}
					else if (member.IsGenericMethod)
					{
						var defaultExpr = "SmartDefault<" + returnType.TrimEnd('?') + $">(\"{member.Name}\")";
						sb.AppendLine($"\t\treturn {defaultExpr};");
					}
					else if (member.DefaultStrategy == DefaultValueStrategy.ThrowException)
					{
						sb.AppendLine($"\t\tthrow new global::System.InvalidOperationException(\"No implementation provided for {member.Name}. Set {interceptorAccess}.OnCall or define a protected method '{member.Name}' in your partial class.\");");
					}
					else
					{
						var defaultExpr = GetDefaultForType(returnType, member.DefaultStrategy, member.ConcreteTypeForNew);
						sb.AppendLine($"\t\treturn {defaultExpr};");
					}
				}
			}
			else
			{
				// Standard invocation
				if (isVoid)
				{
					sb.AppendLine($"\t\t{interceptorAccess}.OnCall?.Invoke({onCallArgs});");
				}
				else if (member.IsGenericMethod)
				{
					// For generic methods, check nullability first, then use SmartDefault
					sb.AppendLine($"\t\tif ({interceptorAccess}.OnCall is {{ }} callback)");
					sb.AppendLine($"\t\t\treturn callback({onCallArgs});");
					if (member.IsNullable)
					{
						// Nullable generic return - return default (null)
						sb.AppendLine($"\t\treturn default!;");
					}
					else
					{
						var defaultExpr = "SmartDefault<" + returnType.TrimEnd('?') + $">(\"{member.Name}\")";
						sb.AppendLine($"\t\treturn {defaultExpr};");
					}
				}
				else if (member.DefaultStrategy == DefaultValueStrategy.ThrowException)
				{
					// Non-nullable type without parameterless constructor - must throw
					sb.AppendLine($"\t\tif ({interceptorAccess}.OnCall is {{ }} callback)");
					sb.AppendLine($"\t\t\treturn callback({onCallArgs});");
					sb.AppendLine($"\t\tthrow new global::System.InvalidOperationException(\"No implementation provided for {member.Name}. Set {interceptorAccess}.OnCall or define a protected method '{member.Name}' in your partial class.\");");
				}
				else
				{
					var defaultExpr = GetDefaultForType(returnType, member.DefaultStrategy, member.ConcreteTypeForNew);
					sb.AppendLine($"\t\treturn {interceptorAccess}.OnCall?.Invoke({onCallArgs}) ?? {defaultExpr};");
				}
			}
		}

		sb.AppendLine("\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generate flat event explicit interface implementation with custom name
	/// </summary>
	private static void GenerateFlatEventImplementationWithName(System.Text.StringBuilder sb, EventMemberInfo evt, string interceptorName)
	{
		var ifaceName = evt.DeclaringInterfaceFullName;
		// Strip trailing ? from delegate type since we add our own nullable marker
		var delegateType = evt.FullDelegateTypeName.TrimEnd('?');

		sb.AppendLine($"\tevent {delegateType}? {ifaceName}.{evt.Name}");
		sb.AppendLine("\t{");
		sb.AppendLine($"\t\tadd => {interceptorName}.RecordAdd(value);");
		sb.AppendLine($"\t\tremove => {interceptorName}.RecordRemove(value);");
		sb.AppendLine("\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generate flat method group interceptor classes using name map
	/// </summary>
	private static void GenerateFlatMethodGroupInterceptorClassWithNames(
		System.Text.StringBuilder sb,
		MethodGroupInfo group,
		string knockOffClassName,
		Dictionary<string, string> flatNameMap)
	{
		var overloads = group.Overloads.GetArray() ?? Array.Empty<MethodOverloadInfo>();

		foreach (var overload in overloads)
		{
			// Build a key from this overload to find its name in the map
			var paramTypes = string.Join(",", overload.Parameters.Select(p => p.Type));
			var key = $"method:{group.Name}({paramTypes})";
			var interceptorName = flatNameMap[key];

			GenerateFlatSingleMethodInterceptorClassWithName(sb, group.Name, overload, group, knockOffClassName, interceptorName);
		}
	}

	/// <summary>
	/// Generate a single method interceptor class with custom name
	/// </summary>
	private static void GenerateFlatSingleMethodInterceptorClassWithName(
		System.Text.StringBuilder sb,
		string methodName,
		MethodOverloadInfo overload,
		MethodGroupInfo group,
		string knockOffClassName,
		string interceptorName)
	{
		var interceptClassName = $"{interceptorName}Interceptor";

		var isGeneric = overload.IsGenericMethod;
		var typeParams = overload.TypeParameters;

		sb.AppendLine($"\t/// <summary>Tracks and configures behavior for {methodName}.</summary>");

		if (isGeneric)
		{
			var typeParamList = string.Join(", ", typeParams.Select(tp => tp.Name));
			sb.AppendLine($"\tpublic sealed class {interceptClassName}<{typeParamList}> : IGenericMethodCallTracker, IResettable");
		}
		else
		{
			sb.AppendLine($"\tpublic sealed class {interceptClassName}");
		}

		sb.AppendLine("\t{");

		// Generate delegate for methods with out/ref parameters
		var paramArray = overload.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();
		var hasRefOrOut = paramArray.Any(p => p.RefKind == RefKind.Ref || p.RefKind == RefKind.Out);

		if (hasRefOrOut || !group.IsVoid)
		{
			// Generate delegate type
			var delegateParams = new List<string> { $"{knockOffClassName} ko" };
			foreach (var p in paramArray)
			{
				delegateParams.Add(FormatParameterWithRefKind(p));
			}
			var delegateParamList = string.Join(", ", delegateParams);

			sb.AppendLine($"\t\t/// <summary>Delegate for {methodName}.</summary>");
			if (group.IsVoid)
			{
				sb.AppendLine($"\t\tpublic delegate void {methodName}Delegate({delegateParamList});");
			}
			else
			{
				sb.AppendLine($"\t\tpublic delegate {group.ReturnType} {methodName}Delegate({delegateParamList});");
			}
			sb.AppendLine();
		}

		// CallCount
		sb.AppendLine("\t\t/// <summary>Number of times this method was called.</summary>");
		sb.AppendLine("\t\tpublic int CallCount { get; private set; }");
		sb.AppendLine();

		// WasCalled
		sb.AppendLine("\t\t/// <summary>Whether this method was called at least once.</summary>");
		sb.AppendLine("\t\tpublic bool WasCalled => CallCount > 0;");
		sb.AppendLine();

		// LastCallArg/LastCallArgs - only track non-out parameters
		var trackableParams = paramArray.Where(p => p.RefKind != RefKind.Out).ToArray();
		if (trackableParams.Length == 1)
		{
			var param = trackableParams[0];
			var nullableType = MakeNullable(param.Type);
			sb.AppendLine($"\t\t/// <summary>The argument from the most recent call.</summary>");
			sb.AppendLine($"\t\tpublic {nullableType} LastCallArg {{ get; private set; }}");
			sb.AppendLine();
		}
		else if (trackableParams.Length > 1)
		{
			var tupleTypes = string.Join(", ", trackableParams.Select(p => $"{MakeNullable(p.Type)} {EscapeIdentifier(p.Name)}"));
			sb.AppendLine($"\t\t/// <summary>The arguments from the most recent call.</summary>");
			sb.AppendLine($"\t\tpublic ({tupleTypes})? LastCallArgs {{ get; private set; }}");
			sb.AppendLine();
		}

		// OnCall
		sb.AppendLine("\t\t/// <summary>Callback invoked when this method is called.</summary>");
		if (hasRefOrOut || !group.IsVoid)
		{
			sb.AppendLine($"\t\tpublic {methodName}Delegate? OnCall {{ get; set; }}");
		}
		else if (paramArray.Length == 0)
		{
			sb.AppendLine($"\t\tpublic global::System.Action<{knockOffClassName}>? OnCall {{ get; set; }}");
		}
		else
		{
			var paramTypes = string.Join(", ", paramArray.Select(p => p.Type));
			sb.AppendLine($"\t\tpublic global::System.Action<{knockOffClassName}, {paramTypes}>? OnCall {{ get; set; }}");
		}
		sb.AppendLine();

		// RecordCall method - only record non-out parameters
		sb.AppendLine("\t\t/// <summary>Records a method call.</summary>");
		if (trackableParams.Length == 0)
		{
			sb.AppendLine("\t\tpublic void RecordCall() => CallCount++;");
		}
		else if (trackableParams.Length == 1)
		{
			var param = trackableParams[0];
			var nullableType = MakeNullable(param.Type);
			sb.AppendLine($"\t\tpublic void RecordCall({nullableType} {EscapeIdentifier(param.Name)}) {{ CallCount++; LastCallArg = {EscapeIdentifier(param.Name)}; }}");
		}
		else
		{
			var paramDecls = string.Join(", ", trackableParams.Select(p => $"{MakeNullable(p.Type)} {EscapeIdentifier(p.Name)}"));
			var tupleAssign = string.Join(", ", trackableParams.Select(p => EscapeIdentifier(p.Name)));
			sb.AppendLine($"\t\tpublic void RecordCall({paramDecls}) {{ CallCount++; LastCallArgs = ({tupleAssign}); }}");
		}
		sb.AppendLine();

		// Reset method
		sb.AppendLine("\t\t/// <summary>Resets all tracking state.</summary>");
		sb.Append("\t\tpublic void Reset() { CallCount = 0; ");
		if (trackableParams.Length == 1)
			sb.Append("LastCallArg = default; ");
		else if (trackableParams.Length > 1)
			sb.Append("LastCallArgs = null; ");
		sb.AppendLine("OnCall = null; }");

		sb.AppendLine("\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generate flat event interceptor class with custom name
	/// </summary>
	private static void GenerateFlatEventInterceptorClassWithName(
		System.Text.StringBuilder sb,
		EventMemberInfo evt,
		string knockOffClassName,
		string interceptorName)
	{
		var interceptClassName = $"{interceptorName}Interceptor";
		// Strip trailing ? from delegate type since we add our own nullable marker
		var delegateType = evt.FullDelegateTypeName.TrimEnd('?');

		sb.AppendLine($"\t/// <summary>Interceptor for {evt.Name} event.</summary>");
		sb.AppendLine($"\tpublic sealed class {interceptClassName}");
		sb.AppendLine("\t{");

		// Backing field for subscribers
		sb.AppendLine($"\t\tprivate {delegateType}? _handler;");
		sb.AppendLine();

		// Add/Remove tracking
		sb.AppendLine("\t\t/// <summary>Number of times event was subscribed to.</summary>");
		sb.AppendLine("\t\tpublic int AddCount { get; private set; }");
		sb.AppendLine();

		sb.AppendLine("\t\t/// <summary>Number of times event subscription was removed.</summary>");
		sb.AppendLine("\t\tpublic int RemoveCount { get; private set; }");
		sb.AppendLine();

		sb.AppendLine("\t\t/// <summary>Whether any handlers are subscribed.</summary>");
		sb.AppendLine("\t\tpublic bool HasSubscribers => _handler != null;");
		sb.AppendLine();

		// RecordAdd/RecordRemove methods
		sb.AppendLine($"\t\t/// <summary>Records an event subscription.</summary>");
		sb.AppendLine($"\t\tpublic void RecordAdd({delegateType}? value) {{ AddCount++; _handler = ({delegateType}?)global::System.Delegate.Combine(_handler, value); }}");
		sb.AppendLine();

		sb.AppendLine($"\t\t/// <summary>Records an event unsubscription.</summary>");
		sb.AppendLine($"\t\tpublic void RecordRemove({delegateType}? value) {{ RemoveCount++; _handler = ({delegateType}?)global::System.Delegate.Remove(_handler, value); }}");
		sb.AppendLine();

		// Raise method based on delegate kind
		GenerateFlatEventRaiseMethod(sb, evt);

		// Reset method
		sb.AppendLine("\t\t/// <summary>Resets all tracking state.</summary>");
		sb.AppendLine("\t\tpublic void Reset() { AddCount = 0; RemoveCount = 0; _handler = null; }");

		sb.AppendLine("\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generate flat interceptor properties for method groups
	/// </summary>
	private static void GenerateFlatMethodGroupInterceptorProperties(
		System.Text.StringBuilder sb,
		MethodGroupInfo group,
		Dictionary<string, string> flatNameMap)
	{
		var overloads = group.Overloads.GetArray() ?? Array.Empty<MethodOverloadInfo>();

		foreach (var overload in overloads)
		{
			var paramTypes = string.Join(",", overload.Parameters.Select(p => p.Type));
			var key = $"method:{group.Name}({paramTypes})";
			var interceptorName = flatNameMap[key];

			sb.AppendLine($"\t/// <summary>Interceptor for {group.Name}.</summary>");
			sb.AppendLine($"\tpublic {GetNewKeywordIfNeeded(interceptorName)}{interceptorName}Interceptor {interceptorName} {{ get; }} = new();");
			sb.AppendLine();
		}
	}

	/// <summary>
	/// Generate flat generic method handler with Of&lt;T&gt;() pattern
	/// </summary>
	private static void GenerateFlatGenericMethodHandler(
		System.Text.StringBuilder sb,
		MethodGroupInfo group,
		string knockOffClassName,
		Dictionary<string, string> flatNameMap)
	{
		// Get interceptor name for this generic method group
		// Note: group.Name may have "Generic" suffix from SplitMixedGroup, but the key in flatNameMap uses the original name
		var originalName = group.Name.EndsWith(GenericSuffix, StringComparison.Ordinal)
			? group.Name.Substring(0, group.Name.Length - GenericSuffix.Length)
			: group.Name;
		var genericKey = $"method:{originalName}()_generic";
		var interceptorName = flatNameMap[genericKey];
		var interceptClassName = $"{interceptorName}Interceptor";

		// Get type parameters from the first generic overload
		var genericOverload = group.Overloads.First(o => o.IsGenericMethod);
		var typeParams = genericOverload.TypeParameters.GetArray() ?? Array.Empty<TypeParameterInfo>();
		var typeParamNames = string.Join(", ", typeParams.Select(tp => tp.Name));
		var constraintClauses = GetConstraintClauses(typeParams);

		// Determine key type based on type parameter count
		var keyType = typeParams.Length == 1
			? "global::System.Type"
			: $"({string.Join(", ", typeParams.Select(_ => "global::System.Type"))})";

		var keyConstruction = typeParams.Length == 1
			? "typeof(T)"
			: $"({string.Join(", ", typeParams.Select(tp => $"typeof({tp.Name})"))})";

		var methodName = group.Name;
		var nonGenericParams = (genericOverload.Parameters.GetArray() ?? Array.Empty<ParameterInfo>())
			.Where(p => !typeParams.Any(tp => p.Type.Contains(tp.Name)))
			.ToArray();

		sb.AppendLine($"\t/// <summary>Interceptor for {methodName} (generic method with Of&lt;T&gt;() access).</summary>");
		sb.AppendLine($"\tpublic sealed class {interceptClassName}");
		sb.AppendLine("\t{");

		// Base Handler: Dictionary + Of<T>() + aggregate tracking
		sb.AppendLine($"\t\tprivate readonly global::System.Collections.Generic.Dictionary<{keyType}, object> _typedHandlers = new();");
		sb.AppendLine();

		// Of<T>() method
		sb.AppendLine($"\t\t/// <summary>Gets the typed handler for the specified type argument(s).</summary>");
		sb.AppendLine($"\t\tpublic {methodName}TypedHandler<{typeParamNames}> Of<{typeParamNames}>(){constraintClauses}");
		sb.AppendLine("\t\t{");
		sb.AppendLine($"\t\t\tvar key = {keyConstruction};");
		sb.AppendLine($"\t\t\tif (!_typedHandlers.TryGetValue(key, out var handler))");
		sb.AppendLine("\t\t\t{");
		sb.AppendLine($"\t\t\t\thandler = new {methodName}TypedHandler<{typeParamNames}>();");
		sb.AppendLine("\t\t\t\t_typedHandlers[key] = handler;");
		sb.AppendLine("\t\t\t}");
		sb.AppendLine($"\t\t\treturn ({methodName}TypedHandler<{typeParamNames}>)handler;");
		sb.AppendLine("\t\t}");
		sb.AppendLine();

		// Aggregate tracking
		sb.AppendLine("\t\t/// <summary>Total number of calls across all type arguments.</summary>");
		sb.AppendLine("\t\tpublic int TotalCallCount => _typedHandlers.Values.Sum(h => ((IGenericMethodCallTracker)h).CallCount);");
		sb.AppendLine();
		sb.AppendLine("\t\t/// <summary>True if this method was called with any type argument.</summary>");
		sb.AppendLine("\t\tpublic bool WasCalled => _typedHandlers.Values.Any(h => ((IGenericMethodCallTracker)h).WasCalled);");
		sb.AppendLine();
		sb.AppendLine($"\t\t/// <summary>All type argument(s) that were used in calls.</summary>");
		sb.AppendLine($"\t\tpublic global::System.Collections.Generic.IReadOnlyList<{keyType}> CalledTypeArguments => _typedHandlers.Keys.ToList();");
		sb.AppendLine();

		// Reset method
		sb.AppendLine("\t\t/// <summary>Resets all typed handlers.</summary>");
		sb.AppendLine("\t\tpublic void Reset()");
		sb.AppendLine("\t\t{");
		sb.AppendLine("\t\t\tforeach (var handler in _typedHandlers.Values)");
		sb.AppendLine("\t\t\t\t((IResettable)handler).Reset();");
		sb.AppendLine("\t\t\t_typedHandlers.Clear();");
		sb.AppendLine("\t\t}");
		sb.AppendLine();

		// Nested Typed Handler Class
		var isVoid = group.IsVoid;
		var delegateReturnType = isVoid ? "void" : group.ReturnType;
		var delegateParams = new List<string> { $"{knockOffClassName} ko" };
		foreach (var p in genericOverload.Parameters)
		{
			delegateParams.Add(FormatParameterWithRefKind(p));
		}
		var delegateParamList = string.Join(", ", delegateParams);

		sb.AppendLine($"\t\t/// <summary>Typed handler for {methodName} with specific type arguments.</summary>");
		sb.AppendLine($"\t\tpublic sealed class {methodName}TypedHandler<{typeParamNames}> : IGenericMethodCallTracker, IResettable{constraintClauses}");
		sb.AppendLine("\t\t{");

		sb.AppendLine($"\t\t\t/// <summary>Delegate for {methodName}.</summary>");
		if (isVoid)
		{
			sb.AppendLine($"\t\t\tpublic delegate void {methodName}Delegate({delegateParamList});");
		}
		else
		{
			sb.AppendLine($"\t\t\tpublic delegate {delegateReturnType} {methodName}Delegate({delegateParamList});");
		}
		sb.AppendLine();

		sb.AppendLine("\t\t\t/// <summary>Number of times this method was called with these type arguments.</summary>");
		sb.AppendLine("\t\t\tpublic int CallCount { get; private set; }");
		sb.AppendLine();

		// LastCallArg/LastCallArgs for non-generic params
		if (nonGenericParams.Length == 1)
		{
			var param = nonGenericParams[0];
			var nullableType = MakeNullable(param.Type);
			sb.AppendLine($"\t\t\t/// <summary>The '{param.Name}' argument from the most recent call.</summary>");
			sb.AppendLine($"\t\t\tpublic {nullableType} LastCallArg {{ get; private set; }}");
			sb.AppendLine();
		}
		else if (nonGenericParams.Length > 1)
		{
			var tupleType = "(" + string.Join(", ", nonGenericParams.Select(p => $"{MakeNullable(p.Type)} {EscapeIdentifier(p.Name)}")) + ")";
			sb.AppendLine("\t\t\t/// <summary>The arguments from the most recent call.</summary>");
			sb.AppendLine($"\t\t\tpublic {tupleType}? LastCallArgs {{ get; private set; }}");
			sb.AppendLine();
		}

		sb.AppendLine("\t\t\t/// <summary>True if this method was called at least once with these type arguments.</summary>");
		sb.AppendLine("\t\t\tpublic bool WasCalled => CallCount > 0;");
		sb.AppendLine();

		sb.AppendLine("\t\t\t/// <summary>Callback invoked when this method is called. If set, its return value is used.</summary>");
		sb.AppendLine($"\t\t\tpublic {methodName}Delegate? OnCall {{ get; set; }}");
		sb.AppendLine();

		// RecordCall method
		sb.AppendLine("\t\t\t/// <summary>Records a method call.</summary>");
		if (nonGenericParams.Length == 0)
		{
			sb.AppendLine("\t\t\tpublic void RecordCall() => CallCount++;");
		}
		else if (nonGenericParams.Length == 1)
		{
			var param = nonGenericParams[0];
			var nullableType = MakeNullable(param.Type);
			sb.AppendLine($"\t\t\tpublic void RecordCall({nullableType} {EscapeIdentifier(param.Name)}) {{ CallCount++; LastCallArg = {EscapeIdentifier(param.Name)}; }}");
		}
		else
		{
			var paramList = string.Join(", ", nonGenericParams.Select(p => $"{MakeNullable(p.Type)} {EscapeIdentifier(p.Name)}"));
			var tupleConstruction = "(" + string.Join(", ", nonGenericParams.Select(p => EscapeIdentifier(p.Name))) + ")";
			sb.AppendLine($"\t\t\tpublic void RecordCall({paramList}) {{ CallCount++; LastCallArgs = {tupleConstruction}; }}");
		}
		sb.AppendLine();

		// Reset method
		sb.AppendLine("\t\t\t/// <summary>Resets all tracking state.</summary>");
		if (nonGenericParams.Length == 0)
		{
			sb.AppendLine("\t\t\tpublic void Reset() { CallCount = 0; OnCall = null; }");
		}
		else if (nonGenericParams.Length == 1)
		{
			sb.AppendLine("\t\t\tpublic void Reset() { CallCount = 0; LastCallArg = default; OnCall = null; }");
		}
		else
		{
			sb.AppendLine("\t\t\tpublic void Reset() { CallCount = 0; LastCallArgs = default; OnCall = null; }");
		}

		sb.AppendLine("\t\t}");
		sb.AppendLine("\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Format a parameter declaration with ref/out/in keyword
	/// </summary>
	private static string FormatParameterWithRefKind(ParameterInfo p)
	{
		var refKindPrefix = p.RefKind switch
		{
			RefKind.Ref => "ref ",
			RefKind.Out => "out ",
			RefKind.In => "in ",
			_ => ""
		};
		return $"{refKindPrefix}{p.Type} {EscapeIdentifier(p.Name)}";
	}

	/// <summary>
	/// Format a parameter name with ref/out/in keyword for passing to another method
	/// </summary>
	private static string FormatParameterNameWithRefKind(ParameterInfo p)
	{
		var refKindPrefix = p.RefKind switch
		{
			RefKind.Ref => "ref ",
			RefKind.Out => "out ",
			RefKind.In => "in ",
			_ => ""
		};
		return $"{refKindPrefix}{EscapeIdentifier(p.Name)}";
	}

	private static int FindOverloadIndex(InterfaceMemberInfo member, MethodGroupInfo group)
	{
		var memberParams = member.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();
		var overloads = group.Overloads.GetArray() ?? Array.Empty<MethodOverloadInfo>();

		for (int i = 0; i < overloads.Length; i++)
		{
			var overloadParams = overloads[i].Parameters.GetArray() ?? Array.Empty<ParameterInfo>();
			if (memberParams.Length == overloadParams.Length)
			{
				bool match = true;
				for (int j = 0; j < memberParams.Length; j++)
				{
					if (memberParams[j].Type != overloadParams[j].Type)
					{
						match = false;
						break;
					}
				}
				if (match) return i;
			}
		}
		return 0;
	}

	#endregion
}
