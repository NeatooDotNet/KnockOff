// <auto-generated/> - Partial class extracted from KnockOffGenerator.cs
#nullable enable
using Microsoft.CodeAnalysis;
using System.Linq;

namespace KnockOff;

public partial class KnockOffGenerator
{
	#region Inline Stubs Generation

	/// <summary>
	/// Reports collected diagnostics to the source production context.
	/// </summary>
	private static void ReportDiagnostics(SourceProductionContext context, EquatableArray<DiagnosticInfo> diagnostics)
	{
		foreach (var diag in diagnostics)
		{
			var descriptor = diag.Id switch
			{
				"KO0008" => KO0008_TypeParameterArityMismatch,
				"KO0010" => KO0010_MultipleInterfaces,
				"KO1001" => KO1001_TypeMustBeInterfaceClassOrDelegate,
				"KO1002" => KO1002_NameCollision,
				"KO1003" => KO1003_StubsTypeConflict,
				"KO2001" => KO2001_CannotStubSealedClass,
				"KO2002" => KO2002_NoAccessibleConstructors,
				"KO2003" => KO2003_NonVirtualMemberSkipped,
				"KO2004" => KO2004_NoVirtualMembers,
				"KO2005" => KO2005_CannotStubStaticClass,
				"KO2006" => KO2006_CannotStubBuiltInType,
				_ => null
			};

			if (descriptor is not null)
			{
				var location = Location.Create(
					diag.FilePath,
					new Microsoft.CodeAnalysis.Text.TextSpan(0, 0),
					new Microsoft.CodeAnalysis.Text.LinePositionSpan(
						new Microsoft.CodeAnalysis.Text.LinePosition(diag.Line, diag.Column),
						new Microsoft.CodeAnalysis.Text.LinePosition(diag.Line, diag.Column)));

				context.ReportDiagnostic(Diagnostic.Create(descriptor, location, diag.Args));
			}
		}
	}

	/// <summary>
	/// Generates the Stubs nested class for inline stub pattern.
	/// Uses the model + renderer pattern for all stub types (interfaces, delegates, and classes).
	/// </summary>
	private static void GenerateInlineStubs(SourceProductionContext context, InlineStubClassInfo info)
	{
		// Report all collected diagnostics
		ReportDiagnostics(context, info.Diagnostics);

		// Check for blocking diagnostics - don't generate code if blocking errors present
		var hasBlockingDiagnostics = info.Diagnostics.Any(d => d.Id is "KO1002" or "KO1003" or "KO2001" or "KO2002" or "KO2005" or "KO2006");

		if (info.Interfaces.Count == 0 && info.Delegates.Count == 0 && info.Classes.Count == 0)
			return;

		if (hasBlockingDiagnostics)
			return;

		// Use model + renderer pattern for all stub types
		var unit = Builder.InlineModelBuilder.Build(info);
		var source = Renderer.InlineRenderer.Render(unit);

		// Build hint name including containing types to ensure uniqueness
		var hintName = info.ContainingTypes.Count > 0
			? string.Join(".", info.ContainingTypes.Select(ct => ct.Name)) + "." + info.ClassName
			: info.ClassName;

		context.AddSource($"{hintName}.Stubs.g.cs", source);
	}

	#endregion
}
