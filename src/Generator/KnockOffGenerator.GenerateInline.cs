// <auto-generated/> - Partial class extracted from KnockOffGenerator.cs
#nullable enable
using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;

namespace KnockOff;

public partial class KnockOffGenerator
{
	#region Inline Stubs Generation

	/// <summary>
	/// Reports collected diagnostics to the source production context.
	/// </summary>
	private static void ReportDiagnostics(SourceProductionContext context, EquatableArray<DiagnosticInfo> diagnostics)
	{
		foreach (var diag in diagnostics)
		{
			var descriptor = diag.Id switch
			{
				"KO0008" => KO0008_TypeParameterArityMismatch,
				"KO0010" => KO0010_MultipleInterfaces,
				"KO1001" => KO1001_TypeMustBeInterfaceClassOrDelegate,
				"KO1002" => KO1002_NameCollision,
				"KO1003" => KO1003_StubsTypeConflict,
				"KO2001" => KO2001_CannotStubSealedClass,
				"KO2002" => KO2002_NoAccessibleConstructors,
				"KO2003" => KO2003_NonVirtualMemberSkipped,
				"KO2004" => KO2004_NoVirtualMembers,
				"KO2005" => KO2005_CannotStubStaticClass,
				"KO2006" => KO2006_CannotStubBuiltInType,
				_ => null
			};

			if (descriptor is not null)
			{
				var location = Location.Create(
					diag.FilePath,
					new Microsoft.CodeAnalysis.Text.TextSpan(0, 0),
					new Microsoft.CodeAnalysis.Text.LinePositionSpan(
						new Microsoft.CodeAnalysis.Text.LinePosition(diag.Line, diag.Column),
						new Microsoft.CodeAnalysis.Text.LinePosition(diag.Line, diag.Column)));

				context.ReportDiagnostic(Diagnostic.Create(descriptor, location, diag.Args));
			}
		}
	}

	/// <summary>
	/// Generates the Stubs nested class for inline stub pattern.
	/// </summary>
	private static void GenerateInlineStubs(SourceProductionContext context, InlineStubClassInfo info)
	{
		// Report all collected diagnostics
		ReportDiagnostics(context, info.Diagnostics);

		// Check for blocking diagnostics - don't generate code if blocking errors present
		var hasBlockingDiagnostics = info.Diagnostics.Any(d => d.Id is "KO1002" or "KO1003" or "KO2001" or "KO2002" or "KO2005" or "KO2006");

		if (info.Interfaces.Count == 0 && info.Delegates.Count == 0 && info.Classes.Count == 0)
			return;

		if (hasBlockingDiagnostics)
			return;

		var sb = new System.Text.StringBuilder();

		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();

		if (!string.IsNullOrEmpty(info.Namespace))
		{
			sb.AppendLine($"namespace {info.Namespace};");
			sb.AppendLine();
		}

		// Open containing type wrappers for nested classes
		foreach (var containingType in info.ContainingTypes)
		{
			var accessMod = string.IsNullOrEmpty(containingType.AccessibilityModifier)
				? ""
				: containingType.AccessibilityModifier + " ";
			sb.AppendLine($"{accessMod}partial {containingType.Keyword} {containingType.Name}");
			sb.AppendLine("{");
		}

		sb.AppendLine($"partial class {info.ClassName}");
		sb.AppendLine("{");

		// Generate the nested Stubs class
		sb.AppendLine("\t/// <summary>Contains stub implementations for inline stub pattern.</summary>");
		sb.AppendLine("\tpublic static class Stubs");
		sb.AppendLine("\t{");

		// Check if any interface has generic methods - if so, generate helper interfaces
		var hasGenericMethods = info.Interfaces.Any(i => i.Members.Any(m => m.IsGenericMethod));
		if (hasGenericMethods)
		{
			sb.AppendLine("\t\tprivate interface IGenericMethodCallTracker { int CallCount { get; } bool WasCalled { get; } }");
			sb.AppendLine("\t\tprivate interface IResettable { void Reset(); }");
			sb.AppendLine();
		}

		foreach (var iface in info.Interfaces)
		{
			// Generate handler classes for this interface's members
			var methodGroups = GroupMethodsByName(iface.Members.Where(m => !m.IsProperty && !m.IsIndexer));

			// Deduplicate property/indexer members by name for interceptor class generation
			// (Keep first occurrence, which is from the most-derived interface)
			var processedPropertyNames = new HashSet<string>();
			var deduplicatedPropertyMembers = new List<InterfaceMemberInfo>();
			foreach (var member in iface.Members)
			{
				if (member.IsProperty || member.IsIndexer)
				{
					if (processedPropertyNames.Add(member.Name))
					{
						deduplicatedPropertyMembers.Add(member);
					}
				}
			}

			// Deduplicate events by name
			var processedEventNames = new HashSet<string>();
			var deduplicatedEvents = new List<EventMemberInfo>();
			foreach (var evt in iface.Events)
			{
				if (processedEventNames.Add(evt.Name))
				{
					deduplicatedEvents.Add(evt);
				}
			}

			// Generate handler classes for deduplicated properties/indexers
			foreach (var member in deduplicatedPropertyMembers)
			{
				GenerateInlineStubMemberHandlerClass(sb, member, iface.Name);
			}

			// Generate handler classes for methods
			foreach (var group in methodGroups.Values)
			{
				GenerateInlineStubMethodGroupHandlerClass(sb, group, iface.Name);
			}

			// Generate handler classes for deduplicated events
			foreach (var evt in deduplicatedEvents)
			{
				GenerateInlineStubEventHandlerClass(sb, evt, iface.Name);
			}

			// Generate the stub class implementing the interface
			// Pass deduplicated members for interceptor properties, but full members for implementations
			GenerateInlineStubClass(sb, iface, methodGroups, deduplicatedPropertyMembers, deduplicatedEvents);
		}

		// Generate delegate stub classes
		foreach (var del in info.Delegates)
		{
			GenerateDelegateStubClass(sb, del);
		}

		// Generate class stub classes (inheritance-based)
		foreach (var cls in info.Classes)
		{
			GenerateClassStubClass(sb, cls);
		}

		sb.AppendLine("\t}"); // Close Stubs class

		// Generate partial property implementations (outside Stubs class, inside partial class)
		foreach (var prop in info.PartialProperties)
		{
			var fieldName = $"__{prop.PropertyName}__Backing";
			var accessMod = string.IsNullOrEmpty(prop.AccessModifier) ? "" : $"{prop.AccessModifier} ";

			// Generate backing field
			sb.AppendLine();
			sb.AppendLine($"\tprivate readonly Stubs.{prop.StubTypeName} {fieldName} = new();");

			// Generate partial property implementation
			sb.AppendLine($"\t/// <summary>Auto-instantiated stub for {prop.StubTypeName}.</summary>");
			sb.AppendLine($"\t{accessMod}partial Stubs.{prop.StubTypeName} {prop.PropertyName} {{ get => {fieldName}; }}");
		}

		sb.AppendLine("}"); // Close partial class

		// Close containing type wrappers for nested classes
		for (int i = 0; i < info.ContainingTypes.Count; i++)
		{
			sb.AppendLine("}");
		}

		// Build hint name including containing types to ensure uniqueness
		var hintName = info.ContainingTypes.Count > 0
			? string.Join(".", info.ContainingTypes.Select(ct => ct.Name)) + "." + info.ClassName
			: info.ClassName;

		context.AddSource($"{hintName}.Stubs.g.cs", sb.ToString());
	}

	/// <summary>
	/// Generates a handler class for property/indexer member in inline stubs.
	/// </summary>
	private static void GenerateInlineStubMemberHandlerClass(
		System.Text.StringBuilder sb,
		InterfaceMemberInfo member,
		string interfaceSimpleName)
	{
		var interceptClassName = $"{interfaceSimpleName}_{member.Name}Interceptor";
		var stubClassName = $"Stubs.{interfaceSimpleName}";

		sb.AppendLine($"\t\t/// <summary>Interceptor for {interfaceSimpleName}.{member.Name}.</summary>");
		sb.AppendLine($"\t\tpublic sealed class {interceptClassName}");
		sb.AppendLine("\t\t{");

		if (member.IsIndexer)
		{
			GenerateInlineIndexerHandler(sb, member, stubClassName);
		}
		else if (member.IsProperty)
		{
			// Property: GetCount, SetCount, Value, OnGet, OnSet
			if (member.HasGetter)
			{
				sb.AppendLine("\t\t\t/// <summary>Number of times the getter was accessed.</summary>");
				sb.AppendLine("\t\t\tpublic int GetCount { get; private set; }");
				sb.AppendLine();
				sb.AppendLine($"\t\t\t/// <summary>Callback for getter. If set, returns its value.</summary>");
				sb.AppendLine($"\t\t\tpublic global::System.Func<{stubClassName}, {member.ReturnType}>? OnGet {{ get; set; }}");
				sb.AppendLine();
			}

			if (member.HasSetter)
			{
				sb.AppendLine("\t\t\t/// <summary>Number of times the setter was accessed.</summary>");
				sb.AppendLine("\t\t\tpublic int SetCount { get; private set; }");
				sb.AppendLine();
				var nullableType = MakeNullable(member.ReturnType);
				sb.AppendLine($"\t\t\t/// <summary>The last value passed to the setter.</summary>");
				sb.AppendLine($"\t\t\tpublic {nullableType} LastSetValue {{ get; private set; }}");
				sb.AppendLine();
				sb.AppendLine($"\t\t\t/// <summary>Callback for setter.</summary>");
				sb.AppendLine($"\t\t\tpublic global::System.Action<{stubClassName}, {member.ReturnType}>? OnSet {{ get; set; }}");
				sb.AppendLine();
			}

			// Value property (for stubbing return value)
			sb.AppendLine($"\t\t\t/// <summary>Value returned by getter when OnGet is not set.</summary>");
			sb.AppendLine($"\t\t\tpublic {member.ReturnType} Value {{ get; set; }} = default!;");
			sb.AppendLine();

			// RecordGet/RecordSet
			if (member.HasGetter)
			{
				sb.AppendLine("\t\t\t/// <summary>Records a getter access.</summary>");
				sb.AppendLine("\t\t\tpublic void RecordGet() => GetCount++;");
				sb.AppendLine();
			}
			if (member.HasSetter)
			{
				var nullableType = MakeNullable(member.ReturnType);
				sb.AppendLine("\t\t\t/// <summary>Records a setter access.</summary>");
				sb.AppendLine($"\t\t\tpublic void RecordSet({nullableType} value) {{ SetCount++; LastSetValue = value; }}");
				sb.AppendLine();
			}

			// Reset method
			sb.AppendLine("\t\t\t/// <summary>Resets all tracking state.</summary>");
			sb.Append("\t\t\tpublic void Reset() { ");
			if (member.HasGetter) sb.Append("GetCount = 0; OnGet = null; ");
			if (member.HasSetter) sb.Append("SetCount = 0; LastSetValue = default; OnSet = null; ");
			sb.Append("Value = default!; ");
			sb.AppendLine("}");
		}

		sb.AppendLine("\t\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates handler content for indexer in inline stubs.
	/// </summary>
	private static void GenerateInlineIndexerHandler(
		System.Text.StringBuilder sb,
		InterfaceMemberInfo member,
		string stubClassName)
	{
		var keyType = member.IndexerParameters.Count == 1
			? member.IndexerParameters.GetArray()![0].Type
			: $"({string.Join(", ", member.IndexerParameters.Select(p => $"{p.Type} {p.Name}"))})";

		if (member.HasGetter)
		{
			sb.AppendLine("\t\t\t/// <summary>Number of times the getter was accessed.</summary>");
			sb.AppendLine("\t\t\tpublic int GetCount { get; private set; }");
			sb.AppendLine();

			var nullableKeyType = MakeNullable(keyType);
			sb.AppendLine($"\t\t\t/// <summary>The last key used to access the getter.</summary>");
			sb.AppendLine($"\t\t\tpublic {nullableKeyType} LastGetKey {{ get; private set; }}");
			sb.AppendLine();

			// OnGet callback
			var paramList = string.Join(", ", member.IndexerParameters.Select(p => p.Type));
			sb.AppendLine($"\t\t\t/// <summary>Callback for getter.</summary>");
			sb.AppendLine($"\t\t\tpublic global::System.Func<{stubClassName}, {paramList}, {member.ReturnType}>? OnGet {{ get; set; }}");
			sb.AppendLine();
		}

		if (member.HasSetter)
		{
			sb.AppendLine("\t\t\t/// <summary>Number of times the setter was accessed.</summary>");
			sb.AppendLine("\t\t\tpublic int SetCount { get; private set; }");
			sb.AppendLine();

			var entryType = $"({keyType} Key, {member.ReturnType} Value)";
			sb.AppendLine($"\t\t\t/// <summary>The last key-value pair passed to the setter.</summary>");
			sb.AppendLine($"\t\t\tpublic {entryType}? LastSetEntry {{ get; private set; }}");
			sb.AppendLine();

			// OnSet callback
			var paramList = string.Join(", ", member.IndexerParameters.Select(p => p.Type));
			sb.AppendLine($"\t\t\t/// <summary>Callback for setter.</summary>");
			sb.AppendLine($"\t\t\tpublic global::System.Action<{stubClassName}, {paramList}, {member.ReturnType}>? OnSet {{ get; set; }}");
			sb.AppendLine();
		}

		// RecordGet/RecordSet
		if (member.HasGetter)
		{
			var paramSig = string.Join(", ", member.IndexerParameters.Select(p => $"{p.Type} {p.Name}"));
			var keyExpr = member.IndexerParameters.Count == 1
				? member.IndexerParameters.GetArray()![0].Name
				: $"({string.Join(", ", member.IndexerParameters.Select(p => p.Name))})";
			sb.AppendLine($"\t\t\t/// <summary>Records a getter access.</summary>");
			sb.AppendLine($"\t\t\tpublic void RecordGet({paramSig}) {{ GetCount++; LastGetKey = {keyExpr}; }}");
			sb.AppendLine();
		}
		if (member.HasSetter)
		{
			var paramSig = string.Join(", ", member.IndexerParameters.Select(p => $"{p.Type} {p.Name}"));
			var keyExpr = member.IndexerParameters.Count == 1
				? member.IndexerParameters.GetArray()![0].Name
				: $"({string.Join(", ", member.IndexerParameters.Select(p => p.Name))})";
			sb.AppendLine($"\t\t\t/// <summary>Records a setter access.</summary>");
			sb.AppendLine($"\t\t\tpublic void RecordSet({paramSig}, {member.ReturnType} value) {{ SetCount++; LastSetEntry = ({keyExpr}, value); }}");
			sb.AppendLine();
		}

		// Reset method
		sb.AppendLine("\t\t\t/// <summary>Resets all tracking state.</summary>");
		sb.Append("\t\t\tpublic void Reset() { ");
		if (member.HasGetter) sb.Append("GetCount = 0; LastGetKey = default; OnGet = null; ");
		if (member.HasSetter) sb.Append("SetCount = 0; LastSetEntry = default; OnSet = null; ");
		sb.AppendLine("}");
	}

	/// <summary>
	/// Generates a handler class for method group in inline stubs.
	/// </summary>
	private static void GenerateInlineStubMethodGroupHandlerClass(
		System.Text.StringBuilder sb,
		MethodGroupInfo group,
		string interfaceSimpleName)
	{
		// Check if this is a mixed group (has both generic and non-generic overloads)
		if (IsMixedMethodGroup(group))
		{
			// Split into two sub-groups and generate both interceptor classes
			var (nonGenericGroup, genericGroup) = SplitMixedGroup(group);

			if (nonGenericGroup is not null)
			{
				GenerateInlineStubNonGenericMethodHandlerClass(sb, nonGenericGroup, interfaceSimpleName);
			}

			if (genericGroup is not null)
			{
				GenerateInlineStubGenericMethodHandlerClass(sb, genericGroup, interfaceSimpleName);
			}
		}
		else
		{
			// Not mixed - use original either/or logic
			var hasGenericOverload = group.Overloads.Any(o => o.IsGenericMethod);

			if (hasGenericOverload)
			{
				GenerateInlineStubGenericMethodHandlerClass(sb, group, interfaceSimpleName);
			}
			else
			{
				GenerateInlineStubNonGenericMethodHandlerClass(sb, group, interfaceSimpleName);
			}
		}
	}

	private static void GenerateInlineStubNonGenericMethodHandlerClass(
		System.Text.StringBuilder sb,
		MethodGroupInfo group,
		string interfaceSimpleName)
	{
		var interceptClassName = $"{interfaceSimpleName}_{group.Name}Interceptor";
		var stubClassName = $"Stubs.{interfaceSimpleName}";
		var inputParams = GetInputCombinedParameters(group.CombinedParameters).ToArray();

		sb.AppendLine($"\t\t/// <summary>Interceptor for {interfaceSimpleName}.{group.Name}.</summary>");
		sb.AppendLine($"\t\tpublic sealed class {interceptClassName}");
		sb.AppendLine("\t\t{");

		// Delegate type for OnCall
		var delegateParamTypes = string.Join(", ", inputParams.Select(p => p.NullableType));
		var delegateParams = string.IsNullOrEmpty(delegateParamTypes)
			? stubClassName
			: $"{stubClassName}, {delegateParamTypes}";
		var delegateType = group.IsVoid
			? $"global::System.Action<{delegateParams}>"
			: $"global::System.Func<{delegateParams}, {group.ReturnType}>";

		sb.AppendLine("\t\t\t/// <summary>Number of times this method was called.</summary>");
		sb.AppendLine("\t\t\tpublic int CallCount { get; private set; }");
		sb.AppendLine();
		sb.AppendLine("\t\t\t/// <summary>Whether this method was called at least once.</summary>");
		sb.AppendLine("\t\t\tpublic bool WasCalled => CallCount > 0;");
		sb.AppendLine();

		// LastCallArg / LastCallArgs - always nullable since default before any call
		if (inputParams.Length == 1)
		{
			var param = inputParams[0];
			var nullableArgType = MakeNullable(param.Type);
			sb.AppendLine($"\t\t\t/// <summary>The argument from the last call.</summary>");
			sb.AppendLine($"\t\t\tpublic {nullableArgType} LastCallArg {{ get; private set; }}");
			sb.AppendLine();
		}
		else if (inputParams.Length > 1)
		{
			var tupleType = $"({string.Join(", ", inputParams.Select(p => $"{MakeNullable(p.Type)} {p.Name}"))})?";
			sb.AppendLine($"\t\t\t/// <summary>The arguments from the last call.</summary>");
			sb.AppendLine($"\t\t\tpublic {tupleType} LastCallArgs {{ get; private set; }}");
			sb.AppendLine();
		}

		// OnCall callback
		sb.AppendLine($"\t\t\t/// <summary>Callback invoked when method is called.</summary>");
		sb.AppendLine($"\t\t\tpublic {delegateType}? OnCall {{ get; set; }}");
		sb.AppendLine();

		// RecordCall method
		var recordParams = string.Join(", ", inputParams.Select(p => $"{p.NullableType} {p.Name}"));
		sb.Append($"\t\t\tpublic void RecordCall({recordParams}) {{ CallCount++; ");
		if (inputParams.Length == 1)
		{
			sb.Append($"LastCallArg = {inputParams[0].Name}; ");
		}
		else if (inputParams.Length > 1)
		{
			sb.Append($"LastCallArgs = ({string.Join(", ", inputParams.Select(p => p.Name))}); ");
		}
		sb.AppendLine("}");
		sb.AppendLine();

		// Reset method
		sb.Append("\t\t\tpublic void Reset() { CallCount = 0; ");
		if (inputParams.Length == 1)
		{
			sb.Append("LastCallArg = default; ");
		}
		else if (inputParams.Length > 1)
		{
			sb.Append("LastCallArgs = default; ");
		}
		sb.AppendLine("OnCall = null; }");

		sb.AppendLine("\t\t}");
		sb.AppendLine();
	}

	private static void GenerateInlineStubGenericMethodHandlerClass(
		System.Text.StringBuilder sb,
		MethodGroupInfo group,
		string interfaceSimpleName)
	{
		var interceptClassName = $"{interfaceSimpleName}_{group.Name}Interceptor";
		var stubClassName = $"Stubs.{interfaceSimpleName}";

		// Get the first generic overload's type parameters (all generic overloads should have same type param count)
		var genericOverload = group.Overloads.First(o => o.IsGenericMethod);
		var typeParams = genericOverload.TypeParameters.GetArray()!;
		var typeParamNames = string.Join(", ", typeParams.Select(tp => tp.Name));
		var typeParamCount = typeParams.Length;

		// Build constraint clauses for the type parameters
		var constraintClauses = GetConstraintClauses(typeParams);

		// Get non-generic parameters (parameters that are not type parameters)
		var typeParamSet = new HashSet<string>(typeParams.Select(tp => tp.Name));
		var nonGenericParams = GetInputCombinedParameters(group.CombinedParameters)
			.Where(p => !IsGenericParameterType(p.Type, typeParamSet))
			.ToArray();

		var isVoid = group.IsVoid;

		// Build the dictionary key type based on number of type parameters
		var keyType = typeParamCount == 1
			? "global::System.Type"
			: $"({string.Join(", ", typeParams.Select(_ => "global::System.Type"))})";

		var keyConstruction = typeParamCount == 1
			? $"typeof({typeParams[0].Name})"
			: $"({string.Join(", ", typeParams.Select(tp => $"typeof({tp.Name})"))})";

		sb.AppendLine($"\t\t/// <summary>Interceptor for {interfaceSimpleName}.{group.Name}.</summary>");
		sb.AppendLine($"\t\tpublic sealed class {interceptClassName}");
		sb.AppendLine("\t\t{");

		// --- Base Handler: Dictionary + Of<T>() + aggregate tracking ---
		sb.AppendLine($"\t\t\tprivate readonly global::System.Collections.Generic.Dictionary<{keyType}, object> _typedHandlers = new();");
		sb.AppendLine();

		// Of<T>() method
		sb.AppendLine($"\t\t\t/// <summary>Gets the typed handler for the specified type argument(s).</summary>");
		sb.AppendLine($"\t\t\tpublic {group.Name}TypedHandler<{typeParamNames}> Of<{typeParamNames}>(){constraintClauses}");
		sb.AppendLine("\t\t\t{");
		sb.AppendLine($"\t\t\t\tvar key = {keyConstruction};");
		sb.AppendLine($"\t\t\t\tif (!_typedHandlers.TryGetValue(key, out var handler))");
		sb.AppendLine("\t\t\t\t{");
		sb.AppendLine($"\t\t\t\t\thandler = new {group.Name}TypedHandler<{typeParamNames}>();");
		sb.AppendLine("\t\t\t\t\t_typedHandlers[key] = handler;");
		sb.AppendLine("\t\t\t\t}");
		sb.AppendLine($"\t\t\t\treturn ({group.Name}TypedHandler<{typeParamNames}>)handler;");
		sb.AppendLine("\t\t\t}");
		sb.AppendLine();

		// Aggregate tracking
		sb.AppendLine("\t\t\t/// <summary>Total number of calls across all type arguments.</summary>");
		sb.AppendLine("\t\t\tpublic int TotalCallCount => _typedHandlers.Values.Cast<IGenericMethodCallTracker>().Sum(h => h.CallCount);");
		sb.AppendLine();
		sb.AppendLine("\t\t\t/// <summary>True if this method was called with any type argument.</summary>");
		sb.AppendLine("\t\t\tpublic bool WasCalled => _typedHandlers.Values.Cast<IGenericMethodCallTracker>().Any(h => h.WasCalled);");
		sb.AppendLine();
		sb.AppendLine($"\t\t\t/// <summary>All type argument(s) that were used in calls.</summary>");
		sb.AppendLine($"\t\t\tpublic global::System.Collections.Generic.IReadOnlyList<{keyType}> CalledTypeArguments => _typedHandlers.Keys.ToList();");
		sb.AppendLine();

		// Reset method
		sb.AppendLine("\t\t\t/// <summary>Resets all typed handlers.</summary>");
		sb.AppendLine("\t\t\tpublic void Reset()");
		sb.AppendLine("\t\t\t{");
		sb.AppendLine("\t\t\t\tforeach (var handler in _typedHandlers.Values.Cast<IResettable>())");
		sb.AppendLine("\t\t\t\t\thandler.Reset();");
		sb.AppendLine("\t\t\t\t_typedHandlers.Clear();");
		sb.AppendLine("\t\t\t}");
		sb.AppendLine();

		// --- Nested Typed Handler Class ---
		sb.AppendLine($"\t\t\t/// <summary>Typed handler for {group.Name} with specific type arguments.</summary>");
		sb.AppendLine($"\t\t\tpublic sealed class {group.Name}TypedHandler<{typeParamNames}> : IGenericMethodCallTracker, IResettable{constraintClauses}");
		sb.AppendLine("\t\t\t{");

		// Delegate type - need to use actual return type which may include type parameters
		var delegateReturnType = isVoid ? "void" : group.ReturnType;

		// Get all parameters from the generic overload for the delegate signature
		var allParams = genericOverload.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();
		var delegateParams = new List<string> { $"{stubClassName} ko" };
		foreach (var p in allParams)
		{
			delegateParams.Add($"{p.Type} {p.Name}");
		}
		var delegateParamList = string.Join(", ", delegateParams);

		sb.AppendLine($"\t\t\t\t/// <summary>Delegate for {group.Name}.</summary>");
		if (isVoid)
		{
			sb.AppendLine($"\t\t\t\tpublic delegate void {group.Name}Delegate({delegateParamList});");
		}
		else
		{
			sb.AppendLine($"\t\t\t\tpublic delegate {delegateReturnType} {group.Name}Delegate({delegateParamList});");
		}
		sb.AppendLine();

		// Tracking storage - based on non-generic parameter count (no List for performance)
		sb.AppendLine("\t\t\t\t/// <summary>Number of times this method was called with these type arguments.</summary>");
		sb.AppendLine("\t\t\t\tpublic int CallCount { get; private set; }");
		sb.AppendLine();

		if (nonGenericParams.Length == 1)
		{
			var param = nonGenericParams[0];
			var nullableType = MakeNullable(param.Type);
			sb.AppendLine($"\t\t\t\t/// <summary>The '{param.Name}' argument from the most recent call.</summary>");
			sb.AppendLine($"\t\t\t\tpublic {nullableType} LastCallArg {{ get; private set; }}");
			sb.AppendLine();
		}
		else if (nonGenericParams.Length > 1)
		{
			var tupleType = "(" + string.Join(", ", nonGenericParams.Select(p => $"{p.Type} {p.Name}")) + ")";
			sb.AppendLine("\t\t\t\t/// <summary>The arguments from the most recent call.</summary>");
			sb.AppendLine($"\t\t\t\tpublic {tupleType}? LastCallArgs {{ get; private set; }}");
			sb.AppendLine();
		}

		sb.AppendLine("\t\t\t\t/// <summary>True if this method was called at least once with these type arguments.</summary>");
		sb.AppendLine("\t\t\t\tpublic bool WasCalled => CallCount > 0;");
		sb.AppendLine();

		sb.AppendLine("\t\t\t\t/// <summary>Callback invoked when this method is called. If set, its return value is used.</summary>");
		sb.AppendLine($"\t\t\t\tpublic {group.Name}Delegate? OnCall {{ get; set; }}");
		sb.AppendLine();

		// RecordCall method
		sb.AppendLine("\t\t\t\t/// <summary>Records a method call.</summary>");
		if (nonGenericParams.Length == 0)
		{
			sb.AppendLine("\t\t\t\tpublic void RecordCall() => CallCount++;");
		}
		else if (nonGenericParams.Length == 1)
		{
			var param = nonGenericParams[0];
			sb.AppendLine($"\t\t\t\tpublic void RecordCall({param.Type} {param.Name}) {{ CallCount++; LastCallArg = {param.Name}; }}");
		}
		else
		{
			var paramList = string.Join(", ", nonGenericParams.Select(p => $"{p.Type} {p.Name}"));
			var tupleConstruction = "(" + string.Join(", ", nonGenericParams.Select(p => p.Name)) + ")";
			sb.AppendLine($"\t\t\t\tpublic void RecordCall({paramList}) {{ CallCount++; LastCallArgs = {tupleConstruction}; }}");
		}
		sb.AppendLine();

		// Reset method
		sb.AppendLine("\t\t\t\t/// <summary>Resets all tracking state.</summary>");
		if (nonGenericParams.Length == 0)
		{
			sb.AppendLine("\t\t\t\tpublic void Reset() { CallCount = 0; OnCall = null; }");
		}
		else if (nonGenericParams.Length == 1)
		{
			sb.AppendLine("\t\t\t\tpublic void Reset() { CallCount = 0; LastCallArg = default; OnCall = null; }");
		}
		else
		{
			sb.AppendLine("\t\t\t\tpublic void Reset() { CallCount = 0; LastCallArgs = default; OnCall = null; }");
		}

		sb.AppendLine("\t\t\t}"); // Close TypedHandler class
		sb.AppendLine("\t\t}"); // Close Interceptor class
		sb.AppendLine();
	}

	/// <summary>
	/// Generates a handler class for event in inline stubs.
	/// </summary>
	private static void GenerateInlineStubEventHandlerClass(
		System.Text.StringBuilder sb,
		EventMemberInfo evt,
		string interfaceSimpleName)
	{
		var interceptClassName = $"{interfaceSimpleName}_{evt.Name}Interceptor";
		// Strip trailing ? from delegate type since we add our own nullable marker
		var delegateType = evt.FullDelegateTypeName.TrimEnd('?');

		sb.AppendLine($"\t\t/// <summary>Interceptor for {interfaceSimpleName}.{evt.Name} event.</summary>");
		sb.AppendLine($"\t\tpublic sealed class {interceptClassName}");
		sb.AppendLine("\t\t{");

		sb.AppendLine("\t\t\t/// <summary>Number of times the event was subscribed to.</summary>");
		sb.AppendLine("\t\t\tpublic int AddCount { get; private set; }");
		sb.AppendLine();
		sb.AppendLine("\t\t\t/// <summary>Number of times the event was unsubscribed from.</summary>");
		sb.AppendLine("\t\t\tpublic int RemoveCount { get; private set; }");
		sb.AppendLine();
		sb.AppendLine($"\t\t\t/// <summary>The backing delegate for raising the event.</summary>");
		sb.AppendLine($"\t\t\tpublic {delegateType}? Handler {{ get; private set; }}");
		sb.AppendLine();
		sb.AppendLine("\t\t\t/// <summary>Records an event subscription.</summary>");
		sb.AppendLine($"\t\t\tpublic void RecordAdd({delegateType}? handler) {{ AddCount++; Handler = ({delegateType}?)global::System.Delegate.Combine(Handler, handler); }}");
		sb.AppendLine();
		sb.AppendLine("\t\t\t/// <summary>Records an event unsubscription.</summary>");
		sb.AppendLine($"\t\t\tpublic void RecordRemove({delegateType}? handler) {{ RemoveCount++; Handler = ({delegateType}?)global::System.Delegate.Remove(Handler, handler); }}");
		sb.AppendLine();
		sb.AppendLine("\t\t\t/// <summary>Resets all tracking state.</summary>");
		sb.AppendLine("\t\t\tpublic void Reset() { AddCount = 0; RemoveCount = 0; Handler = null; }");

		sb.AppendLine("\t\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates the stub class implementing the interface in inline stubs.
	/// </summary>
	private static void GenerateInlineStubClass(
		System.Text.StringBuilder sb,
		InterfaceInfo iface,
		Dictionary<string, MethodGroupInfo> methodGroups,
		List<InterfaceMemberInfo> deduplicatedPropertyMembers,
		List<EventMemberInfo> deduplicatedEvents)
	{
		var stubClassName = iface.Name;

		sb.AppendLine($"\t\t/// <summary>Stub implementation of {iface.FullName}.</summary>");
		sb.AppendLine($"\t\tpublic class {stubClassName} : {iface.FullName}");
		sb.AppendLine("\t\t{");

		// Generate intercept properties (using deduplicated members to avoid duplicates)
		foreach (var member in deduplicatedPropertyMembers)
		{
			sb.AppendLine($"\t\t\t/// <summary>Interceptor for {member.Name}.</summary>");
			sb.AppendLine($"\t\t\tpublic {GetNewKeywordIfNeeded(member.Name)}{stubClassName}_{member.Name}Interceptor {member.Name} {{ get; }} = new();");
			sb.AppendLine();
		}
		foreach (var group in methodGroups.Values)
		{
			if (IsMixedMethodGroup(group))
			{
				// Mixed group: generate TWO properties (non-generic and generic with suffix)
				sb.AppendLine($"\t\t\t/// <summary>Interceptor for {group.Name} (non-generic overloads).</summary>");
				sb.AppendLine($"\t\t\tpublic {GetNewKeywordIfNeeded(group.Name)}{stubClassName}_{group.Name}Interceptor {group.Name} {{ get; }} = new();");
				sb.AppendLine();

				var genericName = group.Name + GenericSuffix;
				sb.AppendLine($"\t\t\t/// <summary>Interceptor for {group.Name} (generic overloads, use .Of&lt;T&gt;()).</summary>");
				sb.AppendLine($"\t\t\tpublic {GetNewKeywordIfNeeded(genericName)}{stubClassName}_{genericName}Interceptor {genericName} {{ get; }} = new();");
				sb.AppendLine();
			}
			else
			{
				sb.AppendLine($"\t\t\t/// <summary>Interceptor for {group.Name}.</summary>");
				sb.AppendLine($"\t\t\tpublic {GetNewKeywordIfNeeded(group.Name)}{stubClassName}_{group.Name}Interceptor {group.Name} {{ get; }} = new();");
				sb.AppendLine();
			}
		}
		foreach (var evt in deduplicatedEvents)
		{
			sb.AppendLine($"\t\t\t/// <summary>Interceptor for {evt.Name} event.</summary>");
			sb.AppendLine($"\t\t\tpublic {stubClassName}_{evt.Name}Interceptor {evt.Name}Interceptor {{ get; }} = new();");
			sb.AppendLine();
		}

		// Generate explicit interface implementations
		foreach (var member in iface.Members)
		{
			if (member.IsIndexer)
			{
				GenerateInlineStubIndexerImplementation(sb, member.DeclaringInterfaceFullName, member, stubClassName);
			}
			else if (member.IsProperty)
			{
				// Check if this base interface property should delegate to a typed counterpart
				// (e.g., IProperty.Value (object) delegates to IProperty<T>.Value (T))
				var propertyDelegationTarget = FindPropertyDelegationTarget(member, iface);
				if (propertyDelegationTarget != null)
				{
					GenerateInlineStubPropertyDelegationImplementation(sb, member, propertyDelegationTarget);
				}
				else
				{
					GenerateInlineStubPropertyImplementation(sb, member.DeclaringInterfaceFullName, member, stubClassName);
				}
			}
			else
			{
				// Check if this base interface method should delegate to a typed counterpart
				// (e.g., IRule.RunRule(IValidateBase) delegates to IRule<T>.RunRule(T))
				var delegationTarget = FindDelegationTarget(member, iface);
				if (delegationTarget != null)
				{
					GenerateInlineStubDelegationImplementation(sb, member, delegationTarget, iface.FullName);
				}
				else
				{
					var group = methodGroups[member.Name];

					// For mixed groups, use the appropriate sub-group so that group.Name matches the interceptor property
					if (IsMixedMethodGroup(group))
					{
						var (nonGenericGroup, genericGroup) = SplitMixedGroup(group);
						var effectiveGroup = member.IsGenericMethod ? genericGroup! : nonGenericGroup!;
						GenerateInlineStubMethodImplementation(sb, member.DeclaringInterfaceFullName, member, effectiveGroup, stubClassName);
					}
					else
					{
						GenerateInlineStubMethodImplementation(sb, member.DeclaringInterfaceFullName, member, group, stubClassName);
					}
				}
			}
		}

		// Generate event implementations
		foreach (var evt in iface.Events)
		{
			GenerateInlineStubEventImplementation(sb, evt.DeclaringInterfaceFullName, evt, stubClassName);
		}

		// Generate SmartDefault helper if interface has generic methods
		var hasGenericMethods = iface.Members.Any(m => m.IsGenericMethod);
		if (hasGenericMethods)
		{
			sb.AppendLine("\t\t\t/// <summary>Gets a smart default value for a generic type at runtime.</summary>");
			sb.AppendLine("\t\t\tprivate static T SmartDefault<T>(string methodName)");
			sb.AppendLine("\t\t\t{");
			sb.AppendLine("\t\t\t\tvar type = typeof(T);");
			sb.AppendLine();
			sb.AppendLine("\t\t\t\t// Value types -> default(T)");
			sb.AppendLine("\t\t\t\tif (type.IsValueType)");
			sb.AppendLine("\t\t\t\t\treturn default!;");
			sb.AppendLine();
			sb.AppendLine("\t\t\t\t// Check for parameterless constructor");
			sb.AppendLine("\t\t\t\tvar ctor = type.GetConstructor(");
			sb.AppendLine("\t\t\t\t\tSystem.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance,");
			sb.AppendLine("\t\t\t\t\tnull, System.Type.EmptyTypes, null);");
			sb.AppendLine();
			sb.AppendLine("\t\t\t\tif (ctor != null)");
			sb.AppendLine("\t\t\t\t\treturn (T)ctor.Invoke(null);");
			sb.AppendLine();
			sb.AppendLine("\t\t\t\tthrow new global::System.InvalidOperationException(");
			sb.AppendLine("\t\t\t\t\t$\"No implementation provided for {methodName}<{type.Name}>. \" +");
			sb.AppendLine("\t\t\t\t\t$\"Set the handler's OnCall.\");");
			sb.AppendLine("\t\t\t}");
			sb.AppendLine();
		}

		sb.AppendLine("\t\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates a stub class for a delegate type.
	/// </summary>
	private static void GenerateDelegateStubClass(
		System.Text.StringBuilder sb,
		DelegateInfo del)
	{
		var stubClassName = del.Name;
		var interceptClassName = $"{del.Name}Interceptor";

		// Generate handler class first
		sb.AppendLine($"\t\t/// <summary>Interceptor for {del.Name} delegate.</summary>");
		sb.AppendLine($"\t\tpublic sealed class {interceptClassName}");
		sb.AppendLine("\t\t{");

		// CallCount and WasCalled
		sb.AppendLine("\t\t\t/// <summary>Number of times this delegate was invoked.</summary>");
		sb.AppendLine("\t\t\tpublic int CallCount { get; private set; }");
		sb.AppendLine();
		sb.AppendLine("\t\t\t/// <summary>Whether this delegate was invoked at least once.</summary>");
		sb.AppendLine("\t\t\tpublic bool WasCalled => CallCount > 0;");
		sb.AppendLine();

		// LastCallArg/LastCallArgs based on parameter count
		if (del.Parameters.Count == 1)
		{
			var param = del.Parameters.GetArray()![0];
			var nullableType = MakeNullable(param.Type);
			sb.AppendLine($"\t\t\t/// <summary>The argument from the last invocation.</summary>");
			sb.AppendLine($"\t\t\tpublic {nullableType} LastCallArg {{ get; private set; }}");
			sb.AppendLine();
		}
		else if (del.Parameters.Count > 1)
		{
			var tupleTypes = string.Join(", ", del.Parameters.Select(p => $"{MakeNullable(p.Type)} {p.Name}"));
			sb.AppendLine($"\t\t\t/// <summary>The arguments from the last invocation.</summary>");
			sb.AppendLine($"\t\t\tpublic ({tupleTypes})? LastCallArgs {{ get; private set; }}");
			sb.AppendLine();
		}

		// OnCall callback
		var onCallType = GenerateOnCallType(del, $"Stubs.{stubClassName}");
		sb.AppendLine($"\t\t\t/// <summary>Callback invoked when delegate is called.</summary>");
		sb.AppendLine($"\t\t\tpublic {onCallType}? OnCall {{ get; set; }}");
		sb.AppendLine();

		// RecordCall method
		if (del.Parameters.Count == 0)
		{
			sb.AppendLine("\t\t\tpublic void RecordCall() { CallCount++; }");
		}
		else if (del.Parameters.Count == 1)
		{
			var param = del.Parameters.GetArray()![0];
			sb.AppendLine($"\t\t\tpublic void RecordCall({param.Type} {param.Name}) {{ CallCount++; LastCallArg = {param.Name}; }}");
		}
		else
		{
			var paramList = string.Join(", ", del.Parameters.Select(p => $"{p.Type} {p.Name}"));
			var argList = string.Join(", ", del.Parameters.Select(p => p.Name));
			sb.AppendLine($"\t\t\tpublic void RecordCall({paramList}) {{ CallCount++; LastCallArgs = ({argList}); }}");
		}
		sb.AppendLine();

		// Reset method
		sb.Append("\t\t\tpublic void Reset() { CallCount = 0; ");
		if (del.Parameters.Count == 1)
			sb.Append("LastCallArg = default; ");
		else if (del.Parameters.Count > 1)
			sb.Append("LastCallArgs = default; ");
		sb.AppendLine("OnCall = null; }");

		sb.AppendLine("\t\t}");
		sb.AppendLine();

		// Generate stub class
		sb.AppendLine($"\t\t/// <summary>Stub for {del.FullName} delegate.</summary>");
		sb.AppendLine($"\t\tpublic sealed class {stubClassName}");
		sb.AppendLine("\t\t{");

		// Interceptor property
		sb.AppendLine($"\t\t\t/// <summary>Interceptor for tracking and configuring delegate behavior.</summary>");
		sb.AppendLine($"\t\t\tpublic {interceptClassName} Interceptor {{ get; }} = new();");
		sb.AppendLine();

		// Private Invoke method
		var invokeParamList = string.Join(", ", del.Parameters.Select(p => $"{p.Type} {p.Name}"));
		var invokeArgList = string.Join(", ", del.Parameters.Select(p => p.Name));
		var recordCallArgs = del.Parameters.Count > 0 ? invokeArgList : "";

		sb.AppendLine($"\t\t\tprivate {del.ReturnType} Invoke({invokeParamList})");
		sb.AppendLine("\t\t\t{");
		sb.AppendLine($"\t\t\t\tInterceptor.RecordCall({recordCallArgs});");
		if (del.IsVoid)
		{
			var onCallArgs = del.Parameters.Count > 0 ? $"this, {invokeArgList}" : "this";
			sb.AppendLine($"\t\t\t\tif (Interceptor.OnCall is {{ }} onCall) onCall({onCallArgs});");
		}
		else
		{
			var onCallArgs = del.Parameters.Count > 0 ? $"this, {invokeArgList}" : "this";
			sb.AppendLine($"\t\t\t\tif (Interceptor.OnCall is {{ }} onCall) return onCall({onCallArgs});");
			var defaultExpr = GetDefaultForType(del.ReturnType, DefaultValueStrategy.Default, null);
			sb.AppendLine($"\t\t\t\treturn {defaultExpr};");
		}
		sb.AppendLine("\t\t\t}");
		sb.AppendLine();

		// Implicit conversion operator to delegate
		sb.AppendLine($"\t\t\t/// <summary>Implicit conversion to {del.FullName}.</summary>");
		sb.AppendLine($"\t\t\tpublic static implicit operator {del.FullName}({stubClassName} stub) => stub.Invoke;");

		sb.AppendLine("\t\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates the OnCall type signature for a delegate stub.
	/// </summary>
	private static string GenerateOnCallType(DelegateInfo del, string stubClassName)
	{
		if (del.IsVoid)
		{
			// Action<Stubs.DelegateName, ...params>
			if (del.Parameters.Count == 0)
				return $"global::System.Action<{stubClassName}>";
			var paramTypes = string.Join(", ", del.Parameters.Select(p => p.Type));
			return $"global::System.Action<{stubClassName}, {paramTypes}>";
		}
		else
		{
			// Func<Stubs.DelegateName, ...params, returnType>
			if (del.Parameters.Count == 0)
				return $"global::System.Func<{stubClassName}, {del.ReturnType}>";
			var paramTypes = string.Join(", ", del.Parameters.Select(p => p.Type));
			return $"global::System.Func<{stubClassName}, {paramTypes}, {del.ReturnType}>";
		}
	}


	/// <summary>
	/// Generates explicit property implementation for inline stubs.
	/// </summary>
	private static void GenerateInlineStubPropertyImplementation(
		System.Text.StringBuilder sb,
		string interfaceFullName,
		InterfaceMemberInfo member,
		string stubClassName)
	{
		sb.AppendLine($"\t\t\t{member.ReturnType} {interfaceFullName}.{member.Name}");
		sb.AppendLine("\t\t\t{");

		if (member.HasGetter)
		{
			sb.AppendLine("\t\t\t\tget");
			sb.AppendLine("\t\t\t\t{");
			sb.AppendLine($"\t\t\t\t\t{member.Name}.RecordGet();");
			sb.AppendLine($"\t\t\t\t\tif ({member.Name}.OnGet is {{ }} onGet) return onGet(this);");
			sb.AppendLine($"\t\t\t\t\treturn {member.Name}.Value;");
			sb.AppendLine("\t\t\t\t}");
		}

		if (member.HasSetter)
		{
			var pragmaDisable = GetSetterNullabilityAttribute(member);
			var pragmaRestore = GetSetterNullabilityRestore(member);
			if (!string.IsNullOrEmpty(pragmaDisable))
				sb.Append(pragmaDisable);
			sb.AppendLine("\t\t\t\tset");
			sb.AppendLine("\t\t\t\t{");
			sb.AppendLine($"\t\t\t\t\t{member.Name}.RecordSet(value);");
			sb.AppendLine($"\t\t\t\t\tif ({member.Name}.OnSet is {{ }} onSet) onSet(this, value);");
			sb.AppendLine($"\t\t\t\t\telse {member.Name}.Value = value;");
			sb.AppendLine("\t\t\t\t}");
			if (!string.IsNullOrEmpty(pragmaRestore))
				sb.AppendLine(pragmaRestore);
		}

		sb.AppendLine("\t\t\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates explicit indexer implementation for inline stubs.
	/// </summary>
	private static void GenerateInlineStubIndexerImplementation(
		System.Text.StringBuilder sb,
		string interfaceFullName,
		InterfaceMemberInfo member,
		string stubClassName)
	{
		var paramList = string.Join(", ", member.IndexerParameters.Select(p => $"{p.Type} {p.Name}"));
		var argList = string.Join(", ", member.IndexerParameters.Select(p => p.Name));

		sb.AppendLine($"\t\t\t{member.ReturnType} {interfaceFullName}.this[{paramList}]");
		sb.AppendLine("\t\t\t{");

		if (member.HasGetter)
		{
			sb.AppendLine("\t\t\t\tget");
			sb.AppendLine("\t\t\t\t{");
			sb.AppendLine($"\t\t\t\t\t{member.Name}.RecordGet({argList});");
			sb.AppendLine($"\t\t\t\t\tif ({member.Name}.OnGet is {{ }} onGet) return onGet(this, {argList});");
			sb.AppendLine($"\t\t\t\t\treturn default!;");
			sb.AppendLine("\t\t\t\t}");
		}

		if (member.HasSetter)
		{
			sb.AppendLine("\t\t\t\tset");
			sb.AppendLine("\t\t\t\t{");
			sb.AppendLine($"\t\t\t\t\t{member.Name}.RecordSet({argList}, value);");
			sb.AppendLine($"\t\t\t\t\tif ({member.Name}.OnSet is {{ }} onSet) onSet(this, {argList}, value);");
			sb.AppendLine("\t\t\t\t}");
		}

		sb.AppendLine("\t\t\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Finds a typed counterpart property in the interface hierarchy that this base interface property should delegate to.
	/// Returns null if no delegation target exists.
	/// </summary>
	/// <remarks>
	/// This handles the case where a generic interface like IProperty&lt;T&gt; inherits from IProperty,
	/// and both have properties with the same name but different types (T vs object).
	/// The base interface property should delegate to the typed version.
	///
	/// The delegation target may be declared on any interface in the hierarchy, not just the primary interface.
	/// For example: IEntityProperty&lt;string&gt; inherits IValidateProperty&lt;string&gt;,
	/// and the typed Value property is declared on IValidateProperty&lt;string&gt;, not IEntityProperty&lt;string&gt;.
	/// </remarks>
	private static InterfaceMemberInfo? FindPropertyDelegationTarget(
		InterfaceMemberInfo member,
		InterfaceInfo iface)
	{
		// Only applies to properties
		if (!member.IsProperty)
			return null;

		// The member with 'object' type should delegate to the member with specific type
		// If the member is already a specific type (not object), don't delegate
		var memberType = member.ReturnType.TrimEnd('?');
		if (memberType != "object" && memberType != "System.Object" &&
		    memberType != "global::System.Object")
		{
			return null;
		}

		// Look for a property with the same name but different (more specific) type
		// The candidate can be from any interface in the hierarchy
		foreach (var candidate in iface.Members)
		{
			// Skip if this is the same member
			if (candidate.DeclaringInterfaceFullName == member.DeclaringInterfaceFullName &&
			    candidate.Name == member.Name &&
			    candidate.ReturnType == member.ReturnType)
				continue;

			// Must be a property with the same name
			if (!candidate.IsProperty || candidate.Name != member.Name)
				continue;

			// Must have different return type (the property type)
			if (candidate.ReturnType == member.ReturnType)
				continue;

			// Found a property with same name and different type
			// This is the typed counterpart
			return candidate;
		}

		return null;
	}

	/// <summary>
	/// Generates a delegation implementation for a base interface property that delegates to its typed counterpart.
	/// </summary>
	private static void GenerateInlineStubPropertyDelegationImplementation(
		System.Text.StringBuilder sb,
		InterfaceMemberInfo baseMember,
		InterfaceMemberInfo targetMember)
	{
		// Cast to the interface where the target property is declared, not necessarily the primary interface
		var targetInterfaceFullName = targetMember.DeclaringInterfaceFullName;

		sb.AppendLine($"\t\t\t{baseMember.ReturnType} {baseMember.DeclaringInterfaceFullName}.{baseMember.Name}");
		sb.AppendLine("\t\t\t{");

		if (baseMember.HasGetter)
		{
			// Getter: return the typed property value (implicit conversion to base type)
			sb.AppendLine($"\t\t\t\tget => (({targetInterfaceFullName})this).{targetMember.Name};");
		}

		if (baseMember.HasSetter)
		{
			// Setter: cast value to typed property's type
			sb.AppendLine($"\t\t\t\tset => (({targetInterfaceFullName})this).{targetMember.Name} = ({targetMember.ReturnType})value;");
		}

		sb.AppendLine("\t\t\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Finds a typed counterpart method in the primary interface that this base interface method should delegate to.
	/// Returns null if no delegation target exists.
	/// </summary>
	/// <remarks>
	/// This handles the case where a generic interface like IRule&lt;T&gt; inherits from a non-generic interface IRule,
	/// and both have methods with the same name but different parameter/return types (T vs IValidateBase).
	/// The base interface method should delegate to the typed version instead of using its own interceptor.
	///
	/// Important: We check that parameter NAMES match to distinguish related methods from unrelated ones.
	/// For example, ICollection.Remove(item) should NOT delegate to IDictionary.Remove(key) even though
	/// both have one parameter - the different names indicate they're semantically different methods.
	/// </remarks>
	private static InterfaceMemberInfo? FindDelegationTarget(
		InterfaceMemberInfo member,
		InterfaceInfo iface)
	{
		// Only look for delegation targets if this member is from a base interface
		if (member.DeclaringInterfaceFullName == iface.FullName)
			return null;

		// Look for a method in the primary interface (iface.FullName) with the same name
		// but potentially different parameter/return types
		foreach (var candidate in iface.Members)
		{
			// Must be from the primary interface
			if (candidate.DeclaringInterfaceFullName != iface.FullName)
				continue;

			// Must have the same name
			if (candidate.Name != member.Name)
				continue;

			// Must have the same number of parameters
			if (candidate.Parameters.Count != member.Parameters.Count)
				continue;

			var candidateParams = candidate.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();
			var memberParams = member.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();

			// Parameter names must match - this indicates the methods are the same logical method
			// with different types due to generic type substitution, not unrelated methods that
			// happen to share a name (e.g., ICollection.Remove(item) vs IDictionary.Remove(key))
			bool sameParamNames = true;
			for (int i = 0; i < candidateParams.Length; i++)
			{
				if (candidateParams[i].Name != memberParams[i].Name)
				{
					sameParamNames = false;
					break;
				}
			}

			if (!sameParamNames)
				continue; // Different param names - these are independent methods

			// Check if signatures actually differ (parameter types or return type)
			bool signaturesMatch = member.ReturnType == candidate.ReturnType;
			if (signaturesMatch)
			{
				for (int i = 0; i < candidateParams.Length; i++)
				{
					if (candidateParams[i].Type != memberParams[i].Type)
					{
						signaturesMatch = false;
						break;
					}
				}
			}

			if (signaturesMatch)
				continue; // Exact same signature - not a delegation target

			// Found a method with same name, same param names, but different types
			// This is the typed counterpart (e.g., RunRule(ICustomValidateBase target) vs RunRule(IValidateBase target))
			// or a method with different return type (e.g., IEnumerable<T>.GetEnumerator vs IEnumerable.GetEnumerator)
			return candidate;
		}

		return null;
	}

	/// <summary>
	/// Generates a delegation implementation for a base interface method that delegates to its typed counterpart.
	/// </summary>
	private static void GenerateInlineStubDelegationImplementation(
		System.Text.StringBuilder sb,
		InterfaceMemberInfo baseMember,
		InterfaceMemberInfo targetMember,
		string primaryInterfaceFullName)
	{
		var baseParams = baseMember.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();
		var targetParams = targetMember.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();

		var paramList = string.Join(", ", baseParams.Select(p => FormatParameter(p)));
		var isVoid = baseMember.ReturnType == "void";

		sb.AppendLine($"\t\t\t{baseMember.ReturnType} {baseMember.DeclaringInterfaceFullName}.{baseMember.Name}({paramList})");
		sb.AppendLine("\t\t\t{");

		// Build the cast arguments: cast each parameter to the target type
		var castArgs = new List<string>();
		for (int i = 0; i < baseParams.Length; i++)
		{
			var baseName = baseParams[i].Name;
			var baseType = baseParams[i].Type;
			var targetType = targetParams[i].Type;

			if (baseType == targetType)
			{
				// Same type - no cast needed
				castArgs.Add(baseName);
			}
			else
			{
				// Different type - cast to target type
				castArgs.Add($"({targetType}){baseName}");
			}
		}

		var callArgs = string.Join(", ", castArgs);

		// Generate: return ((PrimaryInterface)this).Method(castArgs);
		if (isVoid)
		{
			sb.AppendLine($"\t\t\t\t(({primaryInterfaceFullName})this).{targetMember.Name}({callArgs});");
		}
		else
		{
			sb.AppendLine($"\t\t\t\treturn (({primaryInterfaceFullName})this).{targetMember.Name}({callArgs});");
		}

		sb.AppendLine("\t\t\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Finds a typed counterpart property across ALL interfaces that this base interface property should delegate to.
	/// Used for standalone stubs where we need to search across all implemented interfaces.
	/// </summary>
	/// <remarks>
	/// Only finds a delegation target when the member has a less specific type (like 'object')
	/// and the candidate has a more specific type. This ensures base interface properties
	/// delegate to typed interface properties, not the other way around.
	/// </remarks>
	private static (InterfaceMemberInfo? Target, string? TargetInterfaceFullName) FindPropertyDelegationTargetInInterfaces(
		InterfaceMemberInfo member,
		EquatableArray<InterfaceInfo> interfaces)
	{
		// Only applies to properties
		if (!member.IsProperty)
			return (null, null);

		// Look for a property with the same name but different type in any interface
		foreach (var iface in interfaces)
		{
			foreach (var candidate in iface.Members)
			{
				// Skip if this is the same member
				if (candidate.DeclaringInterfaceFullName == member.DeclaringInterfaceFullName &&
				    candidate.Name == member.Name &&
				    candidate.ReturnType == member.ReturnType)
					continue;

				// Must be a property with the same name
				if (!candidate.IsProperty || candidate.Name != member.Name)
					continue;

				// Must have different return type (the property type)
				if (candidate.ReturnType == member.ReturnType)
					continue;

				// Only delegate from base to typed:
				// The member with 'object' type should delegate to the member with specific type
				// (e.g., IProperty.Value (object) delegates to IProperty<string>.Value (string))
				// If the member is already the typed version, don't delegate
				var memberType = member.ReturnType.TrimEnd('?');
				var candidateType = candidate.ReturnType.TrimEnd('?');

				// The member should be the less specific type (object) to need delegation
				// The candidate should be the more specific type (not object)
				if (memberType != "object" && memberType != "System.Object" &&
				    memberType != "global::System.Object")
				{
					// Member is already a specific type, don't delegate
					continue;
				}

				// Found a property with same name where member is object and candidate is typed
				return (candidate, candidate.DeclaringInterfaceFullName);
			}
		}

		return (null, null);
	}

	/// <summary>
	/// Finds a typed counterpart method across ALL interfaces that this base interface method should delegate to.
	/// Used for standalone stubs where we need to search across all implemented interfaces.
	/// </summary>
	/// <remarks>
	/// Only finds a delegation target when the member is the "base" version (non-generic return type
	/// or less specific parameter types) and the candidate is the "typed" version (generic return type
	/// or more specific parameter types). This ensures base interface methods delegate to typed
	/// interface methods, not the other way around.
	///
	/// Generic methods never delegate to non-generic methods and vice versa - they're fundamentally
	/// different overloads even if they have the same name.
	/// </remarks>
	private static (InterfaceMemberInfo? Target, string? TargetInterfaceFullName) FindDelegationTargetInInterfaces(
		InterfaceMemberInfo member,
		EquatableArray<InterfaceInfo> interfaces)
	{
		// Generic methods should never delegate to non-generic methods
		// (e.g., Process<T>(T) should NOT delegate to Process(string))
		if (member.IsGenericMethod)
			return (null, null);

		// Look for a method with the same name, same param count, same param names, but different types
		foreach (var iface in interfaces)
		{
			foreach (var candidate in iface.Members)
			{
				// Skip if this is the same member
				if (candidate.DeclaringInterfaceFullName == member.DeclaringInterfaceFullName &&
				    candidate.Name == member.Name &&
				    candidate.ReturnType == member.ReturnType &&
				    candidate.Parameters.Count == member.Parameters.Count)
				{
					var sameParams = true;
					var candidateParams = candidate.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();
					var memberParams = member.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();
					for (int i = 0; i < candidateParams.Length && sameParams; i++)
					{
						if (candidateParams[i].Type != memberParams[i].Type)
							sameParams = false;
					}
					if (sameParams)
						continue; // Exact same signature
				}

				// Must have the same name
				if (candidate.Name != member.Name)
					continue;

				// Skip generic method candidates - non-generic should not delegate to generic
				if (candidate.IsGenericMethod)
					continue;

				// Must have the same number of parameters
				if (candidate.Parameters.Count != member.Parameters.Count)
					continue;

				var cParams = candidate.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();
				var mParams = member.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();

				// Parameter names must match
				bool sameParamNames = true;
				for (int i = 0; i < cParams.Length; i++)
				{
					if (cParams[i].Name != mParams[i].Name)
					{
						sameParamNames = false;
						break;
					}
				}

				if (!sameParamNames)
					continue;

				// Check if signatures actually differ (parameter types or return type)
				bool signaturesMatch = member.ReturnType == candidate.ReturnType;
				if (signaturesMatch)
				{
					for (int i = 0; i < cParams.Length; i++)
					{
						if (cParams[i].Type != mParams[i].Type)
						{
							signaturesMatch = false;
							break;
						}
					}
				}

				if (signaturesMatch)
					continue;

				// Only delegate from base to typed:
				// Check if the candidate is more specific than the member
				// A type is more specific if:
				// - It's a generic type (contains '<') when the member is non-generic
				// - Or it's a more specific parameter type
				bool memberReturnIsGeneric = member.ReturnType.Contains("<");
				bool candidateReturnIsGeneric = candidate.ReturnType.Contains("<");

				if (member.ReturnType != candidate.ReturnType)
				{
					// Return types differ - only delegate if it's a valid inheritance relationship
					// (e.g., IEnumerator delegates to IEnumerator<T>)

					// If candidate returns void but member doesn't, can't delegate
					if (candidate.ReturnType == "void" && member.ReturnType != "void")
						continue;

					// If member returns void but candidate doesn't, can't delegate
					if (member.ReturnType == "void" && candidate.ReturnType != "void")
						continue;

					// If member return type is generic and candidate is not, member is more specific
					if (memberReturnIsGeneric && !candidateReturnIsGeneric)
					{
						// Member is more specific - don't delegate in this direction
						continue;
					}
				}
				else
				{
					// Return types match - check parameter types
					// Only delegate if member has less specific parameter types (object -> specific)
					bool memberIsMoreSpecific = false;
					bool bothAreSpecificButDifferent = false;

					for (int i = 0; i < mParams.Length; i++)
					{
						bool mParamIsGeneric = mParams[i].Type.Contains("<");
						bool cParamIsGeneric = cParams[i].Type.Contains("<");

						// If member param is generic and candidate is not, member is more specific
						if (mParamIsGeneric && !cParamIsGeneric)
						{
							memberIsMoreSpecific = true;
							break;
						}

						var mParamType = mParams[i].Type.TrimEnd('?');
						var cParamType = cParams[i].Type.TrimEnd('?');

						bool mIsObject = mParamType == "object" || mParamType == "System.Object" ||
						                 mParamType == "global::System.Object";
						bool cIsObject = cParamType == "object" || cParamType == "System.Object" ||
						                 cParamType == "global::System.Object";

						if (!mIsObject && cIsObject)
						{
							// Member param is specific, candidate is object - member is more specific
							memberIsMoreSpecific = true;
							break;
						}

						if (!mIsObject && !cIsObject && mParamType != cParamType)
						{
							// Both params are specific but different types (e.g., string vs int)
							// These are independent overloads, not delegation candidates
							bothAreSpecificButDifferent = true;
							break;
						}
					}

					if (memberIsMoreSpecific || bothAreSpecificButDifferent)
						continue;
				}

				// Found a method with same name, same param names, but different types
				// and the candidate is more specific - this is a valid delegation target
				return (candidate, candidate.DeclaringInterfaceFullName);
			}
		}

		return (null, null);
	}

	/// <summary>
	/// Generates a delegation implementation for a base interface property in standalone stubs.
	/// </summary>
	private static void GenerateFlatPropertyDelegationImplementation(
		System.Text.StringBuilder sb,
		InterfaceMemberInfo baseMember,
		InterfaceMemberInfo targetMember,
		string targetInterfaceFullName)
	{
		sb.AppendLine($"\t{baseMember.ReturnType} {baseMember.DeclaringInterfaceFullName}.{baseMember.Name}");
		sb.AppendLine("\t{");

		if (baseMember.HasGetter)
		{
			// Getter: return the typed property value (implicit conversion to base type)
			sb.AppendLine($"\t\tget => (({targetInterfaceFullName})this).{targetMember.Name};");
		}

		if (baseMember.HasSetter)
		{
			// Setter: cast value to typed property's type
			sb.AppendLine($"\t\tset => (({targetInterfaceFullName})this).{targetMember.Name} = ({targetMember.ReturnType})value;");
		}

		sb.AppendLine("\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates a delegation implementation for a base interface method in standalone stubs.
	/// </summary>
	private static void GenerateFlatMethodDelegationImplementation(
		System.Text.StringBuilder sb,
		InterfaceMemberInfo baseMember,
		InterfaceMemberInfo targetMember,
		string targetInterfaceFullName)
	{
		var baseParams = baseMember.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();
		var targetParams = targetMember.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();

		var paramList = string.Join(", ", baseParams.Select(p => FormatParameter(p)));
		var isVoid = baseMember.ReturnType == "void";

		sb.AppendLine($"\t{baseMember.ReturnType} {baseMember.DeclaringInterfaceFullName}.{baseMember.Name}({paramList})");
		sb.AppendLine("\t{");

		// Build the cast arguments
		var castArgs = new List<string>();
		for (int i = 0; i < baseParams.Length; i++)
		{
			var baseName = baseParams[i].Name;
			var baseType = baseParams[i].Type;
			var targetType = targetParams[i].Type;

			if (baseType == targetType)
			{
				castArgs.Add(baseName);
			}
			else
			{
				castArgs.Add($"({targetType}){baseName}");
			}
		}

		var callArgs = string.Join(", ", castArgs);

		if (isVoid)
		{
			sb.AppendLine($"\t\t(({targetInterfaceFullName})this).{targetMember.Name}({callArgs});");
		}
		else
		{
			sb.AppendLine($"\t\treturn (({targetInterfaceFullName})this).{targetMember.Name}({callArgs});");
		}

		sb.AppendLine("\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates explicit method implementation for inline stubs.
	/// </summary>
	private static void GenerateInlineStubMethodImplementation(
		System.Text.StringBuilder sb,
		string interfaceFullName,
		InterfaceMemberInfo member,
		MethodGroupInfo group,
		string stubClassName)
	{
		if (member.IsGenericMethod)
		{
			GenerateInlineStubGenericMethodImplementation(sb, interfaceFullName, member, group, stubClassName);
		}
		else
		{
			GenerateInlineStubNonGenericMethodImplementation(sb, interfaceFullName, member, group, stubClassName);
		}
	}

	private static void GenerateInlineStubNonGenericMethodImplementation(
		System.Text.StringBuilder sb,
		string interfaceFullName,
		InterfaceMemberInfo member,
		MethodGroupInfo group,
		string stubClassName)
	{
		var paramList = string.Join(", ", member.Parameters.Select(p => FormatParameter(p)));
		var inputParams = GetInputParameters(member.Parameters).ToArray();
		var outParams = member.Parameters.Where(p => IsOutputParameter(p.RefKind)).ToArray();
		var isVoid = member.ReturnType == "void";

		// Check for async types
		var isTask = member.ReturnType.StartsWith("global::System.Threading.Tasks.Task");
		var isValueTask = member.ReturnType.StartsWith("global::System.Threading.Tasks.ValueTask");
		var isAsync = isTask || isValueTask;

		// Get combined parameters (input only) for mapping
		var combinedInputParams = GetInputCombinedParameters(group.CombinedParameters).ToArray();

		// Build a lookup of this overload's parameters by name
		var memberParamsByName = inputParams.ToDictionary(p => p.Name, p => p.Name);

		// Map combined params to actual args: use member's param if present, else null
		var mappedArgs = combinedInputParams.Select(cp =>
			memberParamsByName.ContainsKey(cp.Name) ? cp.Name : "null").ToArray();
		var recordArgs = string.Join(", ", mappedArgs);
		var onCallArgs = mappedArgs.Length > 0 ? $"this, {recordArgs}" : "this";

		sb.AppendLine($"\t\t\t{member.ReturnType} {interfaceFullName}.{member.Name}({paramList})");
		sb.AppendLine("\t\t\t{");

		// Assign default values to out parameters first
		foreach (var outParam in outParams)
		{
			sb.AppendLine($"\t\t\t\t{outParam.Name} = default!;");
		}

		// Record the call with mapped arguments
		sb.AppendLine($"\t\t\t\t{group.Name}.RecordCall({recordArgs});");

		// Call OnCall if set
		if (isVoid)
		{
			sb.AppendLine($"\t\t\t\tif ({group.Name}.OnCall is {{ }} onCall) onCall({onCallArgs});");
		}
		else if (isAsync)
		{
			sb.AppendLine($"\t\t\t\tif ({group.Name}.OnCall is {{ }} onCall) return onCall({onCallArgs});");
			// Return completed task for async methods
			if (isTask && member.ReturnType == "global::System.Threading.Tasks.Task")
			{
				sb.AppendLine("\t\t\t\treturn global::System.Threading.Tasks.Task.CompletedTask;");
			}
			else if (isValueTask && member.ReturnType == "global::System.Threading.Tasks.ValueTask")
			{
				sb.AppendLine("\t\t\t\treturn default;");
			}
			else if (member.DefaultStrategy == DefaultValueStrategy.ThrowException)
			{
				// Task<T>/ValueTask<T> where T is non-nullable and non-instantiable
				sb.AppendLine($"\t\t\t\tthrow new global::System.InvalidOperationException(\"No implementation provided for {member.Name}. Set {group.Name}.OnCall.\");");
			}
			else
			{
				// Task<T> or ValueTask<T> - use strategy to determine value
				var defaultExpr = GetDefaultForType(member.ReturnType, member.DefaultStrategy, member.ConcreteTypeForNew);
				sb.AppendLine($"\t\t\t\treturn {defaultExpr};");
			}
		}
		else if (member.DefaultStrategy == DefaultValueStrategy.ThrowException)
		{
			sb.AppendLine($"\t\t\t\tif ({group.Name}.OnCall is {{ }} onCall) return onCall({onCallArgs});");
			sb.AppendLine($"\t\t\t\tthrow new global::System.InvalidOperationException(\"No implementation provided for {member.Name}. Set {group.Name}.OnCall.\");");
		}
		else
		{
			sb.AppendLine($"\t\t\t\tif ({group.Name}.OnCall is {{ }} onCall) return onCall({onCallArgs});");
			var defaultExpr = GetDefaultForType(member.ReturnType, member.DefaultStrategy, member.ConcreteTypeForNew);
			sb.AppendLine($"\t\t\t\treturn {defaultExpr};");
		}

		sb.AppendLine("\t\t\t}");
		sb.AppendLine();
	}

	private static void GenerateInlineStubGenericMethodImplementation(
		System.Text.StringBuilder sb,
		string interfaceFullName,
		InterfaceMemberInfo member,
		MethodGroupInfo group,
		string stubClassName)
	{
		var typeParams = member.TypeParameters.GetArray()!;
		var typeParamNames = string.Join(", ", typeParams.Select(tp => tp.Name));

		// For explicit interface implementations, only class/struct constraints are allowed (CS0460)
		// Pass return type to determine if class constraint is needed for nullable returns
		var constraintClauses = GetConstraintsForExplicitImpl(typeParams, member.ReturnType);

		var paramList = string.Join(", ", member.Parameters.Select(p => FormatParameter(p)));
		var argList = string.Join(", ", member.Parameters.Select(p => FormatArgument(p)));
		var paramCount = member.Parameters.Count;

		// Get non-generic parameters for RecordCall
		var typeParamSet = new HashSet<string>(typeParams.Select(tp => tp.Name));
		var nonGenericParams = member.Parameters
			.Where(p => !IsGenericParameterType(p.Type, typeParamSet))
			.ToArray();
		var nonGenericArgList = string.Join(", ", nonGenericParams.Select(p => p.Name));

		var isVoid = member.ReturnType == "void";
		var isTask = member.ReturnType == "global::System.Threading.Tasks.Task";
		var isValueTask = member.ReturnType == "global::System.Threading.Tasks.ValueTask";

		// Generate method signature with type parameters (only class/struct constraints allowed in explicit impl)
		sb.AppendLine($"\t\t\t{member.ReturnType} {interfaceFullName}.{member.Name}<{typeParamNames}>({paramList}){constraintClauses}");
		sb.AppendLine("\t\t\t{");

		// Get the typed handler via Of<T>()
		sb.AppendLine($"\t\t\t\tvar typedHandler = {group.Name}.Of<{typeParamNames}>();");

		// Record the call
		if (nonGenericParams.Length > 0)
		{
			sb.AppendLine($"\t\t\t\ttypedHandler.RecordCall({nonGenericArgList});");
		}
		else
		{
			sb.AppendLine($"\t\t\t\ttypedHandler.RecordCall();");
		}

		// Check for OnCall callback
		sb.AppendLine($"\t\t\t\tif (typedHandler.OnCall is {{ }} onCallCallback)");
		if (isVoid)
		{
			// Void methods - call callback and return without value
			if (paramCount == 0)
			{
				sb.AppendLine($"\t\t\t\t{{ onCallCallback(this); return; }}");
			}
			else
			{
				sb.AppendLine($"\t\t\t\t{{ onCallCallback(this, {argList}); return; }}");
			}
		}
		else if (isTask || isValueTask)
		{
			// Task/ValueTask methods - return the callback result
			if (paramCount == 0)
			{
				sb.AppendLine($"\t\t\t\t{{ return onCallCallback(this); }}");
			}
			else
			{
				sb.AppendLine($"\t\t\t\t{{ return onCallCallback(this, {argList}); }}");
			}
		}
		else
		{
			if (paramCount == 0)
			{
				sb.AppendLine($"\t\t\t\t\treturn onCallCallback(this);");
			}
			else
			{
				sb.AppendLine($"\t\t\t\t\treturn onCallCallback(this, {argList});");
			}
		}

		// Default behavior
		if (isVoid)
		{
			// void - no return needed
		}
		else if (isTask)
		{
			sb.AppendLine($"\t\t\t\treturn global::System.Threading.Tasks.Task.CompletedTask;");
		}
		else if (isValueTask)
		{
			sb.AppendLine($"\t\t\t\treturn default;");
		}
		else if (member.IsNullable)
		{
			sb.AppendLine($"\t\t\t\treturn default!;");
		}
		else
		{
			// Non-nullable return - use SmartDefault helper for runtime evaluation
			sb.AppendLine($"\t\t\t\treturn SmartDefault<{member.ReturnType}>(\"{member.Name}\");");
		}

		sb.AppendLine("\t\t\t}");
		sb.AppendLine();
	}

	/// <summary>
	/// Generates explicit event implementation for inline stubs.
	/// </summary>
	private static void GenerateInlineStubEventImplementation(
		System.Text.StringBuilder sb,
		string interfaceFullName,
		EventMemberInfo evt,
		string stubClassName)
	{
		// Strip trailing ? from delegate type since we add our own nullable marker
		var delegateType = evt.FullDelegateTypeName.TrimEnd('?');
		sb.AppendLine($"\t\t\tevent {delegateType}? {interfaceFullName}.{evt.Name}");
		sb.AppendLine("\t\t\t{");
		sb.AppendLine($"\t\t\t\tadd => {evt.Name}Interceptor.RecordAdd(value);");
		sb.AppendLine($"\t\t\t\tremove => {evt.Name}Interceptor.RecordRemove(value);");
		sb.AppendLine("\t\t\t}");
		sb.AppendLine();
	}

	#endregion
}
