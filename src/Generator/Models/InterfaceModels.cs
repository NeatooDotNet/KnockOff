// <auto-generated/> - Extracted from KnockOffGenerator.cs
#nullable enable
using System.Linq;
using Microsoft.CodeAnalysis;

namespace KnockOff;

internal sealed record InterfaceInfo(
	string FullName,
	string Name,
	string SimpleName,
	EquatableArray<InterfaceMemberInfo> Members,
	EquatableArray<EventMemberInfo> Events) : IEquatable<InterfaceInfo>;

internal sealed record InterfaceMemberInfo(
	string Name,
	string ReturnType,
	bool IsProperty,
	bool IsIndexer,
	bool HasGetter,
	bool HasSetter,
	bool IsNullable,
	DefaultValueStrategy DefaultStrategy,
	string? ConcreteTypeForNew,
	EquatableArray<ParameterInfo> Parameters,
	EquatableArray<ParameterInfo> IndexerParameters,
	bool IsGenericMethod,
	EquatableArray<TypeParameterInfo> TypeParameters,
	string DeclaringInterfaceFullName,
	/// <summary>
	/// For properties with asymmetric nullability (e.g., getter returns string?, setter takes string),
	/// this captures the setter's parameter type. Null when setter type matches ReturnType.
	/// </summary>
	string? SetterParameterType = null,
	/// <summary>
	/// True if the setter has [DisallowNull] attribute on its value parameter.
	/// When true, the generated setter should include [param: DisallowNull].
	/// </summary>
	bool SetterHasDisallowNull = false,
	/// <summary>
	/// True if the setter has [AllowNull] attribute on its value parameter.
	/// When true, the generated setter should include [param: AllowNull].
	/// </summary>
	bool SetterHasAllowNull = false) : IEquatable<InterfaceMemberInfo>
{
	/// <summary>
	/// Creates an InterfaceMemberInfo from a property symbol.
	/// </summary>
	public static InterfaceMemberInfo FromProperty(IPropertySymbol property, string declaringInterfaceFullName)
	{
		var returnType = property.Type.ToDisplayString(SymbolHelpers.FullyQualifiedWithNullability);
		var isNullable = property.Type.NullableAnnotation == NullableAnnotation.Annotated
			|| property.Type.IsReferenceType && property.Type.NullableAnnotation != NullableAnnotation.NotAnnotated;
		var (defaultStrategy, concreteType) = SymbolHelpers.GetDefaultValueStrategyWithConcreteType(property.Type);

		// Handle indexers
		var isIndexer = property.IsIndexer;
		var indexerParameters = EquatableArray<ParameterInfo>.Empty;
		var name = property.Name;

		if (isIndexer)
		{
			// For indexers, create a name based on parameter types for uniqueness
			var paramTypes = property.Parameters
				.Select(p => SymbolHelpers.GetSimpleTypeName(p.Type))
				.ToArray();
			name = string.Join("", paramTypes) + "Indexer";

			indexerParameters = new EquatableArray<ParameterInfo>(
				property.Parameters
					.Select(p => new ParameterInfo(p.Name, p.Type.ToDisplayString(SymbolHelpers.FullyQualifiedWithNullability), p.RefKind))
					.ToArray());
		}

		// Check for asymmetric nullability
		string? setterParameterType = null;
		bool setterHasDisallowNull = false;
		bool setterHasAllowNull = false;
		if (property.SetMethod is { } setMethod && setMethod.Parameters.Length > 0)
		{
			var setterParam = setMethod.Parameters[0];
			var setterParamType = setterParam.Type;
			var setterType = setterParamType.ToDisplayString(SymbolHelpers.FullyQualifiedWithNullability);
			if (setterType != returnType)
			{
				setterParameterType = setterType;
			}

			// Check for nullability attributes on setter parameter
			foreach (var attr in setterParam.GetAttributes())
			{
				var attrName = attr.AttributeClass?.Name;
				if (attrName == "DisallowNullAttribute")
					setterHasDisallowNull = true;
				else if (attrName == "AllowNullAttribute")
					setterHasAllowNull = true;
			}
		}

		return new InterfaceMemberInfo(
			Name: name,
			ReturnType: returnType,
			IsProperty: true,
			IsIndexer: isIndexer,
			HasGetter: property.GetMethod is not null,
			HasSetter: property.SetMethod is not null,
			IsNullable: isNullable,
			DefaultStrategy: defaultStrategy,
			ConcreteTypeForNew: concreteType,
			Parameters: EquatableArray<ParameterInfo>.Empty,
			IndexerParameters: indexerParameters,
			IsGenericMethod: false,
			TypeParameters: EquatableArray<TypeParameterInfo>.Empty,
			DeclaringInterfaceFullName: declaringInterfaceFullName,
			SetterParameterType: setterParameterType,
			SetterHasDisallowNull: setterHasDisallowNull,
			SetterHasAllowNull: setterHasAllowNull);
	}

	/// <summary>
	/// Creates an InterfaceMemberInfo from a method symbol.
	/// </summary>
	public static InterfaceMemberInfo FromMethod(IMethodSymbol method, string declaringInterfaceFullName)
	{
		var returnType = method.ReturnType.ToDisplayString(SymbolHelpers.FullyQualifiedWithNullability);
		var isNullable = method.ReturnType.NullableAnnotation == NullableAnnotation.Annotated
			|| (method.ReturnType.IsReferenceType && method.ReturnType.NullableAnnotation != NullableAnnotation.NotAnnotated);
		var defaultStrategy = DefaultValueStrategy.Default;
		string? concreteType = null;

		// For void methods, they're not "nullable" in the sense that matters
		if (method.ReturnsVoid)
			isNullable = true;

		// For Task and ValueTask (non-generic), treat as void-like
		var typeFullName = method.ReturnType.OriginalDefinition.ToDisplayString();
		if (typeFullName == "System.Threading.Tasks.Task" || typeFullName == "System.Threading.Tasks.ValueTask")
			isNullable = true;

		// For Task<T> and ValueTask<T>, check the inner type
		if (method.ReturnType is INamedTypeSymbol namedType && namedType.IsGenericType)
		{
			var containingNs = namedType.ContainingNamespace?.ToDisplayString() ?? "";
			var typeName = namedType.Name;
			if (containingNs == "System.Threading.Tasks" && (typeName == "Task" || typeName == "ValueTask"))
			{
				var innerType = namedType.TypeArguments[0];
				isNullable = innerType.NullableAnnotation == NullableAnnotation.Annotated
					|| (innerType.IsReferenceType && innerType.NullableAnnotation != NullableAnnotation.NotAnnotated);
				(defaultStrategy, concreteType) = SymbolHelpers.GetDefaultValueStrategyWithConcreteType(innerType);
			}
			else
			{
				(defaultStrategy, concreteType) = SymbolHelpers.GetDefaultValueStrategyWithConcreteType(method.ReturnType);
			}
		}
		else if (!method.ReturnsVoid &&
			typeFullName != "System.Threading.Tasks.Task" &&
			typeFullName != "System.Threading.Tasks.ValueTask")
		{
			(defaultStrategy, concreteType) = SymbolHelpers.GetDefaultValueStrategyWithConcreteType(method.ReturnType);
		}

		var parameters = method.Parameters
			.Select(p => new ParameterInfo(p.Name, p.Type.ToDisplayString(SymbolHelpers.FullyQualifiedWithNullability), p.RefKind))
			.ToArray();

		// Extract type parameters for generic methods
		var isGenericMethod = method.IsGenericMethod;
		var typeParameters = EquatableArray<TypeParameterInfo>.Empty;

		if (isGenericMethod)
		{
			typeParameters = new EquatableArray<TypeParameterInfo>(
				method.TypeParameters
					.Select(tp => new TypeParameterInfo(
						tp.Name,
						new EquatableArray<string>(SymbolHelpers.GetTypeParameterConstraints(tp).ToArray())))
					.ToArray());
		}

		return new InterfaceMemberInfo(
			Name: method.Name,
			ReturnType: returnType,
			IsProperty: false,
			IsIndexer: false,
			HasGetter: false,
			HasSetter: false,
			IsNullable: isNullable,
			DefaultStrategy: defaultStrategy,
			ConcreteTypeForNew: concreteType,
			Parameters: new EquatableArray<ParameterInfo>(parameters),
			IndexerParameters: EquatableArray<ParameterInfo>.Empty,
			IsGenericMethod: isGenericMethod,
			TypeParameters: typeParameters,
			DeclaringInterfaceFullName: declaringInterfaceFullName);
	}
}

internal sealed record ParameterInfo(
	string Name,
	string Type,
	RefKind RefKind) : IEquatable<ParameterInfo>;

/// <summary>
/// Represents a type parameter for generic methods (e.g., T in Method&lt;T&gt;).
/// </summary>
internal sealed record TypeParameterInfo(
	string Name,
	EquatableArray<string> Constraints) : IEquatable<TypeParameterInfo>;
