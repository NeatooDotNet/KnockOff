// <auto-generated/> - Extracted from KnockOffGenerator.cs
#nullable enable
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace KnockOff;

/// <summary>
/// Info about a class type for generating class stubs via inheritance.
/// </summary>
internal sealed record ClassStubInfo(
	string FullName,
	string Name,
	EquatableArray<ClassMemberInfo> Members,
	EquatableArray<ClassConstructorInfo> Constructors,
	EquatableArray<EventMemberInfo> Events) : IEquatable<ClassStubInfo>;

/// <summary>
/// Info about a virtual/abstract member of a class for stubbing.
/// Reuses InterfaceMemberInfo structure but tracks whether member is abstract.
/// </summary>
internal sealed record ClassMemberInfo(
	string Name,
	string ReturnType,
	bool IsProperty,
	bool IsIndexer,
	bool HasGetter,
	bool HasSetter,
	bool IsNullable,
	DefaultValueStrategy DefaultStrategy,
	string? ConcreteTypeForNew,
	EquatableArray<ParameterInfo> Parameters,
	EquatableArray<ParameterInfo> IndexerParameters,
	bool IsGenericMethod,
	EquatableArray<TypeParameterInfo> TypeParameters,
	bool IsAbstract,
	string AccessModifier,
	/// <summary>
	/// For indexers, the type suffix to append when multiple indexers exist.
	/// E.g., "String" for this[string key], "Int32" for this[int index].
	/// Used to generate names like "IndexerString" or "IndexerInt32" when needed.
	/// </summary>
	string? IndexerTypeSuffix = null,
	/// <summary>
	/// True if the property setter is init-only (C# 9 init accessor).
	/// When true, the generated setter uses 'init' instead of 'set'.
	/// </summary>
	bool IsInitOnly = false,
	/// <summary>
	/// True if the property has the 'required' modifier (C# 11).
	/// When true, the generated override must also be required.
	/// </summary>
	bool IsRequired = false) : IEquatable<ClassMemberInfo>
{
	/// <summary>
	/// Creates ClassMemberInfo for a property (including indexers).
	/// </summary>
	public static ClassMemberInfo FromProperty(IPropertySymbol property)
	{
		var returnType = property.Type.ToDisplayString(SymbolHelpers.FullyQualifiedWithNullability);
		var isNullable = property.Type.NullableAnnotation == NullableAnnotation.Annotated
			|| (property.Type.IsReferenceType && property.Type.NullableAnnotation != NullableAnnotation.NotAnnotated);
		var (defaultStrategy, concreteType) = SymbolHelpers.GetDefaultValueStrategyWithConcreteType(property.Type);

		// Handle indexers
		var isIndexer = property.IsIndexer;
		var indexerParameters = EquatableArray<ParameterInfo>.Empty;
		var name = property.Name;
		string? indexerTypeSuffix = null;

		if (isIndexer)
		{
			// For indexers, use "Indexer" as base name with type suffix for disambiguation
			// Single indexer: "Indexer"
			// Multiple indexers: "IndexerString", "IndexerInt32", etc.
			name = "Indexer";
			var paramTypes = property.Parameters
				.Select(p => SymbolHelpers.GetSimpleTypeName(p.Type))
				.ToArray();
			indexerTypeSuffix = string.Join("", paramTypes);

			indexerParameters = new EquatableArray<ParameterInfo>(
				property.Parameters
					.Select(p => new ParameterInfo(p.Name, p.Type.ToDisplayString(SymbolHelpers.FullyQualifiedWithNullability), p.RefKind))
					.ToArray());
		}

		var accessModifier = property.DeclaredAccessibility switch
		{
			Accessibility.Public => "public",
			Accessibility.Protected => "protected",
			Accessibility.ProtectedOrInternal => "protected internal",
			Accessibility.Internal => "internal",
			_ => "protected"
		};

		var isInitOnly = property.SetMethod?.IsInitOnly ?? false;
		var isRequired = property.IsRequired;

		return new ClassMemberInfo(
			Name: name,
			ReturnType: returnType,
			IsProperty: true,
			IsIndexer: isIndexer,
			HasGetter: property.GetMethod is not null,
			HasSetter: property.SetMethod is not null,
			IsNullable: isNullable,
			DefaultStrategy: defaultStrategy,
			ConcreteTypeForNew: concreteType,
			Parameters: EquatableArray<ParameterInfo>.Empty,
			IndexerParameters: indexerParameters,
			IsGenericMethod: false,
			TypeParameters: EquatableArray<TypeParameterInfo>.Empty,
			IsAbstract: property.IsAbstract,
			AccessModifier: accessModifier,
			IndexerTypeSuffix: indexerTypeSuffix,
			IsInitOnly: isInitOnly,
			IsRequired: isRequired);
	}

	/// <summary>
	/// Creates ClassMemberInfo for a method.
	/// </summary>
	public static ClassMemberInfo FromMethod(IMethodSymbol method)
	{
		var returnType = method.ReturnType.ToDisplayString(SymbolHelpers.FullyQualifiedWithNullability);
		var isNullable = method.ReturnType.NullableAnnotation == NullableAnnotation.Annotated
			|| (method.ReturnType.IsReferenceType && method.ReturnType.NullableAnnotation != NullableAnnotation.NotAnnotated);
		var defaultStrategy = DefaultValueStrategy.Default;
		string? concreteType = null;

		if (method.ReturnsVoid)
			isNullable = true;

		var typeFullName = method.ReturnType.OriginalDefinition.ToDisplayString();
		if (typeFullName == "System.Threading.Tasks.Task" || typeFullName == "System.Threading.Tasks.ValueTask")
			isNullable = true;

		if (method.ReturnType is INamedTypeSymbol namedType && namedType.IsGenericType)
		{
			var origDef = namedType.OriginalDefinition.ToDisplayString();
			if (origDef == "System.Threading.Tasks.Task<TResult>" || origDef == "System.Threading.Tasks.ValueTask<TResult>")
			{
				var innerType = namedType.TypeArguments[0];
				isNullable = innerType.NullableAnnotation == NullableAnnotation.Annotated
					|| (innerType.IsReferenceType && innerType.NullableAnnotation != NullableAnnotation.NotAnnotated)
					|| innerType.IsValueType;
				(defaultStrategy, concreteType) = SymbolHelpers.GetDefaultValueStrategyWithConcreteType(innerType);
			}
		}

		if (!method.ReturnsVoid && typeFullName != "System.Threading.Tasks.Task" && typeFullName != "System.Threading.Tasks.ValueTask")
		{
			(defaultStrategy, concreteType) = SymbolHelpers.GetDefaultValueStrategyWithConcreteType(method.ReturnType);
		}

		var parameters = method.Parameters
			.Select(p => new ParameterInfo(p.Name, p.Type.ToDisplayString(SymbolHelpers.FullyQualifiedWithNullability), p.RefKind))
			.ToArray();

		var typeParameters = EquatableArray<TypeParameterInfo>.Empty;
		if (method.IsGenericMethod)
		{
			typeParameters = new EquatableArray<TypeParameterInfo>(
				method.TypeParameters
					.Select(tp => new TypeParameterInfo(
						tp.Name,
						new EquatableArray<string>(SymbolHelpers.GetTypeParameterConstraints(tp).ToArray())))
					.ToArray());
		}

		var accessModifier = method.DeclaredAccessibility switch
		{
			Accessibility.Public => "public",
			Accessibility.Protected => "protected",
			Accessibility.ProtectedOrInternal => "protected internal",
			Accessibility.Internal => "internal",
			_ => "protected"
		};

		return new ClassMemberInfo(
			Name: method.Name,
			ReturnType: returnType,
			IsProperty: false,
			IsIndexer: false,
			HasGetter: false,
			HasSetter: false,
			IsNullable: isNullable,
			DefaultStrategy: defaultStrategy,
			ConcreteTypeForNew: concreteType,
			Parameters: new EquatableArray<ParameterInfo>(parameters),
			IndexerParameters: EquatableArray<ParameterInfo>.Empty,
			IsGenericMethod: method.IsGenericMethod,
			TypeParameters: typeParameters,
			IsAbstract: method.IsAbstract,
			AccessModifier: accessModifier);
	}
}

/// <summary>
/// Info about an accessible constructor of a class.
/// </summary>
internal sealed record ClassConstructorInfo(
	EquatableArray<ParameterInfo> Parameters,
	string AccessModifier) : IEquatable<ClassConstructorInfo>;

/// <summary>
/// Groups class methods by name for overload handling.
/// This is a mutable intermediate type used during generation.
/// </summary>
internal sealed class ClassMethodGroupInfo
{
	public string Name { get; }
	public string ReturnType { get; }
	public bool IsVoid { get; }
	public bool IsNullable { get; }
	public EquatableArray<ClassMemberInfo> Members { get; }

	// Constructor for initial creation with List
	public ClassMethodGroupInfo(string name, string returnType, bool isVoid, bool isNullable, IReadOnlyCollection<ClassMemberInfo> members)
	{
		Name = name;
		ReturnType = returnType;
		IsVoid = isVoid;
		IsNullable = isNullable;
		Members = members is List<ClassMemberInfo> list
			? new EquatableArray<ClassMemberInfo>(list.ToArray())
			: new EquatableArray<ClassMemberInfo>(members.ToArray());
	}
}
