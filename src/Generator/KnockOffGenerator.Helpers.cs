// <auto-generated/> - Partial class extracted from KnockOffGenerator.cs
#nullable enable
using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;

namespace KnockOff;

public partial class KnockOffGenerator
{
	/// <summary>
	/// Find user-defined protected methods that match interface method signatures
	/// </summary>
	private static EquatableArray<UserMethodInfo> GetUserDefinedMethods(
		INamedTypeSymbol classSymbol,
		List<InterfaceInfo> interfaces)
	{
		var userMethods = new List<UserMethodInfo>();

		// Get all methods declared directly on this class (not inherited)
		var classMethods = classSymbol.GetMembers()
			.OfType<IMethodSymbol>()
			.Where(m => m.MethodKind == MethodKind.Ordinary
				&& m.DeclaredAccessibility == Accessibility.Protected
				&& !m.IsStatic)
			.ToList();

		// Build a set of interface method signatures to match against
		var interfaceMethodSignatures = new HashSet<string>();
		foreach (var iface in interfaces)
		{
			foreach (var member in iface.Members)
			{
				if (!member.IsProperty)
				{
					var sig = GetMethodSignature(member.Name, member.ReturnType, member.Parameters, member.IsGenericMethod, member.TypeParameters);
					interfaceMethodSignatures.Add(sig);
				}
			}
		}

		// Find matching user methods
		foreach (var method in classMethods)
		{
			var returnType = method.ReturnType.ToDisplayString(FullyQualifiedWithNullability);
			var parameters = method.Parameters
				.Select(p => new ParameterInfo(p.Name, p.Type.ToDisplayString(FullyQualifiedWithNullability), p.RefKind))
				.ToArray();

			// Extract type parameters for generic methods
			var isGenericMethod = method.IsGenericMethod;
			var typeParameters = EquatableArray<TypeParameterInfo>.Empty;
			if (isGenericMethod)
			{
				typeParameters = new EquatableArray<TypeParameterInfo>(
					method.TypeParameters
						.Select(tp => new TypeParameterInfo(
							tp.Name,
							new EquatableArray<string>(SymbolHelpers.GetTypeParameterConstraints(tp).ToArray())))
						.ToArray());
			}

			var sig = GetMethodSignature(method.Name, returnType, new EquatableArray<ParameterInfo>(parameters), isGenericMethod, typeParameters);

			if (interfaceMethodSignatures.Contains(sig))
			{
				userMethods.Add(new UserMethodInfo(
					Name: method.Name,
					ReturnType: returnType,
					Parameters: new EquatableArray<ParameterInfo>(parameters),
					IsGenericMethod: isGenericMethod,
					TypeParameters: typeParameters));
			}
		}

		return new EquatableArray<UserMethodInfo>(userMethods.ToArray());
	}

	private static string GetMethodSignature(string name, string returnType, EquatableArray<ParameterInfo> parameters, bool isGenericMethod, EquatableArray<TypeParameterInfo> typeParameters)
	{
		var paramTypes = string.Join(",", parameters.Select(p => p.Type));
		// Include type parameter count to distinguish generic from non-generic overloads
		// Also include type parameter names since they affect return type and parameter types (e.g., T vs TResult)
		var typeParamSuffix = isGenericMethod
			? $"<{string.Join(",", typeParameters.Select(tp => tp.Name))}>"
			: "";
		return $"{returnType} {name}{typeParamSuffix}({paramTypes})";
	}
}
