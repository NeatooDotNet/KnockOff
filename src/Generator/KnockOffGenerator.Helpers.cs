// <auto-generated/> - Partial class extracted from KnockOffGenerator.cs
#nullable enable
using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;

namespace KnockOff;

public partial class KnockOffGenerator
{
	/// <summary>
	/// Gets the keyword prefix for a ref kind (out, ref, in, ref readonly).
	/// </summary>
	private static string GetRefKindPrefix(RefKind kind) => kind switch
	{
		RefKind.Out => "out ",
		RefKind.Ref => "ref ",
		RefKind.In => "in ",
		RefKind.RefReadOnlyParameter => "ref readonly ",
		_ => ""
	};

	/// <summary>
	/// Formats a parameter for use in a method signature (e.g., "out string value").
	/// </summary>
	private static string FormatParameter(ParameterInfo p) =>
		$"{GetRefKindPrefix(p.RefKind)}{p.Type} {p.Name}";

	/// <summary>
	/// Formats a parameter for use in a method call/argument (e.g., "out value").
	/// </summary>
	private static string FormatArgument(ParameterInfo p) =>
		$"{GetRefKindPrefix(p.RefKind)}{p.Name}";

	/// <summary>
	/// Returns true if the parameter is an output-only parameter (out, not ref).
	/// Out parameters are outputs from the method, not inputs to track.
	/// </summary>
	private static bool IsOutputParameter(RefKind refKind) =>
		refKind == RefKind.Out;

	/// <summary>
	/// Filters parameters to only include input parameters (excludes out params).
	/// </summary>
	private static IEnumerable<ParameterInfo> GetInputParameters(EquatableArray<ParameterInfo> parameters) =>
		parameters.Where(p => !IsOutputParameter(p.RefKind));

	/// <summary>
	/// Filters combined parameters to only include input parameters (excludes out params).
	/// </summary>
	private static IEnumerable<CombinedParameterInfo> GetInputCombinedParameters(EquatableArray<CombinedParameterInfo> parameters) =>
		parameters.Where(p => !IsOutputParameter(p.RefKind));

	/// <summary>
	/// Formats a parameter for RecordCall (stores value, no ref/out keywords).
	/// </summary>
	private static string FormatRecordCallParameter(ParameterInfo p) =>
		$"{p.Type} {p.Name}";

	/// <summary>
	/// Find user-defined protected methods that match interface method signatures
	/// </summary>
	private static EquatableArray<UserMethodInfo> GetUserDefinedMethods(
		INamedTypeSymbol classSymbol,
		List<InterfaceInfo> interfaces)
	{
		var userMethods = new List<UserMethodInfo>();

		// Get all methods declared directly on this class (not inherited)
		var classMethods = classSymbol.GetMembers()
			.OfType<IMethodSymbol>()
			.Where(m => m.MethodKind == MethodKind.Ordinary
				&& m.DeclaredAccessibility == Accessibility.Protected
				&& !m.IsStatic)
			.ToList();

		// Build a set of interface method signatures to match against
		var interfaceMethodSignatures = new HashSet<string>();
		foreach (var iface in interfaces)
		{
			foreach (var member in iface.Members)
			{
				if (!member.IsProperty)
				{
					var sig = GetMethodSignature(member.Name, member.ReturnType, member.Parameters, member.IsGenericMethod, member.TypeParameters);
					interfaceMethodSignatures.Add(sig);
				}
			}
		}

		// Find matching user methods
		foreach (var method in classMethods)
		{
			var returnType = method.ReturnType.ToDisplayString(FullyQualifiedWithNullability);
			var parameters = method.Parameters
				.Select(p => new ParameterInfo(p.Name, p.Type.ToDisplayString(FullyQualifiedWithNullability), p.RefKind))
				.ToArray();

			// Extract type parameters for generic methods
			var isGenericMethod = method.IsGenericMethod;
			var typeParameters = EquatableArray<TypeParameterInfo>.Empty;
			if (isGenericMethod)
			{
				typeParameters = new EquatableArray<TypeParameterInfo>(
					method.TypeParameters
						.Select(tp => new TypeParameterInfo(
							tp.Name,
							new EquatableArray<string>(SymbolHelpers.GetTypeParameterConstraints(tp).ToArray())))
						.ToArray());
			}

			var sig = GetMethodSignature(method.Name, returnType, new EquatableArray<ParameterInfo>(parameters), isGenericMethod, typeParameters);

			if (interfaceMethodSignatures.Contains(sig))
			{
				userMethods.Add(new UserMethodInfo(
					Name: method.Name,
					ReturnType: returnType,
					Parameters: new EquatableArray<ParameterInfo>(parameters),
					IsGenericMethod: isGenericMethod,
					TypeParameters: typeParameters));
			}
		}

		return new EquatableArray<UserMethodInfo>(userMethods.ToArray());
	}

	private static string GetMethodSignature(string name, string returnType, EquatableArray<ParameterInfo> parameters, bool isGenericMethod, EquatableArray<TypeParameterInfo> typeParameters)
	{
		var paramTypes = string.Join(",", parameters.Select(p => p.Type));
		// Include type parameter count to distinguish generic from non-generic overloads
		// Also include type parameter names since they affect return type and parameter types (e.g., T vs TResult)
		var typeParamSuffix = isGenericMethod
			? $"<{string.Join(",", typeParameters.Select(tp => tp.Name))}>"
			: "";
		return $"{returnType} {name}{typeParamSuffix}({paramTypes})";
	}

	/// <summary>
	/// Groups methods by name to handle overloads, creating combined parameter tuples
	/// </summary>
	private static Dictionary<string, MethodGroupInfo> GroupMethodsByName(IEnumerable<InterfaceMemberInfo> methods)
	{
		var groups = new Dictionary<string, List<InterfaceMemberInfo>>();

		foreach (var method in methods.Where(m => !m.IsProperty))
		{
			if (!groups.TryGetValue(method.Name, out var list))
			{
				list = new List<InterfaceMemberInfo>();
				groups[method.Name] = list;
			}
			list.Add(method);
		}

		var result = new Dictionary<string, MethodGroupInfo>();

		foreach (var kvp in groups)
		{
			var methodName = kvp.Key;
			var overloads = kvp.Value;
			var first = overloads[0];

			// Build combined parameters: union of all params across overloads
			// Params not in all overloads become nullable
			var allParamNames = new Dictionary<string, (string Type, int Count, RefKind RefKind)>();
			var totalOverloads = overloads.Count;

			foreach (var overload in overloads)
			{
				foreach (var param in overload.Parameters)
				{
					if (allParamNames.TryGetValue(param.Name, out var existing))
					{
						// Same name exists - increment count (param appears in multiple overloads)
						allParamNames[param.Name] = (existing.Type, existing.Count + 1, existing.RefKind);
					}
					else
					{
						allParamNames[param.Name] = (param.Type, 1, param.RefKind);
					}
				}
			}

			// Create combined parameters
			var combinedParams = new List<CombinedParameterInfo>();
			foreach (var kvp2 in allParamNames)
			{
				var paramName = kvp2.Key;
				var paramType = kvp2.Value.Type;
				var count = kvp2.Value.Count;
				var refKind = kvp2.Value.RefKind;
				var isNullable = count < totalOverloads; // Not in all overloads = nullable
				var nullableType = isNullable ? MakeNullable(paramType) : paramType;

				combinedParams.Add(new CombinedParameterInfo(paramName, paramType, nullableType, isNullable, refKind));
			}

			// Create overload infos
			var overloadInfos = overloads
				.Select(o => new MethodOverloadInfo(o.Parameters, o.IsGenericMethod, o.TypeParameters))
				.ToArray();

			result[methodName] = new MethodGroupInfo(
				Name: methodName,
				ReturnType: first.ReturnType,
				IsVoid: first.ReturnType == "void",
				IsNullable: first.IsNullable,
				Overloads: new EquatableArray<MethodOverloadInfo>(overloadInfos),
				CombinedParameters: new EquatableArray<CombinedParameterInfo>(combinedParams.ToArray()));
		}

		return result;
	}

	/// <summary>
	/// Suffix added to generic interceptor property names when a method group has both generic and non-generic overloads.
	/// </summary>
	private const string GenericSuffix = "Generic";

	/// <summary>
	/// Determines if a method group has both generic and non-generic overloads (a "mixed" group).
	/// Mixed groups require two separate interceptor classes and properties.
	/// </summary>
	private static bool IsMixedMethodGroup(MethodGroupInfo group)
	{
		var overloads = group.Overloads.GetArray() ?? Array.Empty<MethodOverloadInfo>();
		var hasGeneric = overloads.Any(o => o.IsGenericMethod);
		var hasNonGeneric = overloads.Any(o => !o.IsGenericMethod);
		return hasGeneric && hasNonGeneric;
	}

	/// <summary>
	/// Splits a mixed method group into separate non-generic and generic sub-groups.
	/// Returns (nonGenericGroup, genericGroup) where either may be null if the group isn't mixed.
	/// </summary>
	private static (MethodGroupInfo? NonGeneric, MethodGroupInfo? Generic) SplitMixedGroup(MethodGroupInfo group)
	{
		var overloads = group.Overloads.GetArray() ?? Array.Empty<MethodOverloadInfo>();
		var nonGenericOverloads = overloads.Where(o => !o.IsGenericMethod).ToArray();
		var genericOverloads = overloads.Where(o => o.IsGenericMethod).ToArray();

		if (nonGenericOverloads.Length == 0 || genericOverloads.Length == 0)
			return (null, null);

		// Build combined parameters for non-generic overloads only
		var nonGenericCombinedParams = BuildCombinedParametersForOverloads(nonGenericOverloads);

		var nonGenericGroup = new MethodGroupInfo(
			Name: group.Name,
			ReturnType: group.ReturnType,
			IsVoid: group.IsVoid,
			IsNullable: group.IsNullable,
			Overloads: new EquatableArray<MethodOverloadInfo>(nonGenericOverloads),
			CombinedParameters: new EquatableArray<CombinedParameterInfo>(nonGenericCombinedParams));

		// Build combined parameters for generic overloads only
		var genericCombinedParams = BuildCombinedParametersForOverloads(genericOverloads);

		var genericGroup = new MethodGroupInfo(
			Name: group.Name + GenericSuffix,
			ReturnType: group.ReturnType,
			IsVoid: group.IsVoid,
			IsNullable: group.IsNullable,
			Overloads: new EquatableArray<MethodOverloadInfo>(genericOverloads),
			CombinedParameters: new EquatableArray<CombinedParameterInfo>(genericCombinedParams));

		return (nonGenericGroup, genericGroup);
	}

	/// <summary>
	/// Builds combined parameter info for a set of method overloads.
	/// Parameters not present in all overloads become nullable.
	/// </summary>
	private static CombinedParameterInfo[] BuildCombinedParametersForOverloads(MethodOverloadInfo[] overloads)
	{
		var allParamNames = new Dictionary<string, (string Type, int Count, RefKind RefKind)>();
		var totalOverloads = overloads.Length;

		foreach (var overload in overloads)
		{
			var parameters = overload.Parameters.GetArray() ?? Array.Empty<ParameterInfo>();
			foreach (var param in parameters)
			{
				if (allParamNames.TryGetValue(param.Name, out var existing))
				{
					allParamNames[param.Name] = (existing.Type, existing.Count + 1, existing.RefKind);
				}
				else
				{
					allParamNames[param.Name] = (param.Type, 1, param.RefKind);
				}
			}
		}

		var combinedParams = new List<CombinedParameterInfo>();
		foreach (var kvp in allParamNames)
		{
			var paramName = kvp.Key;
			var paramType = kvp.Value.Type;
			var count = kvp.Value.Count;
			var refKind = kvp.Value.RefKind;
			var isNullable = count < totalOverloads;
			var nullableType = isNullable ? MakeNullable(paramType) : paramType;

			combinedParams.Add(new CombinedParameterInfo(paramName, paramType, nullableType, isNullable, refKind));
		}

		return combinedParams.ToArray();
	}

	/// <summary>
	/// Gets the interceptor property name for a method, accounting for mixed groups.
	/// For mixed groups: non-generic methods use base name, generic methods use base name + "Generic" suffix.
	/// </summary>
	private static string GetInterceptorPropertyName(InterfaceMemberInfo member, MethodGroupInfo group)
	{
		if (!IsMixedMethodGroup(group))
			return group.Name;

		return member.IsGenericMethod ? group.Name + GenericSuffix : group.Name;
	}

	/// <summary>
	/// Makes a type nullable if it isn't already
	/// </summary>
	private static string MakeNullable(string type)
	{
		if (type.EndsWith("?"))
			return type;

		// Value types need ? suffix, reference types are already nullable with #nullable enable
		// But for clarity and to handle both, we add ? if not present
		return type + "?";
	}

	/// <summary>
	/// Gets the tuple type string for method parameters: (T1 name1, T2 name2, ...)
	/// </summary>
	private static string GetTupleType(EquatableArray<ParameterInfo> parameters)
	{
		var elements = parameters.Select(p => FormatParameter(p));
		return $"({string.Join(", ", elements)})";
	}

	/// <summary>
	/// Gets the tuple construction expression: (name1, name2, ...)
	/// </summary>
	private static string GetTupleConstruction(EquatableArray<ParameterInfo> parameters)
	{
		var elements = parameters.Select(p => p.Name);
		return $"({string.Join(", ", elements)})";
	}
}
