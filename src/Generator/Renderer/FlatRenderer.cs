// src/Generator/Renderer/FlatRenderer.cs
#nullable enable
using System.Collections.Generic;
using System.Linq;
using KnockOff;
using KnockOff.Model.Flat;
using KnockOff.Model.Shared;

namespace KnockOff.Renderer;

/// <summary>
/// Renders FlatGenerationUnit to source code string.
/// Pure emission - no decisions, just output what the model says.
/// </summary>
internal static class FlatRenderer
{
	public static string Render(FlatGenerationUnit unit)
	{
		var w = new CodeWriter();

		w.Line("// <auto-generated/>");
		w.Line("#nullable enable");
		w.Line();

		// Add using System.Linq if there are generic methods (needed for aggregate LINQ in handlers)
		if (unit.HasGenericMethods)
		{
			w.Line("using System.Linq;");
			w.Line();
		}

		// Namespace
		if (!string.IsNullOrEmpty(unit.Namespace))
		{
			w.Line($"namespace {unit.Namespace};");
			w.Line();
		}

		// Open containing type wrappers for nested classes
		foreach (var containingType in unit.ContainingTypes)
		{
			var accessMod = string.IsNullOrEmpty(containingType.AccessModifier)
				? ""
				: containingType.AccessModifier + " ";
			w.Line($"{accessMod}partial {containingType.Keyword} {containingType.Name}");
			w.Line("{");
		}

		// Class declaration with interfaces
		var interfaces = string.Join(", ", unit.InterfaceList);
		var typeParams = FormatTypeParameters(unit.TypeParameters);
		var constraints = FormatConstraints(unit.TypeParameters);

		// Calculate the class name with type parameters for delegate signatures
		var classNameWithTypeParams = $"{unit.ClassName}{typeParams}";

		using (w.Block($"partial class {unit.ClassName}{typeParams} : {interfaces}, global::KnockOff.IKnockOffStub{constraints}"))
		{
			// Track rendered interceptors to avoid duplicates
			// (Multiple interface members may map to the same interceptor)
			var renderedInterceptorClasses = new HashSet<string>();

			// Generic method interfaces if needed
			if (unit.HasGenericMethods)
				RenderGenericMethodInterfaces(w);

			// Interceptor classes (deduplicated by interceptor name)
			foreach (var prop in unit.Properties)
			{
				if (renderedInterceptorClasses.Add(prop.InterceptorClassName))
					RenderPropertyInterceptorClass(w, prop, classNameWithTypeParams);
			}

			foreach (var indexer in unit.Indexers)
			{
				if (renderedInterceptorClasses.Add(indexer.InterceptorClassName))
					RenderIndexerInterceptorClass(w, indexer, classNameWithTypeParams);
			}

			// Only render interceptor classes for non-generic methods
			// Generic methods use the handler classes with Of<T>() pattern
			foreach (var method in unit.Methods.Where(m => !m.IsGenericMethod))
			{
				if (renderedInterceptorClasses.Add(method.InterceptorClassName))
					RenderMethodInterceptorClass(w, method, classNameWithTypeParams);
			}

			foreach (var handler in unit.GenericMethodHandlers)
			{
				if (renderedInterceptorClasses.Add(handler.InterceptorClassName))
					RenderGenericMethodHandler(w, handler, classNameWithTypeParams);
			}

			foreach (var evt in unit.Events)
			{
				if (renderedInterceptorClasses.Add(evt.InterceptorClassName))
					RenderEventInterceptorClass(w, evt);
			}

			// Interceptor properties (public access to interceptors)
			RenderInterceptorProperties(w, unit);

			// Standard members (Strict mode, Object accessor)
			RenderStandardMembers(w, unit);

			// Explicit interface implementations (NOT deduplicated - one per interface member)
			foreach (var prop in unit.Properties)
				RenderPropertyImplementation(w, prop);

			foreach (var indexer in unit.Indexers)
				RenderIndexerImplementation(w, indexer);

			foreach (var method in unit.Methods)
				RenderMethodImplementation(w, method);

			foreach (var evt in unit.Events)
				RenderEventImplementation(w, evt);
		}

		// Close containing type wrappers for nested classes
		for (int i = 0; i < unit.ContainingTypes.Count; i++)
		{
			w.Line("}");
		}

		return w.ToString();
	}

	#region Type Parameter Formatting

	private static string FormatTypeParameters(EquatableArray<TypeParameterModel> typeParameters)
	{
		if (typeParameters.Count == 0)
			return "";

		var names = string.Join(", ", typeParameters.Select(tp => tp.Name));
		return $"<{names}>";
	}

	private static string FormatConstraints(EquatableArray<TypeParameterModel> typeParameters)
	{
		if (typeParameters.Count == 0)
			return "";

		var clauses = typeParameters
			.Where(tp => !string.IsNullOrEmpty(tp.Constraints))
			.Select(tp => $" where {tp.Name} : {tp.Constraints}");

		return string.Join("", clauses);
	}

	#endregion

	#region Generic Method Interfaces

	private static void RenderGenericMethodInterfaces(CodeWriter w)
	{
		w.Line("/// <summary>Interface for tracking calls to generic methods.</summary>");
		using (w.Block("private interface IGenericMethodCallTracker"))
		{
			w.Line("int CallCount { get; }");
			w.Line("bool WasCalled { get; }");
		}
		w.Line();

		w.Line("/// <summary>Interface for resetting state.</summary>");
		using (w.Block("private interface IResettable"))
		{
			w.Line("void Reset();");
		}
		w.Line();
	}

	#endregion

	#region Property Interceptor Class

	private static void RenderPropertyInterceptorClass(CodeWriter w, FlatPropertyModel prop, string className)
	{
		w.Line($"/// <summary>Tracks and configures behavior for {prop.MemberName}.</summary>");
		using (w.Block($"public sealed class {prop.InterceptorClassName}"))
		{
			if (prop.IsInitOnly)
			{
				RenderInitPropertyInterceptorContent(w, prop);
			}
			else
			{
				RenderRegularPropertyInterceptorContent(w, prop, className);
			}
		}
		w.Line();
	}

	private static void RenderInitPropertyInterceptorContent(CodeWriter w, FlatPropertyModel prop)
	{
		w.Line($"/// <summary>The configured value for {prop.MemberName}.</summary>");
		w.Line($"public {prop.ReturnType} Value {{ get; set; }} = default!;");
		w.Line();

		w.Line("/// <summary>Number of times the getter was accessed.</summary>");
		w.Line("public int GetCount { get; private set; }");
		w.Line();

		w.Line("/// <summary>Records a getter access.</summary>");
		w.Line("public void RecordGet() => GetCount++;");
		w.Line();

		w.Line("/// <summary>Resets all tracking state.</summary>");
		w.Line("public void Reset() { GetCount = 0; Value = default!; }");
	}

	private static void RenderRegularPropertyInterceptorContent(CodeWriter w, FlatPropertyModel prop, string className)
	{
		if (prop.HasGetter)
		{
			w.Line("/// <summary>Number of times the getter was accessed.</summary>");
			w.Line("public int GetCount { get; private set; }");
			w.Line();

			w.Line("/// <summary>Callback invoked when the getter is accessed. If set, its return value is used.</summary>");
			w.Line($"public global::System.Func<{className}, {prop.ReturnType}>? OnGet {{ get; set; }}");
			w.Line();
		}

		if (prop.HasSetter)
		{
			w.Line("/// <summary>Number of times the setter was accessed.</summary>");
			w.Line("public int SetCount { get; private set; }");
			w.Line();

			w.Line("/// <summary>The value from the most recent setter call.</summary>");
			w.Line($"public {prop.NullableReturnType} LastSetValue {{ get; private set; }}");
			w.Line();

			w.Line("/// <summary>Callback invoked when the setter is accessed.</summary>");
			w.Line($"public global::System.Action<{className}, {prop.ReturnType}>? OnSet {{ get; set; }}");
			w.Line();
		}

		// Value property for backing storage
		w.Line("/// <summary>Value returned by getter when OnGet is not set.</summary>");
		w.Line($"public {prop.ReturnType} Value {{ get; set; }}{GetDefaultValueSuffix(prop.DefaultExpression)}");
		w.Line();

		if (prop.HasGetter)
		{
			w.Line("/// <summary>Records a getter access.</summary>");
			w.Line("public void RecordGet() => GetCount++;");
			w.Line();
		}

		if (prop.HasSetter)
		{
			w.Line("/// <summary>Records a setter access.</summary>");
			w.Line($"public void RecordSet({prop.NullableReturnType} value) {{ SetCount++; LastSetValue = value; }}");
			w.Line();
		}

		w.Line("/// <summary>Resets all tracking state.</summary>");
		var resetParts = new System.Collections.Generic.List<string>();
		if (prop.HasGetter) resetParts.Add("GetCount = 0; OnGet = null;");
		if (prop.HasSetter) resetParts.Add("SetCount = 0; LastSetValue = default; OnSet = null;");
		resetParts.Add("Value = default!;");
		w.Line($"public void Reset() {{ {string.Join(" ", resetParts)} }}");
	}

	private static string GetDefaultValueSuffix(string defaultExpression)
	{
		// The DefaultExpression from the model contains the complete expression (e.g., "default!", "new List<int>()")
		// We need to convert it to an initializer format with " = " prefix and ";" suffix
		if (string.IsNullOrEmpty(defaultExpression) || defaultExpression == "default!")
			return " = default!;";

		// For NewInstance strategy, the expression will be like "new SomeType()"
		return $" = {defaultExpression};";
	}

	#endregion

	#region Indexer Interceptor Class

	private static void RenderIndexerInterceptorClass(CodeWriter w, FlatIndexerModel indexer, string className)
	{
		w.Line($"/// <summary>Tracks and configures behavior for indexer.</summary>");
		using (w.Block($"public sealed class {indexer.InterceptorClassName}"))
		{
			if (indexer.HasGetter)
			{
				w.Line("/// <summary>Number of times the getter was accessed.</summary>");
				w.Line("public int GetCount { get; private set; }");
				w.Line();

				w.Line("/// <summary>The key from the most recent getter access.</summary>");
				w.Line($"public {indexer.NullableKeyType} LastGetKey {{ get; private set; }}");
				w.Line();

				w.Line("/// <summary>Callback invoked when the getter is accessed.</summary>");
				w.Line($"public global::System.Func<{className}, {indexer.KeyType}, {indexer.ReturnType}>? OnGet {{ get; set; }}");
				w.Line();
			}

			if (indexer.HasSetter)
			{
				w.Line("/// <summary>Number of times the setter was accessed.</summary>");
				w.Line("public int SetCount { get; private set; }");
				w.Line();

				w.Line("/// <summary>The key and value from the most recent setter call.</summary>");
				w.Line($"public ({indexer.NullableKeyType} Key, {indexer.NullableReturnType} Value)? LastSetEntry {{ get; private set; }}");
				w.Line();

				w.Line("/// <summary>Callback invoked when the setter is accessed.</summary>");
				w.Line($"public global::System.Action<{className}, {indexer.KeyType}, {indexer.ReturnType}>? OnSet {{ get; set; }}");
				w.Line();
			}

			if (indexer.HasGetter)
			{
				w.Line("/// <summary>Records a getter access.</summary>");
				w.Line($"public void RecordGet({indexer.NullableKeyType} {indexer.KeyParamName}) {{ GetCount++; LastGetKey = {indexer.KeyParamName}; }}");
				w.Line();
			}

			if (indexer.HasSetter)
			{
				w.Line("/// <summary>Records a setter access.</summary>");
				w.Line($"public void RecordSet({indexer.NullableKeyType} {indexer.KeyParamName}, {indexer.NullableReturnType} value) {{ SetCount++; LastSetEntry = ({indexer.KeyParamName}, value); }}");
				w.Line();
			}

			// Backing dictionary
			w.Line($"/// <summary>Backing storage for this indexer.</summary>");
			w.Line($"public global::System.Collections.Generic.Dictionary<{indexer.KeyType}, {indexer.ReturnType}> Backing {{ get; }} = new();");
			w.Line();

			// Reset method
			w.Line("/// <summary>Resets all tracking state.</summary>");
			var resetParts = new System.Collections.Generic.List<string>();
			if (indexer.HasGetter) resetParts.Add("GetCount = 0; LastGetKey = default; OnGet = null;");
			if (indexer.HasSetter) resetParts.Add("SetCount = 0; LastSetEntry = null; OnSet = null;");
			// Note: Backing dictionary is intentionally NOT cleared - pre-populated data is preserved
			w.Line($"public void Reset() {{ {string.Join(" ", resetParts)} }}");
		}
		w.Line();
	}

	#endregion

	#region Method Interceptor Class

	private static void RenderMethodInterceptorClass(CodeWriter w, FlatMethodModel method, string className)
	{
		w.Line($"/// <summary>Tracks and configures behavior for {method.MethodName}.</summary>");
		using (w.Block($"public sealed class {method.InterceptorClassName}"))
		{
			// Custom delegate if needed
			if (method.NeedsCustomDelegate && method.CustomDelegateSignature != null)
			{
				w.Line($"/// <summary>Delegate for {method.MethodName}.</summary>");
				w.Line(method.CustomDelegateSignature);
				w.Line();
			}

			// CallCount
			w.Line("/// <summary>Number of times this method was called.</summary>");
			w.Line("public int CallCount { get; private set; }");
			w.Line();

			// WasCalled
			w.Line("/// <summary>Whether this method was called at least once.</summary>");
			w.Line("public bool WasCalled => CallCount > 0;");
			w.Line();

			// LastCallArg/LastCallArgs
			if (method.TrackableParameters.Count == 1)
			{
				var param = method.TrackableParameters.GetArray()![0];
				w.Line($"/// <summary>The argument from the most recent call.</summary>");
				w.Line($"public {param.NullableType} LastCallArg {{ get; private set; }}");
				w.Line();
			}
			else if (method.TrackableParameters.Count > 1)
			{
				w.Line($"/// <summary>The arguments from the most recent call.</summary>");
				w.Line($"public {method.LastCallType}? LastCallArgs {{ get; private set; }}");
				w.Line();
			}

			// OnCall delegate
			w.Line("/// <summary>Callback invoked when this method is called.</summary>");
			w.Line($"public {method.OnCallDelegateType} OnCall {{ get; set; }}");
			w.Line();

			// RecordCall method
			w.Line("/// <summary>Records a method call.</summary>");
			if (method.TrackableParameters.Count == 0)
			{
				w.Line("public void RecordCall() => CallCount++;");
			}
			else if (method.TrackableParameters.Count == 1)
			{
				var param = method.TrackableParameters.GetArray()![0];
				w.Line($"public void RecordCall({param.NullableType} {param.EscapedName}) {{ CallCount++; LastCallArg = {param.EscapedName}; }}");
			}
			else
			{
				var paramDecls = string.Join(", ", method.TrackableParameters.Select(p => $"{p.NullableType} {p.EscapedName}"));
				var tupleAssign = string.Join(", ", method.TrackableParameters.Select(p => p.EscapedName));
				w.Line($"public void RecordCall({paramDecls}) {{ CallCount++; LastCallArgs = ({tupleAssign}); }}");
			}
			w.Line();

			// Reset method
			w.Line("/// <summary>Resets all tracking state.</summary>");
			var resetBody = "CallCount = 0; ";
			if (method.TrackableParameters.Count == 1)
				resetBody += "LastCallArg = default; ";
			else if (method.TrackableParameters.Count > 1)
				resetBody += "LastCallArgs = null; ";
			resetBody += "OnCall = null;";
			w.Line($"public void Reset() {{ {resetBody} }}");
		}
		w.Line();
	}

	#endregion

	#region Generic Method Handler

	private static void RenderGenericMethodHandler(CodeWriter w, FlatGenericMethodHandlerModel handler, string className)
	{
		w.Line($"/// <summary>Interceptor for {handler.MethodName} (generic method with Of&lt;T&gt;() access).</summary>");
		using (w.Block($"public sealed class {handler.InterceptorClassName}"))
		{
			// Dictionary for typed handlers
			w.Line($"private readonly global::System.Collections.Generic.Dictionary<{handler.KeyType}, object> _typedHandlers = new();");
			w.Line();

			// Of<T>() method
			w.Line($"/// <summary>Gets the typed handler for the specified type argument(s).</summary>");
			w.Line($"public {handler.TypedHandlerClassName}<{handler.TypeParameterNames}> Of<{handler.TypeParameterNames}>(){handler.ConstraintClauses}");
			using (w.Braces())
			{
				w.Line($"var key = {handler.KeyConstruction};");
				w.Line($"if (!_typedHandlers.TryGetValue(key, out var handler))");
				using (w.Braces())
				{
					w.Line($"handler = new {handler.TypedHandlerClassName}<{handler.TypeParameterNames}>();");
					w.Line("_typedHandlers[key] = handler;");
				}
				w.Line($"return ({handler.TypedHandlerClassName}<{handler.TypeParameterNames}>)handler;");
			}
			w.Line();

			// Aggregate tracking
			w.Line("/// <summary>Total number of calls across all type arguments.</summary>");
			w.Line("public int TotalCallCount => _typedHandlers.Values.Sum(h => ((IGenericMethodCallTracker)h).CallCount);");
			w.Line();
			w.Line("/// <summary>True if this method was called with any type argument.</summary>");
			w.Line("public bool WasCalled => _typedHandlers.Values.Any(h => ((IGenericMethodCallTracker)h).WasCalled);");
			w.Line();
			w.Line($"/// <summary>All type argument(s) that were used in calls.</summary>");
			w.Line($"public global::System.Collections.Generic.IReadOnlyList<{handler.KeyType}> CalledTypeArguments => _typedHandlers.Keys.ToList();");
			w.Line();

			// Reset method
			w.Line("/// <summary>Resets all typed handlers.</summary>");
			using (w.Block("public void Reset()"))
			{
				w.Line("foreach (var handler in _typedHandlers.Values)");
				w.Line("\t((IResettable)handler).Reset();");
				w.Line("_typedHandlers.Clear();");
			}
			w.Line();

			// Nested Typed Handler Class
			RenderTypedHandlerClass(w, handler, className);
		}
		w.Line();
	}

	private static void RenderTypedHandlerClass(CodeWriter w, FlatGenericMethodHandlerModel handler, string className)
	{
		w.Line($"/// <summary>Typed handler for {handler.MethodName} with specific type arguments.</summary>");
		w.Line($"public sealed class {handler.TypedHandlerClassName}<{handler.TypeParameterNames}> : IGenericMethodCallTracker, IResettable{handler.ConstraintClauses}");
		using (w.Braces())
		{
			// Delegate
			w.Line($"/// <summary>Delegate for {handler.MethodName}.</summary>");
			w.Line(handler.DelegateSignature);
			w.Line();

			// CallCount
			w.Line("/// <summary>Number of times this method was called with these type arguments.</summary>");
			w.Line("public int CallCount { get; private set; }");
			w.Line();

			// LastCallArg/LastCallArgs
			if (handler.NonGenericParams.Count == 1)
			{
				var param = handler.NonGenericParams.GetArray()![0];
				w.Line($"/// <summary>The '{param.Name}' argument from the most recent call.</summary>");
				w.Line($"public {param.NullableType} LastCallArg {{ get; private set; }}");
				w.Line();
			}
			else if (handler.NonGenericParams.Count > 1)
			{
				w.Line("/// <summary>The arguments from the most recent call.</summary>");
				w.Line($"public {handler.LastCallType}? LastCallArgs {{ get; private set; }}");
				w.Line();
			}

			// WasCalled
			w.Line("/// <summary>True if this method was called at least once with these type arguments.</summary>");
			w.Line("public bool WasCalled => CallCount > 0;");
			w.Line();

			// OnCall
			w.Line("/// <summary>Callback invoked when this method is called. If set, its return value is used.</summary>");
			w.Line($"public {handler.MethodName}Delegate? OnCall {{ get; set; }}");
			w.Line();

			// RecordCall
			w.Line("/// <summary>Records a method call.</summary>");
			if (handler.NonGenericParams.Count == 0)
			{
				w.Line("public void RecordCall() => CallCount++;");
			}
			else if (handler.NonGenericParams.Count == 1)
			{
				var param = handler.NonGenericParams.GetArray()![0];
				w.Line($"public void RecordCall({param.NullableType} {param.EscapedName}) {{ CallCount++; LastCallArg = {param.EscapedName}; }}");
			}
			else
			{
				var paramList = string.Join(", ", handler.NonGenericParams.Select(p => $"{p.NullableType} {p.EscapedName}"));
				var tupleConstruction = string.Join(", ", handler.NonGenericParams.Select(p => p.EscapedName));
				w.Line($"public void RecordCall({paramList}) {{ CallCount++; LastCallArgs = ({tupleConstruction}); }}");
			}
			w.Line();

			// Reset
			w.Line("/// <summary>Resets all tracking state.</summary>");
			if (handler.NonGenericParams.Count == 0)
			{
				w.Line("public void Reset() { CallCount = 0; OnCall = null; }");
			}
			else if (handler.NonGenericParams.Count == 1)
			{
				w.Line("public void Reset() { CallCount = 0; LastCallArg = default; OnCall = null; }");
			}
			else
			{
				w.Line("public void Reset() { CallCount = 0; LastCallArgs = default; OnCall = null; }");
			}
		}
	}

	#endregion

	#region Event Interceptor Class

	private static void RenderEventInterceptorClass(CodeWriter w, FlatEventModel evt)
	{
		w.Line($"/// <summary>Interceptor for {evt.EventName} event.</summary>");
		using (w.Block($"public sealed class {evt.InterceptorClassName}"))
		{
			// Backing field
			w.Line($"private {evt.DelegateType}? _handler;");
			w.Line();

			// Add/Remove tracking
			w.Line("/// <summary>Number of times event was subscribed to.</summary>");
			w.Line("public int AddCount { get; private set; }");
			w.Line();

			w.Line("/// <summary>Number of times event subscription was removed.</summary>");
			w.Line("public int RemoveCount { get; private set; }");
			w.Line();

			w.Line("/// <summary>Whether any handlers are subscribed.</summary>");
			w.Line("public bool HasSubscribers => _handler != null;");
			w.Line();

			// RecordAdd/RecordRemove
			w.Line($"/// <summary>Records an event subscription.</summary>");
			w.Line($"public void RecordAdd({evt.DelegateType}? value) {{ AddCount++; _handler = ({evt.DelegateType}?)global::System.Delegate.Combine(_handler, value); }}");
			w.Line();

			w.Line($"/// <summary>Records an event unsubscription.</summary>");
			w.Line($"public void RecordRemove({evt.DelegateType}? value) {{ RemoveCount++; _handler = ({evt.DelegateType}?)global::System.Delegate.Remove(_handler, value); }}");
			w.Line();

			// Raise method
			RenderEventRaiseMethod(w, evt);

			// Reset
			w.Line("/// <summary>Resets all tracking state.</summary>");
			w.Line("public void Reset() { AddCount = 0; RemoveCount = 0; _handler = null; }");
		}
		w.Line();
	}

	private static void RenderEventRaiseMethod(CodeWriter w, FlatEventModel evt)
	{
		if (evt.RaiseReturnsValue)
		{
			// Func-style delegate
			w.Line("/// <summary>Raises the event with the specified arguments and returns the result.</summary>");
			if (string.IsNullOrEmpty(evt.RaiseParameters))
			{
				w.Line($"public {evt.RaiseReturnType} Raise() => _handler != null ? _handler.Invoke() : default!;");
			}
			else
			{
				w.Line($"public {evt.RaiseReturnType} Raise({evt.RaiseParameters}) => _handler != null ? _handler.Invoke({evt.RaiseArguments}) : default!;");
			}
		}
		else if (evt.UsesDynamicInvoke)
		{
			// Custom delegate - use DynamicInvoke
			if (string.IsNullOrEmpty(evt.RaiseParameters))
			{
				w.Line("/// <summary>Raises the event.</summary>");
				w.Line("public void Raise() => (_handler as global::System.Action)?.Invoke();");
			}
			else
			{
				w.Line("/// <summary>Invokes the handler if subscribed.</summary>");
				w.Line($"public void Raise({evt.RaiseParameters}) => _handler?.DynamicInvoke({evt.RaiseArguments});");
			}
		}
		else
		{
			// Standard Action/EventHandler
			if (string.IsNullOrEmpty(evt.RaiseParameters))
			{
				w.Line("/// <summary>Raises the event.</summary>");
				w.Line("public void Raise() => _handler?.Invoke();");
			}
			else
			{
				w.Line("/// <summary>Raises the event with the specified arguments.</summary>");
				w.Line($"public void Raise({evt.RaiseParameters}) => _handler?.Invoke({evt.RaiseArguments});");
			}
		}
		w.Line();
	}

	#endregion

	#region Interceptor Properties

	private static void RenderInterceptorProperties(CodeWriter w, FlatGenerationUnit unit)
	{
		// Track rendered interceptor properties to avoid duplicates
		var renderedProperties = new HashSet<string>();

		// Properties
		foreach (var prop in unit.Properties)
		{
			if (!renderedProperties.Add(prop.InterceptorName))
				continue;
			var newKeyword = prop.NeedsNewKeyword ? "new " : "";
			w.Line($"/// <summary>Interceptor for {prop.MemberName}. Configure via .Value, track via .GetCount.</summary>");
			w.Line($"public {newKeyword}{prop.InterceptorClassName} {prop.InterceptorName} {{ get; }} = new();");
			w.Line();
		}

		// Indexers
		foreach (var indexer in unit.Indexers)
		{
			if (!renderedProperties.Add(indexer.InterceptorName))
				continue;
			var newKeyword = indexer.NeedsNewKeyword ? "new " : "";
			w.Line($"/// <summary>Interceptor for indexer. Configure callbacks and track access.</summary>");
			w.Line($"public {newKeyword}{indexer.InterceptorClassName} {indexer.InterceptorName} {{ get; }} = new();");
			w.Line();
		}

		// Methods (only non-generic - generic methods use handler properties)
		foreach (var method in unit.Methods.Where(m => !m.IsGenericMethod))
		{
			if (!renderedProperties.Add(method.InterceptorName))
				continue;
			var newKeyword = method.NeedsNewKeyword ? "new " : "";
			w.Line($"/// <summary>Interceptor for {method.MethodName}.</summary>");
			w.Line($"public {newKeyword}{method.InterceptorClassName} {method.InterceptorName} {{ get; }} = new();");
			w.Line();
		}

		// Generic method handlers
		foreach (var handler in unit.GenericMethodHandlers)
		{
			if (!renderedProperties.Add(handler.InterceptorName))
				continue;
			var newKeyword = handler.NeedsNewKeyword ? "new " : "";
			w.Line($"/// <summary>Interceptor for {handler.MethodName} (generic method).</summary>");
			w.Line($"public {newKeyword}{handler.InterceptorClassName} {handler.InterceptorName} {{ get; }} = new();");
			w.Line();
		}

		// Events
		foreach (var evt in unit.Events)
		{
			if (!renderedProperties.Add(evt.InterceptorName))
				continue;
			var newKeyword = evt.NeedsNewKeyword ? "new " : "";
			w.Line($"/// <summary>Interceptor for {evt.EventName} event.</summary>");
			w.Line($"public {newKeyword}{evt.InterceptorClassName} {evt.InterceptorName} {{ get; }} = new();");
			w.Line();
		}
	}

	#endregion

	#region Standard Members

	private static void RenderStandardMembers(CodeWriter w, FlatGenerationUnit unit)
	{
		// Strict mode property with configurable default
		var strictDefault = unit.Strict ? "true" : "false";
		w.Line("/// <summary>When true, throws StubException for unconfigured member access.</summary>");
		w.Line($"public bool Strict {{ get; set; }} = {strictDefault};");
		w.Line();

		// Object accessor - returns the first interface type
		var typeParams = FormatTypeParameters(unit.TypeParameters);
		var primaryInterface = unit.InterfaceList.Count > 0 ? unit.InterfaceList.GetArray()![0] : $"{unit.ClassName}{typeParams}";
		w.Line($"/// <summary>The {primaryInterface} instance. Use for passing to code expecting the interface.</summary>");
		w.Line($"public {primaryInterface} Object => this;");
		w.Line();

		// SmartDefault helper (only if there are generic methods)
		if (unit.HasGenericMethods)
		{
			RenderSmartDefaultMethod(w);
		}
	}

	private static void RenderSmartDefaultMethod(CodeWriter w)
	{
		w.Line("/// <summary>Gets a smart default value for a generic type at runtime.</summary>");
		using (w.Block("private static T SmartDefault<T>(string methodName)"))
		{
			w.Line("var type = typeof(T);");
			w.Line();
			w.Line("// Value types -> default(T)");
			w.Line("if (type.IsValueType)");
			w.Line("\treturn default!;");
			w.Line();
			w.Line("// Check for parameterless constructor");
			w.Line("var ctor = type.GetConstructor(");
			w.Line("\tSystem.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance,");
			w.Line("\tnull, System.Type.EmptyTypes, null);");
			w.Line();
			w.Line("if (ctor != null)");
			w.Line("\treturn (T)ctor.Invoke(null);");
			w.Line();
			w.Line("throw new global::System.InvalidOperationException(");
			w.Line("\t$\"No implementation provided for {methodName}<{type.Name}>. \" +");
			w.Line("\t$\"Set the handler's OnCall.\");");
		}
		w.Line();
	}

	#endregion

	#region Property Implementation

	private static void RenderPropertyImplementation(CodeWriter w, FlatPropertyModel prop)
	{
		// Handle property delegation (e.g., IProperty.Value (object) delegates to IProperty<T>.Value (T))
		if (prop.DelegationTarget != null && prop.DelegationTargetInterface != null)
		{
			RenderPropertyDelegation(w, prop);
			return;
		}

		w.Line($"{prop.ReturnType} {prop.DeclaringInterface}.{prop.MemberName}");
		using (w.Braces())
		{
			if (prop.IsInitOnly)
			{
				// Init-only: read from interceptor's Value, record access
				w.Line($"get {{ {prop.InterceptorName}.RecordGet(); return {prop.InterceptorName}.Value; }}");
				w.Line($"init {{ {prop.InterceptorName}.Value = value; }}");
			}
			else
			{
				if (prop.HasGetter)
				{
					w.Line($"get {{ {prop.InterceptorName}.RecordGet(); if ({prop.InterceptorName}.OnGet is {{ }} onGet) return onGet(this); if (Strict) throw global::KnockOff.StubException.NotConfigured(\"{prop.SimpleInterfaceName}\", \"{prop.MemberName}\"); return {prop.InterceptorName}.Value; }}");
				}

				if (prop.HasSetter)
				{
					if (prop.SetterPragmaDisable != null)
						w.Append(prop.SetterPragmaDisable);
					w.Line($"set {{ {prop.InterceptorName}.RecordSet(value); if ({prop.InterceptorName}.OnSet is {{ }} onSet) {{ onSet(this, value); return; }} if (Strict) throw global::KnockOff.StubException.NotConfigured(\"{prop.SimpleInterfaceName}\", \"{prop.MemberName}\"); {prop.InterceptorName}.Value = value; }}");
					if (prop.SetterPragmaRestore != null)
						w.Line(prop.SetterPragmaRestore);
				}
			}
		}
		w.Line();
	}

	private static void RenderPropertyDelegation(CodeWriter w, FlatPropertyModel prop)
	{
		var target = prop.DelegationTarget!;
		var targetInterface = prop.DelegationTargetInterface!;

		w.Line($"{prop.ReturnType} {prop.DeclaringInterface}.{prop.MemberName}");
		using (w.Braces())
		{
			if (prop.HasGetter)
			{
				// Cast the typed value to object (or the base return type)
				w.Line($"get => (({targetInterface})this).{target.Name}!;");
			}

			if (prop.HasSetter)
			{
				// Cast the object value to the typed type
				w.Line($"set => (({targetInterface})this).{target.Name} = ({target.ReturnType.TrimEnd('?')})value!;");
			}
		}
		w.Line();
	}

	#endregion

	#region Indexer Implementation

	private static void RenderIndexerImplementation(CodeWriter w, FlatIndexerModel indexer)
	{
		w.Line($"{indexer.ReturnType} {indexer.DeclaringInterface}.this[{indexer.KeyType} {indexer.KeyParamName}]");
		using (w.Braces())
		{
			if (indexer.HasGetter)
			{
				w.Line($"get {{ {indexer.InterceptorName}.RecordGet({indexer.KeyParamName}); if ({indexer.InterceptorName}.OnGet is {{ }} onGet) return onGet(this, {indexer.KeyParamName}); if (Strict) throw global::KnockOff.StubException.NotConfigured(\"{indexer.SimpleInterfaceName}\", \"this[]\"); return {indexer.InterceptorName}.Backing.TryGetValue({indexer.KeyParamName}, out var v) ? v : {indexer.DefaultExpression}; }}");
			}

			if (indexer.HasSetter)
			{
				w.Line($"set {{ {indexer.InterceptorName}.RecordSet({indexer.KeyParamName}, value); if ({indexer.InterceptorName}.OnSet is {{ }} onSet) {{ onSet(this, {indexer.KeyParamName}, value); return; }} if (Strict) throw global::KnockOff.StubException.NotConfigured(\"{indexer.SimpleInterfaceName}\", \"this[]\"); {indexer.InterceptorName}.Backing[{indexer.KeyParamName}] = value; }}");
			}
		}
		w.Line();
	}

	#endregion

	#region Method Implementation

	private static void RenderMethodImplementation(CodeWriter w, FlatMethodModel method)
	{
		// Handle method delegation (e.g., IRule.RunRule(IValidateBase) delegates to IRule<T>.RunRule(T))
		if (method.DelegationTarget != null && method.DelegationTargetInterface != null)
		{
			RenderMethodDelegation(w, method);
			return;
		}

		w.Line($"{method.ReturnType} {method.DeclaringInterface}.{method.MethodName}{method.TypeParameterDecl}({method.ParameterDeclarations}){method.ConstraintClauses}");
		using (w.Braces())
		{
			// Initialize out parameters
			foreach (var p in method.Parameters.Where(p => p.RefKind == Microsoft.CodeAnalysis.RefKind.Out))
			{
				w.Line($"{p.EscapedName} = default!;");
			}

			// Build interceptor access expression
			// For generic methods: MethodName.Of<T>() pattern
			// For non-generic methods: MethodName directly
			var interceptorAccess = method.IsGenericMethod
				? $"{method.InterceptorName}{method.OfTypeAccess}"
				: method.InterceptorName;

			// Record the call
			w.Line($"{interceptorAccess}.RecordCall({method.RecordCallArgs});");

			// Build onCall args
			var hasRefOrOut = method.Parameters.Any(p => p.RefKind == Microsoft.CodeAnalysis.RefKind.Ref || p.RefKind == Microsoft.CodeAnalysis.RefKind.Out);
			var onCallArgs = method.Parameters.Count > 0
				? "this, " + string.Join(", ", method.Parameters.Select(p => $"{p.RefPrefix}{p.EscapedName}"))
				: "this";

			if (method.UserMethodCall != null)
			{
				// User method takes priority
				if (method.IsVoid)
				{
					w.Line($"if ({interceptorAccess}.OnCall is {{ }} callback) {{ callback({onCallArgs}); return; }}");
					w.Line($"{method.UserMethodCall};");
				}
				else
				{
					w.Line($"if ({interceptorAccess}.OnCall is {{ }} callback) return callback({onCallArgs});");
					w.Line($"return {method.UserMethodCall};");
				}
			}
			else if (hasRefOrOut)
			{
				// Ref/out methods need special handling
				if (method.IsVoid)
				{
					w.Line($"if ({interceptorAccess}.OnCall is {{ }} onCallCallback)");
					w.Line($"{{ onCallCallback({onCallArgs}); return; }}");
					w.Line($"if (Strict) throw global::KnockOff.StubException.NotConfigured(\"{method.SimpleInterfaceName}\", \"{method.MethodName}\");");
				}
				else
				{
					w.Line($"if ({interceptorAccess}.OnCall is {{ }} onCallCallback)");
					w.Line($"\treturn onCallCallback({onCallArgs});");
					w.Line($"if (Strict) throw global::KnockOff.StubException.NotConfigured(\"{method.SimpleInterfaceName}\", \"{method.MethodName}\");");
					if (method.ThrowsOnDefault)
					{
						w.Line($"throw new global::System.InvalidOperationException(\"No implementation provided for {method.MethodName}. Set {interceptorAccess}.OnCall or define a protected method '{method.MethodName}' in your partial class.\");");
					}
					else
					{
						w.Line($"return {method.DefaultExpression};");
					}
				}
			}
			else
			{
				// Standard method
				if (method.IsVoid)
				{
					w.Line($"if ({interceptorAccess}.OnCall is {{ }} onCallCallback)");
					w.Line($"{{ onCallCallback({onCallArgs}); return; }}");
					w.Line($"if (Strict) throw global::KnockOff.StubException.NotConfigured(\"{method.SimpleInterfaceName}\", \"{method.MethodName}\");");
				}
				else if (method.ThrowsOnDefault)
				{
					w.Line($"if ({interceptorAccess}.OnCall is {{ }} callback)");
					w.Line($"\treturn callback({onCallArgs});");
					w.Line($"if (Strict) throw global::KnockOff.StubException.NotConfigured(\"{method.SimpleInterfaceName}\", \"{method.MethodName}\");");
					w.Line($"throw new global::System.InvalidOperationException(\"No implementation provided for {method.MethodName}. Set {interceptorAccess}.OnCall or define a protected method '{method.MethodName}' in your partial class.\");");
				}
				else
				{
					w.Line($"if ({interceptorAccess}.OnCall is {{ }} callback)");
					w.Line($"\treturn callback({onCallArgs});");
					w.Line($"if (Strict) throw global::KnockOff.StubException.NotConfigured(\"{method.SimpleInterfaceName}\", \"{method.MethodName}\");");
					w.Line($"return {method.DefaultExpression};");
				}
			}
		}
		w.Line();
	}

	private static void RenderMethodDelegation(CodeWriter w, FlatMethodModel method)
	{
		var target = method.DelegationTarget!;
		var targetInterface = method.DelegationTargetInterface!;

		// Build parameter cast expressions for delegation
		var memberParams = method.Parameters.GetArray() ?? System.Array.Empty<KnockOff.Model.Shared.ParameterModel>();
		var targetParams = target.Parameters.GetArray() ?? System.Array.Empty<ParameterInfo>();

		var castArgs = new List<string>();
		for (int i = 0; i < memberParams.Length; i++)
		{
			var memberType = memberParams[i].Type;
			var targetType = targetParams[i].Type;
			var paramName = memberParams[i].EscapedName;

			if (memberType != targetType)
			{
				// Cast to the target type
				castArgs.Add($"({targetType}){paramName}");
			}
			else
			{
				castArgs.Add(paramName);
			}
		}

		var argList = string.Join(", ", castArgs);

		// Expression-bodied members don't use 'return' keyword
		w.Line($"{method.ReturnType} {method.DeclaringInterface}.{method.MethodName}{method.TypeParameterDecl}({method.ParameterDeclarations}){method.ConstraintClauses}");
		w.Line($"\t=> (({targetInterface})this).{target.Name}({argList});");
		w.Line();
	}

	#endregion

	#region Event Implementation

	private static void RenderEventImplementation(CodeWriter w, FlatEventModel evt)
	{
		w.Line($"event {evt.DelegateType}? {evt.DeclaringInterface}.{evt.EventName}");
		using (w.Braces())
		{
			w.Line($"add => {evt.InterceptorName}.RecordAdd(value);");
			w.Line($"remove => {evt.InterceptorName}.RecordRemove(value);");
		}
		w.Line();
	}

	#endregion
}
