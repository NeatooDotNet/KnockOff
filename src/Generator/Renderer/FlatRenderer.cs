// src/Generator/Renderer/FlatRenderer.cs
#nullable enable
using System.Collections.Generic;
using System.Linq;
using KnockOff;
using KnockOff.Model.Flat;
using KnockOff.Model.Shared;

namespace KnockOff.Renderer;

/// <summary>
/// Renders FlatGenerationUnit to source code string.
/// Pure emission - no decisions, just output what the model says.
/// </summary>
internal static class FlatRenderer
{
	public static string Render(FlatGenerationUnit unit)
	{
		var w = new CodeWriter();

		w.Line("// <auto-generated/>");
		w.Line("#nullable enable");
		w.Line();

		// Add using System.Linq if there are generic methods (needed for aggregate LINQ in handlers)
		if (unit.HasGenericMethods)
		{
			w.Line("using System.Linq;");
			w.Line();
		}

		// Namespace
		if (!string.IsNullOrEmpty(unit.Namespace))
		{
			w.Line($"namespace {unit.Namespace};");
			w.Line();
		}

		// Open containing type wrappers for nested classes
		foreach (var containingType in unit.ContainingTypes)
		{
			var accessMod = string.IsNullOrEmpty(containingType.AccessModifier)
				? ""
				: containingType.AccessModifier + " ";
			w.Line($"{accessMod}partial {containingType.Keyword} {containingType.Name}");
			w.Line("{");
		}

		// Class declaration with interfaces
		var interfaces = string.Join(", ", unit.InterfaceList);
		var typeParams = FormatTypeParameters(unit.TypeParameters);
		var constraints = FormatConstraints(unit.TypeParameters);

		// Calculate the class name with type parameters for delegate signatures
		var classNameWithTypeParams = $"{unit.ClassName}{typeParams}";

		using (w.Block($"partial class {unit.ClassName}{typeParams} : {interfaces}, global::KnockOff.IKnockOffStub{constraints}"))
		{
			// Track rendered interceptors to avoid duplicates
			// (Multiple interface members may map to the same interceptor)
			var renderedInterceptorClasses = new HashSet<string>();

			// Generic method interfaces if needed
			if (unit.HasGenericMethods)
				RenderGenericMethodInterfaces(w);

			// Interceptor classes (deduplicated by interceptor name)
			foreach (var prop in unit.Properties)
			{
				if (renderedInterceptorClasses.Add(prop.InterceptorClassName))
					RenderPropertyInterceptorClass(w, prop, classNameWithTypeParams);
			}

			foreach (var indexer in unit.Indexers)
			{
				if (renderedInterceptorClasses.Add(indexer.InterceptorClassName))
					RenderIndexerInterceptorClass(w, indexer, classNameWithTypeParams);
			}

			// Render method interceptor classes using groups (handles overloads)
			foreach (var group in unit.MethodGroups)
			{
				if (renderedInterceptorClasses.Add(group.InterceptorClassName))
					RenderMethodGroupInterceptorClass(w, group, classNameWithTypeParams);
			}

			// Render user-defined method interceptor classes (tracking-only, not in groups)
			foreach (var method in unit.Methods.Where(m => !m.IsGenericMethod && m.UserMethodCall != null))
			{
				if (renderedInterceptorClasses.Add(method.InterceptorClassName))
					RenderUserMethodInterceptorClass(w, method);
			}

			foreach (var handler in unit.GenericMethodHandlers)
			{
				if (renderedInterceptorClasses.Add(handler.InterceptorClassName))
					RenderGenericMethodHandler(w, handler, classNameWithTypeParams);
			}

			foreach (var evt in unit.Events)
			{
				if (renderedInterceptorClasses.Add(evt.InterceptorClassName))
					RenderEventInterceptorClass(w, evt);
			}

			// Interceptor properties (public access to interceptors)
			RenderInterceptorProperties(w, unit);

			// Standard members (Strict mode, Object accessor)
			RenderStandardMembers(w, unit);

			// Build set of interceptor names that have multiple overloads (need suffixed Invoke)
			var multiOverloadInterceptors = new HashSet<string>(
				unit.MethodGroups
					.Where(g => g.Methods.Count > 1)
					.Select(g => g.InterceptorName));

			// Explicit interface implementations (NOT deduplicated - one per interface member)
			foreach (var prop in unit.Properties)
				RenderPropertyImplementation(w, prop);

			foreach (var indexer in unit.Indexers)
				RenderIndexerImplementation(w, indexer);

			foreach (var method in unit.Methods)
				RenderMethodImplementation(w, method, multiOverloadInterceptors);

			foreach (var evt in unit.Events)
				RenderEventImplementation(w, evt);
		}

		// Close containing type wrappers for nested classes
		for (int i = 0; i < unit.ContainingTypes.Count; i++)
		{
			w.Line("}");
		}

		return w.ToString();
	}

	#region Type Parameter Formatting

	private static string FormatTypeParameters(EquatableArray<TypeParameterModel> typeParameters)
	{
		if (typeParameters.Count == 0)
			return "";

		var names = string.Join(", ", typeParameters.Select(tp => tp.Name));
		return $"<{names}>";
	}

	private static string FormatConstraints(EquatableArray<TypeParameterModel> typeParameters)
	{
		if (typeParameters.Count == 0)
			return "";

		var clauses = typeParameters
			.Where(tp => !string.IsNullOrEmpty(tp.Constraints))
			.Select(tp => $" where {tp.Name} : {tp.Constraints}");

		return string.Join("", clauses);
	}

	#endregion

	#region Generic Method Interfaces

	private static void RenderGenericMethodInterfaces(CodeWriter w)
	{
		w.Line("/// <summary>Interface for tracking calls to generic methods.</summary>");
		using (w.Block("private interface IGenericMethodCallTracker"))
		{
			w.Line("int CallCount { get; }");
			w.Line("bool WasCalled { get; }");
		}
		w.Line();

		w.Line("/// <summary>Interface for resetting state.</summary>");
		using (w.Block("private interface IResettable"))
		{
			w.Line("void Reset();");
		}
		w.Line();
	}

	#endregion

	#region Property Interceptor Class

	private static void RenderPropertyInterceptorClass(CodeWriter w, FlatPropertyModel prop, string className)
	{
		w.Line($"/// <summary>Tracks and configures behavior for {prop.MemberName}.</summary>");
		using (w.Block($"public sealed class {prop.InterceptorClassName}"))
		{
			if (prop.IsInitOnly)
			{
				RenderInitPropertyInterceptorContent(w, prop);
			}
			else
			{
				RenderRegularPropertyInterceptorContent(w, prop, className);
			}
		}
		w.Line();
	}

	private static void RenderInitPropertyInterceptorContent(CodeWriter w, FlatPropertyModel prop)
	{
		w.Line($"/// <summary>The configured value for {prop.MemberName}.</summary>");
		w.Line($"public {prop.ReturnType} Value {{ get; set; }} = default!;");
		w.Line();

		w.Line("/// <summary>Number of times the getter was accessed.</summary>");
		w.Line("public int GetCount { get; private set; }");
		w.Line();

		w.Line("/// <summary>Records a getter access.</summary>");
		w.Line("public void RecordGet() => GetCount++;");
		w.Line();

		w.Line("/// <summary>Resets all tracking state.</summary>");
		w.Line("public void Reset() { GetCount = 0; Value = default!; }");
	}

	private static void RenderRegularPropertyInterceptorContent(CodeWriter w, FlatPropertyModel prop, string className)
	{
		if (prop.HasGetter)
		{
			w.Line("/// <summary>Number of times the getter was accessed.</summary>");
			w.Line("public int GetCount { get; private set; }");
			w.Line();

			w.Line("/// <summary>Callback invoked when the getter is accessed. If set, its return value is used.</summary>");
			w.Line($"public global::System.Func<{className}, {prop.ReturnType}>? OnGet {{ get; set; }}");
			w.Line();
		}

		if (prop.HasSetter)
		{
			w.Line("/// <summary>Number of times the setter was accessed.</summary>");
			w.Line("public int SetCount { get; private set; }");
			w.Line();

			w.Line("/// <summary>The value from the most recent setter call.</summary>");
			w.Line($"public {prop.NullableReturnType} LastSetValue {{ get; private set; }}");
			w.Line();

			w.Line("/// <summary>Callback invoked when the setter is accessed.</summary>");
			w.Line($"public global::System.Action<{className}, {prop.ReturnType}>? OnSet {{ get; set; }}");
			w.Line();
		}

		// Value property for backing storage
		w.Line("/// <summary>Value returned by getter when OnGet is not set.</summary>");
		w.Line($"public {prop.ReturnType} Value {{ get; set; }}{GetDefaultValueSuffix(prop.DefaultExpression)}");
		w.Line();

		if (prop.HasGetter)
		{
			w.Line("/// <summary>Records a getter access.</summary>");
			w.Line("public void RecordGet() => GetCount++;");
			w.Line();
		}

		if (prop.HasSetter)
		{
			w.Line("/// <summary>Records a setter access.</summary>");
			w.Line($"public void RecordSet({prop.NullableReturnType} value) {{ SetCount++; LastSetValue = value; }}");
			w.Line();
		}

		w.Line("/// <summary>Resets all tracking state.</summary>");
		var resetParts = new System.Collections.Generic.List<string>();
		if (prop.HasGetter) resetParts.Add("GetCount = 0; OnGet = null;");
		if (prop.HasSetter) resetParts.Add("SetCount = 0; LastSetValue = default; OnSet = null;");
		resetParts.Add("Value = default!;");
		w.Line($"public void Reset() {{ {string.Join(" ", resetParts)} }}");
	}

	private static string GetDefaultValueSuffix(string defaultExpression)
	{
		// The DefaultExpression from the model contains the complete expression (e.g., "default!", "new List<int>()")
		// We need to convert it to an initializer format with " = " prefix and ";" suffix
		if (string.IsNullOrEmpty(defaultExpression) || defaultExpression == "default!")
			return " = default!;";

		// For NewInstance strategy, the expression will be like "new SomeType()"
		return $" = {defaultExpression};";
	}

	#endregion

	#region Indexer Interceptor Class

	private static void RenderIndexerInterceptorClass(CodeWriter w, FlatIndexerModel indexer, string className)
	{
		w.Line($"/// <summary>Tracks and configures behavior for indexer.</summary>");
		using (w.Block($"public sealed class {indexer.InterceptorClassName}"))
		{
			if (indexer.HasGetter)
			{
				w.Line("/// <summary>Number of times the getter was accessed.</summary>");
				w.Line("public int GetCount { get; private set; }");
				w.Line();

				w.Line("/// <summary>The key from the most recent getter access.</summary>");
				w.Line($"public {indexer.NullableKeyType} LastGetKey {{ get; private set; }}");
				w.Line();

				w.Line("/// <summary>Callback invoked when the getter is accessed.</summary>");
				w.Line($"public global::System.Func<{className}, {indexer.KeyType}, {indexer.ReturnType}>? OnGet {{ get; set; }}");
				w.Line();
			}

			if (indexer.HasSetter)
			{
				w.Line("/// <summary>Number of times the setter was accessed.</summary>");
				w.Line("public int SetCount { get; private set; }");
				w.Line();

				w.Line("/// <summary>The key and value from the most recent setter call.</summary>");
				w.Line($"public ({indexer.NullableKeyType} Key, {indexer.NullableReturnType} Value)? LastSetEntry {{ get; private set; }}");
				w.Line();

				w.Line("/// <summary>Callback invoked when the setter is accessed.</summary>");
				w.Line($"public global::System.Action<{className}, {indexer.KeyType}, {indexer.ReturnType}>? OnSet {{ get; set; }}");
				w.Line();
			}

			if (indexer.HasGetter)
			{
				w.Line("/// <summary>Records a getter access.</summary>");
				w.Line($"public void RecordGet({indexer.NullableKeyType} {indexer.KeyParamName}) {{ GetCount++; LastGetKey = {indexer.KeyParamName}; }}");
				w.Line();
			}

			if (indexer.HasSetter)
			{
				w.Line("/// <summary>Records a setter access.</summary>");
				w.Line($"public void RecordSet({indexer.NullableKeyType} {indexer.KeyParamName}, {indexer.NullableReturnType} value) {{ SetCount++; LastSetEntry = ({indexer.KeyParamName}, value); }}");
				w.Line();
			}

			// Backing dictionary
			w.Line($"/// <summary>Backing storage for this indexer.</summary>");
			w.Line($"public global::System.Collections.Generic.Dictionary<{indexer.KeyType}, {indexer.ReturnType}> Backing {{ get; }} = new();");
			w.Line();

			// Reset method
			w.Line("/// <summary>Resets all tracking state.</summary>");
			var resetParts = new System.Collections.Generic.List<string>();
			if (indexer.HasGetter) resetParts.Add("GetCount = 0; LastGetKey = default; OnGet = null;");
			if (indexer.HasSetter) resetParts.Add("SetCount = 0; LastSetEntry = null; OnSet = null;");
			// Note: Backing dictionary is intentionally NOT cleared - pre-populated data is preserved
			w.Line($"public void Reset() {{ {string.Join(" ", resetParts)} }}");
		}
		w.Line();
	}

	#endregion

	#region Method Interceptor Class

	private static void RenderMethodInterceptorClass(CodeWriter w, FlatMethodModel method, string className)
	{
		// User-defined methods get tracking-only interceptor
		if (method.UserMethodCall != null)
		{
			RenderUserMethodInterceptorClass(w, method);
			return;
		}

		w.Line($"/// <summary>Tracks and configures behavior for {method.MethodName}.</summary>");
		using (w.Block($"public sealed class {method.InterceptorClassName}"))
		{
			// Custom delegate if needed
			if (method.NeedsCustomDelegate && method.CustomDelegateSignature != null)
			{
				w.Line($"/// <summary>Delegate for {method.MethodName}.</summary>");
				w.Line(method.CustomDelegateSignature);
				w.Line();
			}

			// Determine tracking interface type based on parameter count
			var trackingInterface = GetTrackingInterface(method);
			var argsType = GetArgsType(method);

			// Sequence list and index
			w.Line($"private readonly global::System.Collections.Generic.List<({method.OnCallDelegateType.TrimEnd('?')} Callback, global::KnockOff.Times Times, MethodTrackingImpl Tracking)> _sequence = new();");
			w.Line("private int _sequenceIndex;");
			w.Line();

			// OnCall without Times - returns IMethodTracking, repeats forever
			w.Line($"/// <summary>Configures callback that repeats forever. Returns tracking interface.</summary>");
			w.Line($"public {trackingInterface} OnCall({method.OnCallDelegateType.TrimEnd('?')} callback)");
			using (w.Braces())
			{
				w.Line("var tracking = new MethodTrackingImpl();");
				w.Line("_sequence.Clear();");
				w.Line("_sequence.Add((callback, global::KnockOff.Times.Forever, tracking));");
				w.Line("_sequenceIndex = 0;");
				w.Line("return tracking;");
			}
			w.Line();

			// OnCall with Times - returns IMethodSequence, enables ThenCall
			w.Line($"/// <summary>Configures callback with Times constraint. Returns sequence for ThenCall chaining.</summary>");
			w.Line($"public global::KnockOff.IMethodSequence<{method.OnCallDelegateType.TrimEnd('?')}> OnCall({method.OnCallDelegateType.TrimEnd('?')} callback, global::KnockOff.Times times)");
			using (w.Braces())
			{
				w.Line("var tracking = new MethodTrackingImpl();");
				w.Line("_sequence.Clear();");
				w.Line("_sequence.Add((callback, times, tracking));");
				w.Line("_sequenceIndex = 0;");
				w.Line("return new MethodSequenceImpl(this);");
			}
			w.Line();

			// Invoke method - called by explicit interface implementation
			RenderInvokeMethod(w, method, className);

			// Reset method
			w.Line("/// <summary>Resets all tracking state.</summary>");
			using (w.Block("public void Reset()"))
			{
				w.Line("foreach (var (_, _, tracking) in _sequence)");
				w.Line("\ttracking.Reset();");
				w.Line("_sequenceIndex = 0;");
			}
			w.Line();

			// Nested MethodTrackingImpl class
			RenderMethodTrackingImpl(w, method);

			// Nested MethodSequenceImpl class
			RenderMethodSequenceImpl(w, method);
		}
		w.Line();
	}

	private static string GetTrackingInterface(FlatMethodModel method)
	{
		if (method.TrackableParameters.Count == 0)
			return "global::KnockOff.IMethodTracking";
		if (method.TrackableParameters.Count == 1)
		{
			var param = method.TrackableParameters.GetArray()![0];
			return $"global::KnockOff.IMethodTracking<{param.Type}>";
		}
		return $"global::KnockOff.IMethodTrackingArgs<{method.LastCallType}>";
	}

	private static string GetArgsType(FlatMethodModel method)
	{
		if (method.TrackableParameters.Count == 0)
			return "";
		if (method.TrackableParameters.Count == 1)
		{
			var param = method.TrackableParameters.GetArray()![0];
			return param.Type;
		}
		return method.LastCallType ?? "";
	}

	private static void RenderInvokeMethod(CodeWriter w, FlatMethodModel method, string className)
	{
		// Build parameter list for Invoke (includes strict parameter)
		var invokeParams = method.Parameters.Count > 0
			? $"{className} ko, bool strict, " + string.Join(", ", method.Parameters.Select(p => $"{p.RefPrefix}{p.Type} {p.EscapedName}"))
			: $"{className} ko, bool strict";

		var returnType = method.IsVoid ? "void" : method.ReturnType;

		w.Line($"/// <summary>Invokes the configured callback. Called by explicit interface implementation.</summary>");
		w.Line($"internal {returnType} Invoke({invokeParams})");
		using (w.Braces())
		{
			// Initialize out parameters (must be done before any return)
			foreach (var p in method.Parameters.Where(p => p.RefKind == Microsoft.CodeAnalysis.RefKind.Out))
			{
				w.Line($"{p.EscapedName} = default!;");
			}

			// Build args tuple for tracking
			var trackingArgs = BuildTrackingArgs(method);

			// No sequence configured
			w.Line("if (_sequence.Count == 0)");
			using (w.Braces())
			{
				w.Line($"if (strict) throw global::KnockOff.StubException.NotConfigured(\"\", \"{method.MethodName}\");");
				if (method.IsVoid)
					w.Line("return;");
				else
				{
					var defaultExpr = string.IsNullOrEmpty(method.DefaultExpression) ? "default!" : method.DefaultExpression;
					w.Line($"return {defaultExpr};");
				}
			}
			w.Line();

			// Get current callback from sequence
			w.Line("var (callback, times, tracking) = _sequence[_sequenceIndex];");
			w.Line($"tracking.RecordCall({trackingArgs});");
			w.Line();

			// Advance sequence if times exhausted (and not Forever)
			w.Line("if (!times.IsForever && tracking.CallCount >= times.Count)");
			using (w.Braces())
			{
				w.Line("if (_sequenceIndex < _sequence.Count - 1)");
				w.Line("\t_sequenceIndex++;");
				w.Line("else if (tracking.CallCount > times.Count)");
				w.Line($"\tthrow global::KnockOff.StubException.SequenceExhausted(\"{method.MethodName}\");");
			}
			w.Line();

			// Invoke callback
			var callbackArgs = method.Parameters.Count > 0
				? "ko, " + string.Join(", ", method.Parameters.Select(p => $"{p.RefPrefix}{p.EscapedName}"))
				: "ko";

			if (method.IsVoid)
				w.Line($"callback({callbackArgs});");
			else
				w.Line($"return callback({callbackArgs});");
		}
		w.Line();
	}

	private static string BuildTrackingArgs(FlatMethodModel method)
	{
		if (method.TrackableParameters.Count == 0)
			return "";
		if (method.TrackableParameters.Count == 1)
		{
			var param = method.TrackableParameters.GetArray()![0];
			return param.EscapedName;
		}
		return "(" + string.Join(", ", method.TrackableParameters.Select(p => p.EscapedName)) + ")";
	}

	private static void RenderMethodTrackingImpl(CodeWriter w, FlatMethodModel method)
	{
		var trackingInterface = GetTrackingInterface(method);

		w.Line($"/// <summary>Tracks invocations for this callback registration.</summary>");
		w.Line($"private sealed class MethodTrackingImpl : {trackingInterface}");
		using (w.Braces())
		{
			// LastArg/LastArgs storage (non-nullable to match interface)
			if (method.TrackableParameters.Count == 1)
			{
				var param = method.TrackableParameters.GetArray()![0];
				w.Line($"private {param.Type} _lastArg = default!;");
			}
			else if (method.TrackableParameters.Count > 1)
			{
				w.Line($"private {method.LastCallType} _lastArgs;");
			}
			w.Line();

			// CallCount property
			w.Line("/// <summary>Number of times this callback was invoked.</summary>");
			w.Line("public int CallCount { get; private set; }");
			w.Line();

			// WasCalled property
			w.Line("/// <summary>True if CallCount > 0.</summary>");
			w.Line("public bool WasCalled => CallCount > 0;");
			w.Line();

			// LastArg/LastArgs property (non-nullable to match interface)
			if (method.TrackableParameters.Count == 1)
			{
				var param = method.TrackableParameters.GetArray()![0];
				w.Line($"/// <summary>Last argument passed to this callback. Default if never called.</summary>");
				w.Line($"public {param.Type} LastArg => _lastArg;");
				w.Line();
			}
			else if (method.TrackableParameters.Count > 1)
			{
				w.Line($"/// <summary>Last arguments passed to this callback. Default if never called.</summary>");
				w.Line($"public {method.LastCallType} LastArgs => _lastArgs;");
				w.Line();
			}

			// RecordCall method
			w.Line("/// <summary>Records a call to this callback.</summary>");
			if (method.TrackableParameters.Count == 0)
			{
				w.Line("public void RecordCall() => CallCount++;");
			}
			else if (method.TrackableParameters.Count == 1)
			{
				var param = method.TrackableParameters.GetArray()![0];
				w.Line($"public void RecordCall({param.Type} {param.EscapedName}) {{ CallCount++; _lastArg = {param.EscapedName}; }}");
			}
			else
			{
				w.Line($"public void RecordCall({method.LastCallType} args) {{ CallCount++; _lastArgs = args; }}");
			}
			w.Line();

			// Reset method
			w.Line("/// <summary>Resets tracking state.</summary>");
			if (method.TrackableParameters.Count == 0)
			{
				w.Line("public void Reset() => CallCount = 0;");
			}
			else if (method.TrackableParameters.Count == 1)
			{
				w.Line("public void Reset() { CallCount = 0; _lastArg = default!; }");
			}
			else
			{
				w.Line("public void Reset() { CallCount = 0; _lastArgs = default; }");
			}
		}
		w.Line();
	}

	private static void RenderMethodSequenceImpl(CodeWriter w, FlatMethodModel method)
	{
		var delegateType = method.OnCallDelegateType.TrimEnd('?');

		w.Line($"/// <summary>Sequence implementation for ThenCall chaining.</summary>");
		w.Line($"private sealed class MethodSequenceImpl : global::KnockOff.IMethodSequence<{delegateType}>");
		using (w.Braces())
		{
			w.Line($"private readonly {method.InterceptorClassName} _interceptor;");
			w.Line();

			w.Line($"public MethodSequenceImpl({method.InterceptorClassName} interceptor) => _interceptor = interceptor;");
			w.Line();

			// TotalCallCount
			w.Line("/// <summary>Total calls across all callbacks in sequence.</summary>");
			w.Line("public int TotalCallCount");
			using (w.Braces())
			{
				w.Line("get");
				using (w.Braces())
				{
					w.Line("var total = 0;");
					w.Line("foreach (var (_, _, tracking) in _interceptor._sequence)");
					w.Line("\ttotal += tracking.CallCount;");
					w.Line("return total;");
				}
			}
			w.Line();

			// ThenCall
			w.Line($"/// <summary>Add another callback to the sequence.</summary>");
			w.Line($"public global::KnockOff.IMethodSequence<{delegateType}> ThenCall({delegateType} callback, global::KnockOff.Times times)");
			using (w.Braces())
			{
				w.Line("var tracking = new MethodTrackingImpl();");
				w.Line("_interceptor._sequence.Add((callback, times, tracking));");
				w.Line("return this;");
			}
			w.Line();

			// Verify
			w.Line("/// <summary>Verify all Times constraints in the sequence were satisfied.</summary>");
			w.Line("public bool Verify()");
			using (w.Braces())
			{
				w.Line("foreach (var (_, times, tracking) in _interceptor._sequence)");
				using (w.Braces())
				{
					w.Line("if (!times.Verify(tracking.CallCount))");
					w.Line("\treturn false;");
				}
				w.Line("return true;");
			}
			w.Line();

			// Reset
			w.Line("/// <summary>Reset all tracking in the sequence.</summary>");
			w.Line("public void Reset() => _interceptor.Reset();");
		}
	}

	/// <summary>
	/// Renders an interceptor class for a method group (handles single methods and overloads).
	/// For groups with multiple methods, generates per-signature delegates, sequences, and OnCall overloads.
	/// </summary>
	private static void RenderMethodGroupInterceptorClass(CodeWriter w, FlatMethodGroup group, string className)
	{
		// If only one method in group, use simpler single-method pattern
		if (group.Methods.Count == 1)
		{
			RenderMethodInterceptorClass(w, group.Methods.GetArray()![0], className);
			return;
		}

		// Deduplicate methods by signature suffix
		// Multiple interface methods with identical signatures (same params AND return type)
		// should generate only one set of interceptor members
		var renderedSuffixes = new HashSet<string>();
		var uniqueMethods = new List<FlatMethodModel>();
		foreach (var method in group.Methods)
		{
			var suffix = GetSignatureSuffix(method);
			if (renderedSuffixes.Add(suffix))
			{
				uniqueMethods.Add(method);
			}
		}

		// If after deduplication we only have one unique signature, use single-method pattern
		if (uniqueMethods.Count == 1)
		{
			RenderMethodInterceptorClass(w, uniqueMethods[0], className);
			return;
		}

		var firstMethod = group.Methods.GetArray()![0];
		w.Line($"/// <summary>Tracks and configures behavior for {firstMethod.MethodName} (overloaded).</summary>");
		using (w.Block($"public sealed class {group.InterceptorClassName}"))
		{
			// Generate delegates and sequences for each unique overload
			foreach (var method in uniqueMethods)
			{
				var suffix = GetSignatureSuffix(method);

				// Delegate
				w.Line($"/// <summary>Delegate for {method.MethodName}({GetParamTypeList(method)}).</summary>");
				w.Line($"public delegate {(method.IsVoid ? "void" : method.ReturnType)} {method.MethodName}Delegate_{suffix}({className} ko{(method.Parameters.Count > 0 ? ", " : "")}{method.ParameterDeclarations});");
				w.Line();

				// Sequence list
				w.Line($"private readonly global::System.Collections.Generic.List<({method.MethodName}Delegate_{suffix} Callback, global::KnockOff.Times Times, MethodTrackingImpl_{suffix} Tracking)> _sequence_{suffix} = new();");
				w.Line($"private int _sequenceIndex_{suffix};");
				w.Line();
			}

			// OnCall overloads for each unique signature
			foreach (var method in uniqueMethods)
			{
				var suffix = GetSignatureSuffix(method);
				var trackingInterface = GetTrackingInterface(method);

				// OnCall without Times
				w.Line($"/// <summary>Configures callback for {method.MethodName}({GetParamTypeList(method)}). Returns tracking interface.</summary>");
				w.Line($"public {trackingInterface} OnCall({method.MethodName}Delegate_{suffix} callback)");
				using (w.Braces())
				{
					w.Line($"var tracking = new MethodTrackingImpl_{suffix}();");
					w.Line($"_sequence_{suffix}.Clear();");
					w.Line($"_sequence_{suffix}.Add((callback, global::KnockOff.Times.Forever, tracking));");
					w.Line($"_sequenceIndex_{suffix} = 0;");
					w.Line("return tracking;");
				}
				w.Line();

				// OnCall with Times
				w.Line($"/// <summary>Configures callback for {method.MethodName}({GetParamTypeList(method)}) with Times constraint.</summary>");
				w.Line($"public global::KnockOff.IMethodSequence<{method.MethodName}Delegate_{suffix}> OnCall({method.MethodName}Delegate_{suffix} callback, global::KnockOff.Times times)");
				using (w.Braces())
				{
					w.Line($"var tracking = new MethodTrackingImpl_{suffix}();");
					w.Line($"_sequence_{suffix}.Clear();");
					w.Line($"_sequence_{suffix}.Add((callback, times, tracking));");
					w.Line($"_sequenceIndex_{suffix} = 0;");
					w.Line($"return new MethodSequenceImpl_{suffix}(this);");
				}
				w.Line();
			}

			// Invoke methods for each unique signature
			foreach (var method in uniqueMethods)
			{
				RenderGroupInvokeMethod(w, method, className);
			}

			// Reset method (resets all unique sequences)
			w.Line("/// <summary>Resets all tracking state for all overloads.</summary>");
			using (w.Block("public void Reset()"))
			{
				foreach (var method in uniqueMethods)
				{
					var suffix = GetSignatureSuffix(method);
					w.Line($"foreach (var (_, _, tracking) in _sequence_{suffix})");
					w.Line("\ttracking.Reset();");
					w.Line($"_sequenceIndex_{suffix} = 0;");
				}
			}
			w.Line();

			// Verify method
			w.Line("/// <summary>Verifies all Times constraints for all overloads were satisfied.</summary>");
			using (w.Block("public bool Verify()"))
			{
				foreach (var method in uniqueMethods)
				{
					var suffix = GetSignatureSuffix(method);
					w.Line($"foreach (var (_, times, tracking) in _sequence_{suffix})");
					using (w.Braces())
					{
						w.Line("if (!times.Verify(tracking.CallCount))");
						w.Line("\treturn false;");
					}
				}
				w.Line("return true;");
			}
			w.Line();

			// Nested tracking classes for each unique signature
			foreach (var method in uniqueMethods)
			{
				RenderGroupMethodTrackingImpl(w, method);
			}

			// Nested sequence classes for each unique signature
			foreach (var method in uniqueMethods)
			{
				RenderGroupMethodSequenceImpl(w, method, group.InterceptorClassName);
			}
		}
		w.Line();
	}

	private static string GetSignatureSuffix(FlatMethodModel method)
	{
		var returnSuffix = GetTypeSuffix(method.ReturnType);
		if (method.Parameters.Count == 0)
			return $"NoParams_{returnSuffix}";
		return string.Join("_", method.Parameters.Select(p => GetTypeSuffix(p.Type))) + $"_{returnSuffix}";
	}

	private static string GetTypeSuffix(string type)
	{
		// Extract simple type name: "global::System.String" -> "String", "int" -> "Int32"
		var simple = type.Replace("global::", "").Replace("System.", "");
		simple = simple switch
		{
			"int" => "Int32",
			"string" => "String",
			"bool" => "Boolean",
			"long" => "Int64",
			"double" => "Double",
			"float" => "Single",
			"decimal" => "Decimal",
			"char" => "Char",
			"byte" => "Byte",
			_ => simple.Replace(".", "_").Replace("<", "_").Replace(">", "").Replace(",", "_").Replace(" ", "")
		};
		return simple.TrimEnd('?');
	}

	private static string GetParamTypeList(FlatMethodModel method)
	{
		return string.Join(", ", method.Parameters.Select(p => p.Type));
	}

	private static void RenderGroupInvokeMethod(CodeWriter w, FlatMethodModel method, string className)
	{
		var suffix = GetSignatureSuffix(method);
		var invokeParams = method.Parameters.Count > 0
			? $"{className} ko, bool strict, " + string.Join(", ", method.Parameters.Select(p => $"{p.RefPrefix}{p.Type} {p.EscapedName}"))
			: $"{className} ko, bool strict";
		var returnType = method.IsVoid ? "void" : method.ReturnType;

		w.Line($"/// <summary>Invokes configured callback for {method.MethodName}({GetParamTypeList(method)}).</summary>");
		w.Line($"internal {returnType} Invoke_{suffix}({invokeParams})");
		using (w.Braces())
		{
			// Initialize out parameters
			foreach (var p in method.Parameters.Where(p => p.RefKind == Microsoft.CodeAnalysis.RefKind.Out))
			{
				w.Line($"{p.EscapedName} = default!;");
			}

			var trackingArgs = BuildTrackingArgs(method);

			w.Line($"if (_sequence_{suffix}.Count == 0)");
			using (w.Braces())
			{
				w.Line($"if (strict) throw global::KnockOff.StubException.NotConfigured(\"\", \"{method.MethodName}\");");
				if (method.IsVoid)
					w.Line("return;");
				else
				{
					var defaultExpr = string.IsNullOrEmpty(method.DefaultExpression) ? "default!" : method.DefaultExpression;
					w.Line($"return {defaultExpr};");
				}
			}
			w.Line();

			w.Line($"var (callback, times, tracking) = _sequence_{suffix}[_sequenceIndex_{suffix}];");
			w.Line($"tracking.RecordCall({trackingArgs});");
			w.Line();

			w.Line("if (!times.IsForever && tracking.CallCount >= times.Count)");
			using (w.Braces())
			{
				w.Line($"if (_sequenceIndex_{suffix} < _sequence_{suffix}.Count - 1)");
				w.Line($"\t_sequenceIndex_{suffix}++;");
				w.Line("else if (tracking.CallCount > times.Count)");
				w.Line($"\tthrow global::KnockOff.StubException.SequenceExhausted(\"{method.MethodName}\");");
			}
			w.Line();

			var callbackArgs = method.Parameters.Count > 0
				? "ko, " + string.Join(", ", method.Parameters.Select(p => $"{p.RefPrefix}{p.EscapedName}"))
				: "ko";

			if (method.IsVoid)
				w.Line($"callback({callbackArgs});");
			else
				w.Line($"return callback({callbackArgs});");
		}
		w.Line();
	}

	private static void RenderGroupMethodTrackingImpl(CodeWriter w, FlatMethodModel method)
	{
		var suffix = GetSignatureSuffix(method);
		var trackingInterface = GetTrackingInterface(method);

		w.Line($"private sealed class MethodTrackingImpl_{suffix} : {trackingInterface}");
		using (w.Braces())
		{
			if (method.TrackableParameters.Count == 1)
			{
				var param = method.TrackableParameters.GetArray()![0];
				w.Line($"private {param.Type} _lastArg = default!;");
			}
			else if (method.TrackableParameters.Count > 1)
			{
				w.Line($"private {method.LastCallType} _lastArgs;");
			}
			w.Line();

			w.Line("public int CallCount { get; private set; }");
			w.Line();
			w.Line("public bool WasCalled => CallCount > 0;");
			w.Line();

			if (method.TrackableParameters.Count == 1)
			{
				var param = method.TrackableParameters.GetArray()![0];
				w.Line($"public {param.Type} LastArg => _lastArg;");
				w.Line();
			}
			else if (method.TrackableParameters.Count > 1)
			{
				w.Line($"public {method.LastCallType} LastArgs => _lastArgs;");
				w.Line();
			}

			if (method.TrackableParameters.Count == 0)
			{
				w.Line("public void RecordCall() => CallCount++;");
			}
			else if (method.TrackableParameters.Count == 1)
			{
				var param = method.TrackableParameters.GetArray()![0];
				w.Line($"public void RecordCall({param.Type} {param.EscapedName}) {{ CallCount++; _lastArg = {param.EscapedName}; }}");
			}
			else
			{
				w.Line($"public void RecordCall({method.LastCallType} args) {{ CallCount++; _lastArgs = args; }}");
			}
			w.Line();

			if (method.TrackableParameters.Count == 0)
				w.Line("public void Reset() => CallCount = 0;");
			else if (method.TrackableParameters.Count == 1)
				w.Line("public void Reset() { CallCount = 0; _lastArg = default!; }");
			else
				w.Line("public void Reset() { CallCount = 0; _lastArgs = default; }");
		}
		w.Line();
	}

	private static void RenderGroupMethodSequenceImpl(CodeWriter w, FlatMethodModel method, string interceptorClassName)
	{
		var suffix = GetSignatureSuffix(method);
		var delegateType = $"{method.MethodName}Delegate_{suffix}";

		w.Line($"private sealed class MethodSequenceImpl_{suffix} : global::KnockOff.IMethodSequence<{delegateType}>");
		using (w.Braces())
		{
			w.Line($"private readonly {interceptorClassName} _interceptor;");
			w.Line();
			w.Line($"public MethodSequenceImpl_{suffix}({interceptorClassName} interceptor) => _interceptor = interceptor;");
			w.Line();

			w.Line("public int TotalCallCount");
			using (w.Braces())
			{
				w.Line("get");
				using (w.Braces())
				{
					w.Line("var total = 0;");
					w.Line($"foreach (var (_, _, tracking) in _interceptor._sequence_{suffix})");
					w.Line("\ttotal += tracking.CallCount;");
					w.Line("return total;");
				}
			}
			w.Line();

			w.Line($"public global::KnockOff.IMethodSequence<{delegateType}> ThenCall({delegateType} callback, global::KnockOff.Times times)");
			using (w.Braces())
			{
				w.Line($"var tracking = new MethodTrackingImpl_{suffix}();");
				w.Line($"_interceptor._sequence_{suffix}.Add((callback, times, tracking));");
				w.Line("return this;");
			}
			w.Line();

			w.Line("public bool Verify()");
			using (w.Braces())
			{
				w.Line($"foreach (var (_, times, tracking) in _interceptor._sequence_{suffix})");
				using (w.Braces())
				{
					w.Line("if (!times.Verify(tracking.CallCount))");
					w.Line("\treturn false;");
				}
				w.Line("return true;");
			}
			w.Line();

			w.Line("public void Reset() => _interceptor.Reset();");
		}
		w.Line();
	}

	/// <summary>
	/// Renders a tracking-only interceptor for user-defined methods.
	/// No OnCall methods - the user's method is used directly.
	/// </summary>
	private static void RenderUserMethodInterceptorClass(CodeWriter w, FlatMethodModel method)
	{
		var trackingInterface = GetTrackingInterface(method);

		w.Line($"/// <summary>Tracks calls to {method.MethodName} (user-defined implementation).</summary>");
		w.Line($"public sealed class {method.InterceptorClassName} : {trackingInterface}");
		using (w.Braces())
		{
			// LastArg/LastArgs storage (non-nullable to match interface)
			if (method.TrackableParameters.Count == 1)
			{
				var param = method.TrackableParameters.GetArray()![0];
				w.Line($"private {param.Type} _lastArg = default!;");
			}
			else if (method.TrackableParameters.Count > 1)
			{
				w.Line($"private {method.LastCallType} _lastArgs;");
			}
			w.Line();

			// CallCount property
			w.Line("/// <summary>Number of times this method was called.</summary>");
			w.Line("public int CallCount { get; private set; }");
			w.Line();

			// WasCalled property
			w.Line("/// <summary>True if CallCount > 0.</summary>");
			w.Line("public bool WasCalled => CallCount > 0;");
			w.Line();

			// LastArg/LastArgs property (non-nullable to match interface)
			if (method.TrackableParameters.Count == 1)
			{
				var param = method.TrackableParameters.GetArray()![0];
				w.Line($"/// <summary>Last argument passed to this method. Default if never called.</summary>");
				w.Line($"public {param.Type} LastArg => _lastArg;");
				w.Line();
			}
			else if (method.TrackableParameters.Count > 1)
			{
				w.Line($"/// <summary>Last arguments passed to this method. Default if never called.</summary>");
				w.Line($"public {method.LastCallType} LastArgs => _lastArgs;");
				w.Line();
			}

			// RecordCall method (internal, called by generated code)
			w.Line("/// <summary>Records a method call.</summary>");
			if (method.TrackableParameters.Count == 0)
			{
				w.Line("internal void RecordCall() => CallCount++;");
			}
			else if (method.TrackableParameters.Count == 1)
			{
				var param = method.TrackableParameters.GetArray()![0];
				w.Line($"internal void RecordCall({param.Type} {param.EscapedName}) {{ CallCount++; _lastArg = {param.EscapedName}; }}");
			}
			else
			{
				w.Line($"internal void RecordCall({method.LastCallType} args) {{ CallCount++; _lastArgs = args; }}");
			}
			w.Line();

			// Reset method
			w.Line("/// <summary>Resets tracking state.</summary>");
			if (method.TrackableParameters.Count == 0)
			{
				w.Line("public void Reset() => CallCount = 0;");
			}
			else if (method.TrackableParameters.Count == 1)
			{
				w.Line("public void Reset() { CallCount = 0; _lastArg = default!; }");
			}
			else
			{
				w.Line("public void Reset() { CallCount = 0; _lastArgs = default; }");
			}
		}
		w.Line();
	}

	#endregion

	#region Generic Method Handler

	private static void RenderGenericMethodHandler(CodeWriter w, FlatGenericMethodHandlerModel handler, string className)
	{
		w.Line($"/// <summary>Interceptor for {handler.MethodName} (generic method with Of&lt;T&gt;() access).</summary>");
		using (w.Block($"public sealed class {handler.InterceptorClassName}"))
		{
			// Dictionary for typed handlers
			w.Line($"private readonly global::System.Collections.Generic.Dictionary<{handler.KeyType}, object> _typedHandlers = new();");
			w.Line();

			// Of<T>() method
			w.Line($"/// <summary>Gets the typed handler for the specified type argument(s).</summary>");
			w.Line($"public {handler.TypedHandlerClassName}<{handler.TypeParameterNames}> Of<{handler.TypeParameterNames}>(){handler.ConstraintClauses}");
			using (w.Braces())
			{
				w.Line($"var key = {handler.KeyConstruction};");
				w.Line($"if (!_typedHandlers.TryGetValue(key, out var handler))");
				using (w.Braces())
				{
					w.Line($"handler = new {handler.TypedHandlerClassName}<{handler.TypeParameterNames}>();");
					w.Line("_typedHandlers[key] = handler;");
				}
				w.Line($"return ({handler.TypedHandlerClassName}<{handler.TypeParameterNames}>)handler;");
			}
			w.Line();

			// Aggregate tracking
			w.Line("/// <summary>Total number of calls across all type arguments.</summary>");
			w.Line("public int TotalCallCount => _typedHandlers.Values.Sum(h => ((IGenericMethodCallTracker)h).CallCount);");
			w.Line();
			w.Line("/// <summary>True if this method was called with any type argument.</summary>");
			w.Line("public bool WasCalled => _typedHandlers.Values.Any(h => ((IGenericMethodCallTracker)h).WasCalled);");
			w.Line();
			w.Line($"/// <summary>All type argument(s) that were used in calls.</summary>");
			w.Line($"public global::System.Collections.Generic.IReadOnlyList<{handler.KeyType}> CalledTypeArguments => _typedHandlers.Keys.ToList();");
			w.Line();

			// Reset method
			w.Line("/// <summary>Resets all typed handlers.</summary>");
			using (w.Block("public void Reset()"))
			{
				w.Line("foreach (var handler in _typedHandlers.Values)");
				w.Line("\t((IResettable)handler).Reset();");
				w.Line("_typedHandlers.Clear();");
			}
			w.Line();

			// Nested Typed Handler Class
			RenderTypedHandlerClass(w, handler, className);
		}
		w.Line();
	}

	private static void RenderTypedHandlerClass(CodeWriter w, FlatGenericMethodHandlerModel handler, string className)
	{
		w.Line($"/// <summary>Typed handler for {handler.MethodName} with specific type arguments.</summary>");
		w.Line($"public sealed class {handler.TypedHandlerClassName}<{handler.TypeParameterNames}> : IGenericMethodCallTracker, IResettable{handler.ConstraintClauses}");
		using (w.Braces())
		{
			// Delegate
			w.Line($"/// <summary>Delegate for {handler.MethodName}.</summary>");
			w.Line(handler.DelegateSignature);
			w.Line();

			// CallCount
			w.Line("/// <summary>Number of times this method was called with these type arguments.</summary>");
			w.Line("public int CallCount { get; private set; }");
			w.Line();

			// LastCallArg/LastCallArgs
			if (handler.NonGenericParams.Count == 1)
			{
				var param = handler.NonGenericParams.GetArray()![0];
				w.Line($"/// <summary>The '{param.Name}' argument from the most recent call.</summary>");
				w.Line($"public {param.NullableType} LastCallArg {{ get; private set; }}");
				w.Line();
			}
			else if (handler.NonGenericParams.Count > 1)
			{
				w.Line("/// <summary>The arguments from the most recent call.</summary>");
				w.Line($"public {handler.LastCallType}? LastCallArgs {{ get; private set; }}");
				w.Line();
			}

			// WasCalled
			w.Line("/// <summary>True if this method was called at least once with these type arguments.</summary>");
			w.Line("public bool WasCalled => CallCount > 0;");
			w.Line();

			// OnCall
			w.Line("/// <summary>Callback invoked when this method is called. If set, its return value is used.</summary>");
			w.Line($"public {handler.MethodName}Delegate? OnCall {{ get; set; }}");
			w.Line();

			// RecordCall
			w.Line("/// <summary>Records a method call.</summary>");
			if (handler.NonGenericParams.Count == 0)
			{
				w.Line("public void RecordCall() => CallCount++;");
			}
			else if (handler.NonGenericParams.Count == 1)
			{
				var param = handler.NonGenericParams.GetArray()![0];
				w.Line($"public void RecordCall({param.NullableType} {param.EscapedName}) {{ CallCount++; LastCallArg = {param.EscapedName}; }}");
			}
			else
			{
				var paramList = string.Join(", ", handler.NonGenericParams.Select(p => $"{p.NullableType} {p.EscapedName}"));
				var tupleConstruction = string.Join(", ", handler.NonGenericParams.Select(p => p.EscapedName));
				w.Line($"public void RecordCall({paramList}) {{ CallCount++; LastCallArgs = ({tupleConstruction}); }}");
			}
			w.Line();

			// Reset
			w.Line("/// <summary>Resets all tracking state.</summary>");
			if (handler.NonGenericParams.Count == 0)
			{
				w.Line("public void Reset() { CallCount = 0; OnCall = null; }");
			}
			else if (handler.NonGenericParams.Count == 1)
			{
				w.Line("public void Reset() { CallCount = 0; LastCallArg = default; OnCall = null; }");
			}
			else
			{
				w.Line("public void Reset() { CallCount = 0; LastCallArgs = default; OnCall = null; }");
			}
		}
	}

	#endregion

	#region Event Interceptor Class

	private static void RenderEventInterceptorClass(CodeWriter w, FlatEventModel evt)
	{
		w.Line($"/// <summary>Interceptor for {evt.EventName} event.</summary>");
		using (w.Block($"public sealed class {evt.InterceptorClassName}"))
		{
			// Backing field
			w.Line($"private {evt.DelegateType}? _handler;");
			w.Line();

			// Add/Remove tracking
			w.Line("/// <summary>Number of times event was subscribed to.</summary>");
			w.Line("public int AddCount { get; private set; }");
			w.Line();

			w.Line("/// <summary>Number of times event subscription was removed.</summary>");
			w.Line("public int RemoveCount { get; private set; }");
			w.Line();

			w.Line("/// <summary>Whether any handlers are subscribed.</summary>");
			w.Line("public bool HasSubscribers => _handler != null;");
			w.Line();

			// RecordAdd/RecordRemove
			w.Line($"/// <summary>Records an event subscription.</summary>");
			w.Line($"public void RecordAdd({evt.DelegateType}? value) {{ AddCount++; _handler = ({evt.DelegateType}?)global::System.Delegate.Combine(_handler, value); }}");
			w.Line();

			w.Line($"/// <summary>Records an event unsubscription.</summary>");
			w.Line($"public void RecordRemove({evt.DelegateType}? value) {{ RemoveCount++; _handler = ({evt.DelegateType}?)global::System.Delegate.Remove(_handler, value); }}");
			w.Line();

			// Raise method
			RenderEventRaiseMethod(w, evt);

			// Reset
			w.Line("/// <summary>Resets all tracking state.</summary>");
			w.Line("public void Reset() { AddCount = 0; RemoveCount = 0; _handler = null; }");
		}
		w.Line();
	}

	private static void RenderEventRaiseMethod(CodeWriter w, FlatEventModel evt)
	{
		if (evt.RaiseReturnsValue)
		{
			// Func-style delegate
			w.Line("/// <summary>Raises the event with the specified arguments and returns the result.</summary>");
			if (string.IsNullOrEmpty(evt.RaiseParameters))
			{
				w.Line($"public {evt.RaiseReturnType} Raise() => _handler != null ? _handler.Invoke() : default!;");
			}
			else
			{
				w.Line($"public {evt.RaiseReturnType} Raise({evt.RaiseParameters}) => _handler != null ? _handler.Invoke({evt.RaiseArguments}) : default!;");
			}
		}
		else if (evt.UsesDynamicInvoke)
		{
			// Custom delegate - use DynamicInvoke
			if (string.IsNullOrEmpty(evt.RaiseParameters))
			{
				w.Line("/// <summary>Raises the event.</summary>");
				w.Line("public void Raise() => (_handler as global::System.Action)?.Invoke();");
			}
			else
			{
				w.Line("/// <summary>Invokes the handler if subscribed.</summary>");
				w.Line($"public void Raise({evt.RaiseParameters}) => _handler?.DynamicInvoke({evt.RaiseArguments});");
			}
		}
		else
		{
			// Standard Action/EventHandler
			if (string.IsNullOrEmpty(evt.RaiseParameters))
			{
				w.Line("/// <summary>Raises the event.</summary>");
				w.Line("public void Raise() => _handler?.Invoke();");
			}
			else
			{
				w.Line("/// <summary>Raises the event with the specified arguments.</summary>");
				w.Line($"public void Raise({evt.RaiseParameters}) => _handler?.Invoke({evt.RaiseArguments});");
			}
		}
		w.Line();
	}

	#endregion

	#region Interceptor Properties

	private static void RenderInterceptorProperties(CodeWriter w, FlatGenerationUnit unit)
	{
		// Track rendered interceptor properties to avoid duplicates
		var renderedProperties = new HashSet<string>();

		// Properties
		foreach (var prop in unit.Properties)
		{
			if (!renderedProperties.Add(prop.InterceptorName))
				continue;
			var newKeyword = prop.NeedsNewKeyword ? "new " : "";
			w.Line($"/// <summary>Interceptor for {prop.MemberName}. Configure via .Value, track via .GetCount.</summary>");
			w.Line($"public {newKeyword}{prop.InterceptorClassName} {prop.InterceptorName} {{ get; }} = new();");
			w.Line();
		}

		// Indexers
		foreach (var indexer in unit.Indexers)
		{
			if (!renderedProperties.Add(indexer.InterceptorName))
				continue;
			var newKeyword = indexer.NeedsNewKeyword ? "new " : "";
			w.Line($"/// <summary>Interceptor for indexer. Configure callbacks and track access.</summary>");
			w.Line($"public {newKeyword}{indexer.InterceptorClassName} {indexer.InterceptorName} {{ get; }} = new();");
			w.Line();
		}

		// Methods (only non-generic - generic methods use handler properties)
		foreach (var method in unit.Methods.Where(m => !m.IsGenericMethod))
		{
			if (!renderedProperties.Add(method.InterceptorName))
				continue;
			var newKeyword = method.NeedsNewKeyword ? "new " : "";
			w.Line($"/// <summary>Interceptor for {method.MethodName}.</summary>");
			w.Line($"public {newKeyword}{method.InterceptorClassName} {method.InterceptorName} {{ get; }} = new();");
			w.Line();
		}

		// Generic method handlers
		foreach (var handler in unit.GenericMethodHandlers)
		{
			if (!renderedProperties.Add(handler.InterceptorName))
				continue;
			var newKeyword = handler.NeedsNewKeyword ? "new " : "";
			w.Line($"/// <summary>Interceptor for {handler.MethodName} (generic method).</summary>");
			w.Line($"public {newKeyword}{handler.InterceptorClassName} {handler.InterceptorName} {{ get; }} = new();");
			w.Line();
		}

		// Events
		foreach (var evt in unit.Events)
		{
			if (!renderedProperties.Add(evt.InterceptorName))
				continue;
			var newKeyword = evt.NeedsNewKeyword ? "new " : "";
			w.Line($"/// <summary>Interceptor for {evt.EventName} event.</summary>");
			w.Line($"public {newKeyword}{evt.InterceptorClassName} {evt.InterceptorName} {{ get; }} = new();");
			w.Line();
		}
	}

	#endregion

	#region Standard Members

	private static void RenderStandardMembers(CodeWriter w, FlatGenerationUnit unit)
	{
		// Strict mode property with configurable default
		var strictDefault = unit.Strict ? "true" : "false";
		w.Line("/// <summary>When true, throws StubException for unconfigured member access.</summary>");
		w.Line($"public bool Strict {{ get; set; }} = {strictDefault};");
		w.Line();

		// Object accessor - returns the first interface type
		var typeParams = FormatTypeParameters(unit.TypeParameters);
		var primaryInterface = unit.InterfaceList.Count > 0 ? unit.InterfaceList.GetArray()![0] : $"{unit.ClassName}{typeParams}";
		w.Line($"/// <summary>The {primaryInterface} instance. Use for passing to code expecting the interface.</summary>");
		w.Line($"public {primaryInterface} Object => this;");
		w.Line();

		// SmartDefault helper (only if there are generic methods)
		if (unit.HasGenericMethods)
		{
			RenderSmartDefaultMethod(w);
		}
	}

	private static void RenderSmartDefaultMethod(CodeWriter w)
	{
		w.Line("/// <summary>Gets a smart default value for a generic type at runtime.</summary>");
		using (w.Block("private static T SmartDefault<T>(string methodName)"))
		{
			w.Line("var type = typeof(T);");
			w.Line();
			w.Line("// Value types -> default(T)");
			w.Line("if (type.IsValueType)");
			w.Line("\treturn default!;");
			w.Line();
			w.Line("// Check for parameterless constructor");
			w.Line("var ctor = type.GetConstructor(");
			w.Line("\tSystem.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance,");
			w.Line("\tnull, System.Type.EmptyTypes, null);");
			w.Line();
			w.Line("if (ctor != null)");
			w.Line("\treturn (T)ctor.Invoke(null);");
			w.Line();
			w.Line("throw new global::System.InvalidOperationException(");
			w.Line("\t$\"No implementation provided for {methodName}<{type.Name}>. \" +");
			w.Line("\t$\"Set the handler's OnCall.\");");
		}
		w.Line();
	}

	#endregion

	#region Property Implementation

	private static void RenderPropertyImplementation(CodeWriter w, FlatPropertyModel prop)
	{
		// Handle property delegation (e.g., IProperty.Value (object) delegates to IProperty<T>.Value (T))
		if (prop.DelegationTarget != null && prop.DelegationTargetInterface != null)
		{
			RenderPropertyDelegation(w, prop);
			return;
		}

		w.Line($"{prop.ReturnType} {prop.DeclaringInterface}.{prop.MemberName}");
		using (w.Braces())
		{
			if (prop.IsInitOnly)
			{
				// Init-only: read from interceptor's Value, record access
				w.Line($"get {{ {prop.InterceptorName}.RecordGet(); return {prop.InterceptorName}.Value; }}");
				w.Line($"init {{ {prop.InterceptorName}.Value = value; }}");
			}
			else
			{
				if (prop.HasGetter)
				{
					w.Line($"get {{ {prop.InterceptorName}.RecordGet(); if ({prop.InterceptorName}.OnGet is {{ }} onGet) return onGet(this); if (Strict) throw global::KnockOff.StubException.NotConfigured(\"{prop.SimpleInterfaceName}\", \"{prop.MemberName}\"); return {prop.InterceptorName}.Value; }}");
				}

				if (prop.HasSetter)
				{
					if (prop.SetterPragmaDisable != null)
						w.Append(prop.SetterPragmaDisable);
					w.Line($"set {{ {prop.InterceptorName}.RecordSet(value); if ({prop.InterceptorName}.OnSet is {{ }} onSet) {{ onSet(this, value); return; }} if (Strict) throw global::KnockOff.StubException.NotConfigured(\"{prop.SimpleInterfaceName}\", \"{prop.MemberName}\"); {prop.InterceptorName}.Value = value; }}");
					if (prop.SetterPragmaRestore != null)
						w.Line(prop.SetterPragmaRestore);
				}
			}
		}
		w.Line();
	}

	private static void RenderPropertyDelegation(CodeWriter w, FlatPropertyModel prop)
	{
		var target = prop.DelegationTarget!;
		var targetInterface = prop.DelegationTargetInterface!;

		w.Line($"{prop.ReturnType} {prop.DeclaringInterface}.{prop.MemberName}");
		using (w.Braces())
		{
			if (prop.HasGetter)
			{
				// Cast the typed value to object (or the base return type)
				w.Line($"get => (({targetInterface})this).{target.Name}!;");
			}

			if (prop.HasSetter)
			{
				// Cast the object value to the typed type
				w.Line($"set => (({targetInterface})this).{target.Name} = ({target.ReturnType.TrimEnd('?')})value!;");
			}
		}
		w.Line();
	}

	#endregion

	#region Indexer Implementation

	private static void RenderIndexerImplementation(CodeWriter w, FlatIndexerModel indexer)
	{
		w.Line($"{indexer.ReturnType} {indexer.DeclaringInterface}.this[{indexer.KeyType} {indexer.KeyParamName}]");
		using (w.Braces())
		{
			if (indexer.HasGetter)
			{
				w.Line($"get {{ {indexer.InterceptorName}.RecordGet({indexer.KeyParamName}); if ({indexer.InterceptorName}.OnGet is {{ }} onGet) return onGet(this, {indexer.KeyParamName}); if (Strict) throw global::KnockOff.StubException.NotConfigured(\"{indexer.SimpleInterfaceName}\", \"this[]\"); return {indexer.InterceptorName}.Backing.TryGetValue({indexer.KeyParamName}, out var v) ? v : {indexer.DefaultExpression}; }}");
			}

			if (indexer.HasSetter)
			{
				w.Line($"set {{ {indexer.InterceptorName}.RecordSet({indexer.KeyParamName}, value); if ({indexer.InterceptorName}.OnSet is {{ }} onSet) {{ onSet(this, {indexer.KeyParamName}, value); return; }} if (Strict) throw global::KnockOff.StubException.NotConfigured(\"{indexer.SimpleInterfaceName}\", \"this[]\"); {indexer.InterceptorName}.Backing[{indexer.KeyParamName}] = value; }}");
			}
		}
		w.Line();
	}

	#endregion

	#region Method Implementation

	private static void RenderMethodImplementation(CodeWriter w, FlatMethodModel method, HashSet<string> multiOverloadInterceptors)
	{
		// Handle method delegation (e.g., IRule.RunRule(IValidateBase) delegates to IRule<T>.RunRule(T))
		if (method.DelegationTarget != null && method.DelegationTargetInterface != null)
		{
			RenderMethodDelegation(w, method);
			return;
		}

		// Generic methods use the old pattern (OnCall property on typed handler)
		if (method.IsGenericMethod)
		{
			RenderGenericMethodImplementation(w, method);
			return;
		}

		// User-defined methods: record call and delegate to user's implementation
		if (method.UserMethodCall != null)
		{
			RenderUserMethodImplementation(w, method);
			return;
		}

		// Determine if this method is part of an overload group (needs suffixed Invoke)
		var isMultiOverload = multiOverloadInterceptors.Contains(method.InterceptorName);
		var invokeSuffix = isMultiOverload ? $"_{GetSignatureSuffix(method)}" : "";

		// Non-generic methods use the new Invoke pattern
		w.Line($"{method.ReturnType} {method.DeclaringInterface}.{method.MethodName}({method.ParameterDeclarations})");
		using (w.Braces())
		{
			// Build invoke args (includes Strict)
			var invokeArgs = method.Parameters.Count > 0
				? "this, Strict, " + string.Join(", ", method.Parameters.Select(p => $"{p.RefPrefix}{p.EscapedName}"))
				: "this, Strict";

			if (method.IsVoid)
				w.Line($"{method.InterceptorName}.Invoke{invokeSuffix}({invokeArgs});");
			else
				w.Line($"return {method.InterceptorName}.Invoke{invokeSuffix}({invokeArgs});");
		}
		w.Line();
	}

	private static void RenderUserMethodImplementation(CodeWriter w, FlatMethodModel method)
	{
		w.Line($"{method.ReturnType} {method.DeclaringInterface}.{method.MethodName}({method.ParameterDeclarations})");
		using (w.Braces())
		{
			// Build record call args
			var recordCallArgs = BuildTrackingArgs(method);

			// Record the call
			w.Line($"{method.InterceptorName}.RecordCall({recordCallArgs});");

			// Call user's method
			if (method.IsVoid)
				w.Line($"{method.UserMethodCall};");
			else
				w.Line($"return {method.UserMethodCall};");
		}
		w.Line();
	}

	private static void RenderGenericMethodImplementation(CodeWriter w, FlatMethodModel method)
	{
		// Generic methods still use the old OnCall property pattern
		w.Line($"{method.ReturnType} {method.DeclaringInterface}.{method.MethodName}{method.TypeParameterDecl}({method.ParameterDeclarations}){method.ConstraintClauses}");
		using (w.Braces())
		{
			// Initialize out parameters
			foreach (var p in method.Parameters.Where(p => p.RefKind == Microsoft.CodeAnalysis.RefKind.Out))
			{
				w.Line($"{p.EscapedName} = default!;");
			}

			var interceptorAccess = $"{method.InterceptorName}{method.OfTypeAccess}";

			// Record the call
			w.Line($"{interceptorAccess}.RecordCall({method.RecordCallArgs});");

			// Build onCall args
			var onCallArgs = method.Parameters.Count > 0
				? "this, " + string.Join(", ", method.Parameters.Select(p => $"{p.RefPrefix}{p.EscapedName}"))
				: "this";

			if (method.IsVoid)
			{
				w.Line($"if ({interceptorAccess}.OnCall is {{ }} onCallCallback)");
				w.Line($"{{ onCallCallback({onCallArgs}); return; }}");
				w.Line($"if (Strict) throw global::KnockOff.StubException.NotConfigured(\"{method.SimpleInterfaceName}\", \"{method.MethodName}\");");
			}
			else if (method.ThrowsOnDefault)
			{
				w.Line($"if ({interceptorAccess}.OnCall is {{ }} callback)");
				w.Line($"\treturn callback({onCallArgs});");
				w.Line($"if (Strict) throw global::KnockOff.StubException.NotConfigured(\"{method.SimpleInterfaceName}\", \"{method.MethodName}\");");
				w.Line($"throw new global::System.InvalidOperationException(\"No implementation provided for {method.MethodName}. Set {interceptorAccess}.OnCall or define a protected method '{method.MethodName}' in your partial class.\");");
			}
			else
			{
				w.Line($"if ({interceptorAccess}.OnCall is {{ }} callback)");
				w.Line($"\treturn callback({onCallArgs});");
				w.Line($"if (Strict) throw global::KnockOff.StubException.NotConfigured(\"{method.SimpleInterfaceName}\", \"{method.MethodName}\");");
				w.Line($"return {method.DefaultExpression};");
			}
		}
		w.Line();
	}

	private static void RenderMethodDelegation(CodeWriter w, FlatMethodModel method)
	{
		var target = method.DelegationTarget!;
		var targetInterface = method.DelegationTargetInterface!;

		// Build parameter cast expressions for delegation
		var memberParams = method.Parameters.GetArray() ?? System.Array.Empty<KnockOff.Model.Shared.ParameterModel>();
		var targetParams = target.Parameters.GetArray() ?? System.Array.Empty<ParameterInfo>();

		var castArgs = new List<string>();
		for (int i = 0; i < memberParams.Length; i++)
		{
			var memberType = memberParams[i].Type;
			var targetType = targetParams[i].Type;
			var paramName = memberParams[i].EscapedName;

			if (memberType != targetType)
			{
				// Cast to the target type
				castArgs.Add($"({targetType}){paramName}");
			}
			else
			{
				castArgs.Add(paramName);
			}
		}

		var argList = string.Join(", ", castArgs);

		// Expression-bodied members don't use 'return' keyword
		w.Line($"{method.ReturnType} {method.DeclaringInterface}.{method.MethodName}{method.TypeParameterDecl}({method.ParameterDeclarations}){method.ConstraintClauses}");
		w.Line($"\t=> (({targetInterface})this).{target.Name}({argList});");
		w.Line();
	}

	#endregion

	#region Event Implementation

	private static void RenderEventImplementation(CodeWriter w, FlatEventModel evt)
	{
		w.Line($"event {evt.DelegateType}? {evt.DeclaringInterface}.{evt.EventName}");
		using (w.Braces())
		{
			w.Line($"add => {evt.InterceptorName}.RecordAdd(value);");
			w.Line($"remove => {evt.InterceptorName}.RecordRemove(value);");
		}
		w.Line();
	}

	#endregion
}
