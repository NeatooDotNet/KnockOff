// src/Generator/Renderer/InlineRenderer.cs
#nullable enable
using System.Collections.Generic;
using System.Linq;
using KnockOff.Model.Inline;
using KnockOff.Model.Shared;

namespace KnockOff.Renderer;

/// <summary>
/// Renders InlineGenerationUnit to source code string.
/// Pure emission - no decisions, just output what the model says.
/// </summary>
internal static class InlineRenderer
{
    public static string Render(InlineGenerationUnit unit)
    {
        var w = new CodeWriter();

        w.Line("// <auto-generated/>");
        w.Line("#nullable enable");
        w.Line();

        // Add using System.Linq if there are generic methods (needed for aggregate LINQ)
        if (unit.HasGenericMethods)
        {
            w.Line("using System.Linq;");
            w.Line();
        }

        // Namespace
        if (!string.IsNullOrEmpty(unit.Namespace))
        {
            w.Line($"namespace {unit.Namespace};");
            w.Line();
        }

        // Open containing type wrappers for nested classes
        foreach (var containingType in unit.ContainingTypes)
        {
            var accessMod = string.IsNullOrEmpty(containingType.AccessModifier)
                ? ""
                : containingType.AccessModifier + " ";
            w.Line($"{accessMod}partial {containingType.Keyword} {containingType.Name}");
            w.Line("{");
        }

        // Partial class
        w.Line($"partial class {unit.ClassName}");
        w.Line("{");

        // Nested Stubs class
        w.Line("\t/// <summary>Contains stub implementations for inline stub pattern.</summary>");
        w.Line("\tpublic static class Stubs");
        w.Line("\t{");

        // Check if any interface has generic methods - if so, generate helper interfaces
        if (unit.HasGenericMethods)
        {
            w.Line("\t\tprivate interface IGenericMethodCallTracker { int CallCount { get; } bool WasCalled { get; } }");
            w.Line("\t\tprivate interface IResettable { void Reset(); }");
            w.Line();
        }

        // Render interface stubs
        foreach (var ifaceStub in unit.InterfaceStubs)
        {
            RenderInterfaceStub(w, ifaceStub);
        }

        // Render delegate stubs
        foreach (var delStub in unit.DelegateStubs)
        {
            RenderDelegateStub(w, delStub);
        }

        // Render class stubs
        foreach (var classStub in unit.ClassStubs)
        {
            RenderClassStub(w, classStub);
        }

        w.Line("\t}"); // Close Stubs class

        // Render partial property implementations
        foreach (var prop in unit.PartialProperties)
        {
            RenderPartialProperty(w, prop);
        }

        w.Line("}"); // Close partial class

        // Close containing type wrappers
        for (int i = 0; i < unit.ContainingTypes.Count; i++)
        {
            w.Line("}");
        }

        return w.ToString();
    }

    #region Interface Stub Rendering

    private static void RenderInterfaceStub(CodeWriter w, InlineInterfaceStubModel iface)
    {
        // Render interceptor classes first
        foreach (var prop in iface.Properties)
        {
            RenderPropertyInterceptorClass(w, prop, iface.StubClassName);
        }

        foreach (var indexer in iface.Indexers)
        {
            RenderIndexerInterceptorClass(w, indexer, iface.StubClassName);
        }

        foreach (var method in iface.Methods)
        {
            RenderMethodInterceptorClass(w, method);
        }

        foreach (var handler in iface.GenericMethodHandlers)
        {
            RenderGenericMethodHandler(w, handler);
        }

        foreach (var evt in iface.Events)
        {
            RenderEventInterceptorClass(w, evt, iface.StubClassName);
        }

        // Render the stub class
        var typeParamList = FormatTypeParameterList(iface.TypeParameters);
        var constraints = FormatConstraints(iface.TypeParameters);

        w.Line($"\t\t/// <summary>Stub implementation of {iface.BaseType}.</summary>");
        w.Line($"\t\tpublic class {iface.StubClassName}{typeParamList} : {iface.BaseType}, global::KnockOff.IKnockOffStub{constraints}");
        w.Line("\t\t{");

        // Interceptor properties
        foreach (var interceptorProp in iface.InterceptorProperties)
        {
            var newKeyword = interceptorProp.NeedsNewKeyword ? "new " : "";
            w.Line($"\t\t\t/// <summary>{interceptorProp.Description}</summary>");
            w.Line($"\t\t\tpublic {newKeyword}{interceptorProp.InterceptorTypeName} {interceptorProp.PropertyName} {{ get; }} = new();");
            w.Line();
        }

        // Explicit interface implementations
        foreach (var impl in iface.Implementations)
        {
            RenderImplementation(w, impl);
        }

        // Object property
        w.Line($"\t\t\t/// <summary>The {iface.BaseType} instance. Use for passing to code expecting the interface.</summary>");
        w.Line($"\t\t\tpublic {iface.BaseType} Object => this;");
        w.Line();

        // Strict property and constructor
        var strictDefault = iface.Strict ? "true" : "false";
        w.Line("\t\t\t/// <summary>When true, unconfigured method calls throw StubException instead of returning default.</summary>");
        w.Line($"\t\t\tpublic bool Strict {{ get; set; }} = {strictDefault};");
        w.Line();
        w.Line($"\t\t\t/// <summary>Creates a new instance of the stub.</summary>");
        w.Line($"\t\t\t/// <param name=\"strict\">When true, unconfigured method calls throw StubException.</param>");
        w.Line($"\t\t\tpublic {iface.StubClassName}(bool strict = {strictDefault})");
        w.Line("\t\t\t{");
        w.Line("\t\t\t\tStrict = strict;");
        w.Line("\t\t\t}");
        w.Line();

        // SmartDefault helper if interface has generic methods
        if (iface.HasGenericMethods)
        {
            RenderSmartDefaultMethod(w);
        }

        w.Line("\t\t}");
        w.Line();
    }

    private static void RenderPropertyInterceptorClass(CodeWriter w, InlinePropertyModel prop, string stubClassName)
    {
        var typeParamList = prop.TypeParameterList;
        var constraintClause = prop.ConstraintClauses;

        w.Line($"\t\t/// <summary>Interceptor for {stubClassName}.{prop.PropertyName}.</summary>");
        w.Line($"\t\tpublic sealed class {prop.InterceptorClassName}{typeParamList}{constraintClause}");
        w.Line("\t\t{");

        if (prop.HasGetter)
        {
            w.Line("\t\t\t/// <summary>Number of times the getter was accessed.</summary>");
            w.Line("\t\t\tpublic int GetCount { get; private set; }");
            w.Line();
            w.Line($"\t\t\t/// <summary>Callback for getter. If set, returns its value.</summary>");
            w.Line($"\t\t\tpublic global::System.Func<{prop.StubClassName}, {prop.ReturnType}>? OnGet {{ get; set; }}");
            w.Line();
        }

        if (prop.HasSetter)
        {
            w.Line("\t\t\t/// <summary>Number of times the setter was accessed.</summary>");
            w.Line("\t\t\tpublic int SetCount { get; private set; }");
            w.Line();
            w.Line($"\t\t\t/// <summary>The last value passed to the setter.</summary>");
            w.Line($"\t\t\tpublic {prop.NullableReturnType} LastSetValue {{ get; private set; }}");
            w.Line();
            w.Line($"\t\t\t/// <summary>Callback for setter.</summary>");
            w.Line($"\t\t\tpublic global::System.Action<{prop.StubClassName}, {prop.ReturnType}>? OnSet {{ get; set; }}");
            w.Line();
        }

        // Value property
        w.Line($"\t\t\t/// <summary>Value returned by getter when OnGet is not set.</summary>");
        w.Line($"\t\t\tpublic {prop.ReturnType} Value {{ get; set; }} = default!;");
        w.Line();

        // RecordGet/RecordSet
        if (prop.HasGetter)
        {
            w.Line("\t\t\t/// <summary>Records a getter access.</summary>");
            w.Line("\t\t\tpublic void RecordGet() => GetCount++;");
            w.Line();
        }
        if (prop.HasSetter)
        {
            w.Line("\t\t\t/// <summary>Records a setter access.</summary>");
            w.Line($"\t\t\tpublic void RecordSet({prop.NullableReturnType} value) {{ SetCount++; LastSetValue = value; }}");
            w.Line();
        }

        // Reset method
        w.Line("\t\t\t/// <summary>Resets all tracking state.</summary>");
        var resetParts = new List<string>();
        if (prop.HasGetter) resetParts.Add("GetCount = 0; OnGet = null;");
        if (prop.HasSetter) resetParts.Add("SetCount = 0; LastSetValue = default; OnSet = null;");
        resetParts.Add("Value = default!;");
        w.Line($"\t\t\tpublic void Reset() {{ {string.Join(" ", resetParts)} }}");

        w.Line("\t\t}");
        w.Line();
    }

    private static void RenderIndexerInterceptorClass(CodeWriter w, InlineIndexerModel indexer, string stubClassName)
    {
        var typeParamList = indexer.TypeParameterList;
        var constraintClause = indexer.ConstraintClauses;

        w.Line($"\t\t/// <summary>Interceptor for {stubClassName}.{indexer.IndexerName}.</summary>");
        w.Line($"\t\tpublic sealed class {indexer.InterceptorClassName}{typeParamList}{constraintClause}");
        w.Line("\t\t{");

        if (indexer.HasGetter)
        {
            w.Line("\t\t\t/// <summary>Number of times the getter was accessed.</summary>");
            w.Line("\t\t\tpublic int GetCount { get; private set; }");
            w.Line();
            w.Line($"\t\t\t/// <summary>The last key used to access the getter.</summary>");
            w.Line($"\t\t\tpublic {indexer.NullableKeyType} LastGetKey {{ get; private set; }}");
            w.Line();
            w.Line($"\t\t\t/// <summary>Callback for getter.</summary>");
            w.Line($"\t\t\tpublic global::System.Func<{indexer.StubClassName}, {indexer.ParameterTypes}, {indexer.ReturnType}>? OnGet {{ get; set; }}");
            w.Line();
        }

        if (indexer.HasSetter)
        {
            w.Line("\t\t\t/// <summary>Number of times the setter was accessed.</summary>");
            w.Line("\t\t\tpublic int SetCount { get; private set; }");
            w.Line();
            w.Line($"\t\t\t/// <summary>The last key-value pair passed to the setter.</summary>");
            w.Line($"\t\t\tpublic ({indexer.KeyType} Key, {indexer.ReturnType} Value)? LastSetEntry {{ get; private set; }}");
            w.Line();
            w.Line($"\t\t\t/// <summary>Callback for setter.</summary>");
            w.Line($"\t\t\tpublic global::System.Action<{indexer.StubClassName}, {indexer.ParameterTypes}, {indexer.ReturnType}>? OnSet {{ get; set; }}");
            w.Line();
        }

        // RecordGet/RecordSet
        if (indexer.HasGetter)
        {
            w.Line($"\t\t\t/// <summary>Records a getter access.</summary>");
            w.Line($"\t\t\tpublic void RecordGet({indexer.ParameterSignature}) {{ GetCount++; LastGetKey = {indexer.KeyExpression}; }}");
            w.Line();
        }
        if (indexer.HasSetter)
        {
            w.Line($"\t\t\t/// <summary>Records a setter access.</summary>");
            w.Line($"\t\t\tpublic void RecordSet({indexer.ParameterSignature}, {indexer.ReturnType} value) {{ SetCount++; LastSetEntry = ({indexer.KeyExpression}, value); }}");
            w.Line();
        }

        // Backing dictionary
        w.Line($"\t\t\t/// <summary>Backing storage for this indexer.</summary>");
        w.Line($"\t\t\tpublic global::System.Collections.Generic.Dictionary<{indexer.SingleKeyType}, {indexer.ReturnType}> Backing {{ get; }} = new();");
        w.Line();

        // Reset method
        w.Line("\t\t\t/// <summary>Resets all tracking state.</summary>");
        var resetParts = new List<string>();
        if (indexer.HasGetter) resetParts.Add("GetCount = 0; LastGetKey = default; OnGet = null;");
        if (indexer.HasSetter) resetParts.Add("SetCount = 0; LastSetEntry = default; OnSet = null;");
        w.Line($"\t\t\tpublic void Reset() {{ {string.Join(" ", resetParts)} }}");

        w.Line("\t\t}");
        w.Line();
    }

    private static void RenderMethodInterceptorClass(CodeWriter w, InlineMethodModel method)
    {
        var typeParamList = method.TypeParameterList;
        var constraintClause = method.ConstraintClauses;

        w.Line($"\t\t/// <summary>Interceptor for {method.MethodName}.</summary>");
        w.Line($"\t\tpublic sealed class {method.InterceptorClassName}{typeParamList}{constraintClause}");
        w.Line("\t\t{");

        // CallCount and WasCalled
        w.Line("\t\t\t/// <summary>Number of times this method was called.</summary>");
        w.Line("\t\t\tpublic int CallCount { get; private set; }");
        w.Line();
        w.Line("\t\t\t/// <summary>Whether this method was called at least once.</summary>");
        w.Line("\t\t\tpublic bool WasCalled => CallCount > 0;");
        w.Line();

        // LastCallArg/LastCallArgs
        if (method.LastCallArgType != null)
        {
            w.Line($"\t\t\t/// <summary>The argument from the last call.</summary>");
            w.Line($"\t\t\tpublic {method.LastCallArgType} LastCallArg {{ get; private set; }}");
            w.Line();
        }
        else if (method.LastCallArgsType != null)
        {
            w.Line($"\t\t\t/// <summary>The arguments from the last call.</summary>");
            w.Line($"\t\t\tpublic {method.LastCallArgsType} LastCallArgs {{ get; private set; }}");
            w.Line();
        }

        // OnCall callback
        w.Line($"\t\t\t/// <summary>Callback invoked when method is called.</summary>");
        w.Line($"\t\t\tpublic {method.DelegateType}? OnCall {{ get; set; }}");
        w.Line();

        // RecordCall method
        w.Append($"\t\t\tpublic void RecordCall({method.RecordCallParameters}) {{ CallCount++; ");
        if (method.LastCallArgType != null)
        {
            var paramName = method.InputParameters.GetArray()![0].Name;
            w.Append($"LastCallArg = {paramName}; ");
        }
        else if (method.LastCallArgsType != null)
        {
            var paramNames = string.Join(", ", method.InputParameters.Select(p => p.Name));
            w.Append($"LastCallArgs = ({paramNames}); ");
        }
        w.Line("}");
        w.Line();

        // Reset method
        w.Append("\t\t\tpublic void Reset() { CallCount = 0; ");
        if (method.LastCallArgType != null)
            w.Append("LastCallArg = default; ");
        else if (method.LastCallArgsType != null)
            w.Append("LastCallArgs = default; ");
        w.Line("OnCall = null; }");

        w.Line("\t\t}");
        w.Line();
    }

    private static void RenderGenericMethodHandler(CodeWriter w, InlineGenericMethodHandlerModel handler)
    {
        var ifaceTypeParamList = handler.InterfaceTypeParameterList;
        var ifaceConstraintClause = handler.InterfaceConstraintClauses;

        w.Line($"\t\t/// <summary>Interceptor for {handler.MethodName}.</summary>");
        w.Line($"\t\tpublic sealed class {handler.InterceptorClassName}{ifaceTypeParamList}{ifaceConstraintClause}");
        w.Line("\t\t{");

        // Dictionary for typed handlers
        w.Line($"\t\t\tprivate readonly global::System.Collections.Generic.Dictionary<{handler.KeyType}, object> _typedHandlers = new();");
        w.Line();

        // Of<T>() method
        w.Line($"\t\t\t/// <summary>Gets the typed handler for the specified type argument(s).</summary>");
        w.Line($"\t\t\tpublic {handler.TypedHandlerClassName}<{handler.TypeParameterNames}> Of<{handler.TypeParameterNames}>(){handler.MethodConstraintClauses}");
        w.Line("\t\t\t{");
        w.Line($"\t\t\t\tvar key = {handler.KeyConstruction};");
        w.Line($"\t\t\t\tif (!_typedHandlers.TryGetValue(key, out var handler))");
        w.Line("\t\t\t\t{");
        w.Line($"\t\t\t\t\thandler = new {handler.TypedHandlerClassName}<{handler.TypeParameterNames}>();");
        w.Line("\t\t\t\t\t_typedHandlers[key] = handler;");
        w.Line("\t\t\t\t}");
        w.Line($"\t\t\t\treturn ({handler.TypedHandlerClassName}<{handler.TypeParameterNames}>)handler;");
        w.Line("\t\t\t}");
        w.Line();

        // Aggregate tracking
        w.Line("\t\t\t/// <summary>Total number of calls across all type arguments.</summary>");
        w.Line("\t\t\tpublic int TotalCallCount => _typedHandlers.Values.Cast<IGenericMethodCallTracker>().Sum(h => h.CallCount);");
        w.Line();
        w.Line("\t\t\t/// <summary>True if this method was called with any type argument.</summary>");
        w.Line("\t\t\tpublic bool WasCalled => _typedHandlers.Values.Cast<IGenericMethodCallTracker>().Any(h => h.WasCalled);");
        w.Line();
        w.Line($"\t\t\t/// <summary>All type argument(s) that were used in calls.</summary>");
        w.Line($"\t\t\tpublic global::System.Collections.Generic.IReadOnlyList<{handler.KeyType}> CalledTypeArguments => _typedHandlers.Keys.ToList();");
        w.Line();

        // Reset method
        w.Line("\t\t\t/// <summary>Resets all typed handlers.</summary>");
        w.Line("\t\t\tpublic void Reset()");
        w.Line("\t\t\t{");
        w.Line("\t\t\t\tforeach (var handler in _typedHandlers.Values.Cast<IResettable>())");
        w.Line("\t\t\t\t\thandler.Reset();");
        w.Line("\t\t\t\t_typedHandlers.Clear();");
        w.Line("\t\t\t}");
        w.Line();

        // Nested Typed Handler Class
        RenderTypedHandlerClass(w, handler);

        w.Line("\t\t}");
        w.Line();
    }

    private static void RenderTypedHandlerClass(CodeWriter w, InlineGenericMethodHandlerModel handler)
    {
        w.Line($"\t\t\t/// <summary>Typed handler for {handler.MethodName} with specific type arguments.</summary>");
        w.Line($"\t\t\tpublic sealed class {handler.TypedHandlerClassName}<{handler.TypeParameterNames}> : IGenericMethodCallTracker, IResettable{handler.MethodConstraintClauses}");
        w.Line("\t\t\t{");

        // Delegate
        w.Line($"\t\t\t\t/// <summary>Delegate for {handler.MethodName}.</summary>");
        w.Line($"\t\t\t\t{handler.DelegateSignature}");
        w.Line();

        // CallCount
        w.Line("\t\t\t\t/// <summary>Number of times this method was called with these type arguments.</summary>");
        w.Line("\t\t\t\tpublic int CallCount { get; private set; }");
        w.Line();

        // LastCallArg/LastCallArgs
        if (handler.LastCallArgType != null)
        {
            var param = handler.NonGenericParameters.GetArray()![0];
            w.Line($"\t\t\t\t/// <summary>The '{param.Name}' argument from the most recent call.</summary>");
            w.Line($"\t\t\t\tpublic {handler.LastCallArgType} LastCallArg {{ get; private set; }}");
            w.Line();
        }
        else if (handler.LastCallArgsType != null)
        {
            w.Line("\t\t\t\t/// <summary>The arguments from the most recent call.</summary>");
            w.Line($"\t\t\t\tpublic {handler.LastCallArgsType} LastCallArgs {{ get; private set; }}");
            w.Line();
        }

        w.Line("\t\t\t\t/// <summary>True if this method was called at least once with these type arguments.</summary>");
        w.Line("\t\t\t\tpublic bool WasCalled => CallCount > 0;");
        w.Line();

        w.Line("\t\t\t\t/// <summary>Callback invoked when this method is called. If set, its return value is used.</summary>");
        w.Line($"\t\t\t\tpublic {handler.MethodName}Delegate? OnCall {{ get; set; }}");
        w.Line();

        // RecordCall
        w.Line("\t\t\t\t/// <summary>Records a method call.</summary>");
        if (handler.NonGenericParameters.Count == 0)
        {
            w.Line("\t\t\t\tpublic void RecordCall() => CallCount++;");
        }
        else if (handler.NonGenericParameters.Count == 1)
        {
            var param = handler.NonGenericParameters.GetArray()![0];
            w.Line($"\t\t\t\tpublic void RecordCall({param.Type} {param.Name}) {{ CallCount++; LastCallArg = {param.Name}; }}");
        }
        else
        {
            var paramList = string.Join(", ", handler.NonGenericParameters.Select(p => $"{p.Type} {p.Name}"));
            var tupleConstruction = string.Join(", ", handler.NonGenericParameters.Select(p => p.Name));
            w.Line($"\t\t\t\tpublic void RecordCall({paramList}) {{ CallCount++; LastCallArgs = ({tupleConstruction}); }}");
        }
        w.Line();

        // Reset
        w.Line("\t\t\t\t/// <summary>Resets all tracking state.</summary>");
        if (handler.NonGenericParameters.Count == 0)
        {
            w.Line("\t\t\t\tpublic void Reset() { CallCount = 0; OnCall = null; }");
        }
        else if (handler.NonGenericParameters.Count == 1)
        {
            w.Line("\t\t\t\tpublic void Reset() { CallCount = 0; LastCallArg = default; OnCall = null; }");
        }
        else
        {
            w.Line("\t\t\t\tpublic void Reset() { CallCount = 0; LastCallArgs = default; OnCall = null; }");
        }

        w.Line("\t\t\t}");
    }

    private static void RenderEventInterceptorClass(CodeWriter w, InlineEventModel evt, string stubClassName)
    {
        var typeParamList = evt.TypeParameterList;
        var constraintClause = evt.ConstraintClauses;

        w.Line($"\t\t/// <summary>Interceptor for {stubClassName}.{evt.EventName} event.</summary>");
        w.Line($"\t\tpublic sealed class {evt.InterceptorClassName}{typeParamList}{constraintClause}");
        w.Line("\t\t{");

        w.Line("\t\t\t/// <summary>Number of times the event was subscribed to.</summary>");
        w.Line("\t\t\tpublic int AddCount { get; private set; }");
        w.Line();
        w.Line("\t\t\t/// <summary>Number of times the event was unsubscribed from.</summary>");
        w.Line("\t\t\tpublic int RemoveCount { get; private set; }");
        w.Line();
        w.Line($"\t\t\t/// <summary>The backing delegate for raising the event.</summary>");
        w.Line($"\t\t\tpublic {evt.DelegateType}? Handler {{ get; private set; }}");
        w.Line();
        w.Line("\t\t\t/// <summary>Records an event subscription.</summary>");
        w.Line($"\t\t\tpublic void RecordAdd({evt.DelegateType}? handler) {{ AddCount++; Handler = ({evt.DelegateType}?)global::System.Delegate.Combine(Handler, handler); }}");
        w.Line();
        w.Line("\t\t\t/// <summary>Records an event unsubscription.</summary>");
        w.Line($"\t\t\tpublic void RecordRemove({evt.DelegateType}? handler) {{ RemoveCount++; Handler = ({evt.DelegateType}?)global::System.Delegate.Remove(Handler, handler); }}");
        w.Line();
        w.Line("\t\t\t/// <summary>Resets all tracking state.</summary>");
        w.Line("\t\t\tpublic void Reset() { AddCount = 0; RemoveCount = 0; Handler = null; }");

        w.Line("\t\t}");
        w.Line();
    }

    private static void RenderSmartDefaultMethod(CodeWriter w)
    {
        w.Line("\t\t\t/// <summary>Gets a smart default value for a generic type at runtime.</summary>");
        w.Line("\t\t\tprivate static T SmartDefault<T>(string methodName)");
        w.Line("\t\t\t{");
        w.Line("\t\t\t\tvar type = typeof(T);");
        w.Line();
        w.Line("\t\t\t\t// Value types -> default(T)");
        w.Line("\t\t\t\tif (type.IsValueType)");
        w.Line("\t\t\t\t\treturn default!;");
        w.Line();
        w.Line("\t\t\t\t// Check for parameterless constructor");
        w.Line("\t\t\t\tvar ctor = type.GetConstructor(");
        w.Line("\t\t\t\t\tSystem.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance,");
        w.Line("\t\t\t\t\tnull, System.Type.EmptyTypes, null);");
        w.Line();
        w.Line("\t\t\t\tif (ctor != null)");
        w.Line("\t\t\t\t\treturn (T)ctor.Invoke(null);");
        w.Line();
        w.Line("\t\t\t\tthrow new global::System.InvalidOperationException(");
        w.Line("\t\t\t\t\t$\"No implementation provided for {methodName}<{type.Name}>. \" +");
        w.Line("\t\t\t\t\t$\"Set the handler's OnCall.\");");
        w.Line("\t\t\t}");
        w.Line();
    }

    #endregion

    #region Implementation Rendering

    private static void RenderImplementation(CodeWriter w, InlineInterfaceImplementation impl)
    {
        switch (impl.Kind)
        {
            case InlineMemberKind.Property:
                RenderPropertyImplementation(w, impl);
                break;
            case InlineMemberKind.Indexer:
                RenderIndexerImplementation(w, impl);
                break;
            case InlineMemberKind.Method:
                RenderMethodImplementation(w, impl);
                break;
            case InlineMemberKind.Event:
                RenderEventImplementation(w, impl);
                break;
        }
    }

    private static void RenderPropertyImplementation(CodeWriter w, InlineInterfaceImplementation impl)
    {
        if (impl.DelegationTarget != null)
        {
            // Delegation implementation
            w.Line($"\t\t\t{impl.ReturnType} {impl.InterfaceFullName}.{impl.MemberName}");
            w.Line("\t\t\t{");
            if (impl.HasGetter)
            {
                w.Line($"\t\t\t\tget => (({impl.DelegationTarget.TargetInterfaceFullName})this).{impl.DelegationTarget.TargetMemberName};");
            }
            if (impl.HasSetter)
            {
                w.Line($"\t\t\t\tset => (({impl.DelegationTarget.TargetInterfaceFullName})this).{impl.DelegationTarget.TargetMemberName} = ({impl.DelegationTarget.TargetReturnType})value;");
            }
            w.Line("\t\t\t}");
            w.Line();
            return;
        }

        w.Line($"\t\t\t{impl.ReturnType} {impl.InterfaceFullName}.{impl.MemberName}");
        w.Line("\t\t\t{");

        if (impl.HasGetter)
        {
            w.Line("\t\t\t\tget");
            w.Line("\t\t\t\t{");
            w.Line($"\t\t\t\t\t{impl.InterceptorName}.RecordGet();");
            w.Line($"\t\t\t\t\tif ({impl.InterceptorName}.OnGet is {{ }} onGet) return onGet(this);");
            w.Line($"\t\t\t\t\tif (Strict) throw global::KnockOff.StubException.NotConfigured(\"{impl.SimpleInterfaceName}\", \"{impl.MemberName}\");");
            w.Line($"\t\t\t\t\treturn {impl.InterceptorName}.Value;");
            w.Line("\t\t\t\t}");
        }

        if (impl.HasSetter)
        {
            var setterKeyword = impl.IsInitOnly ? "init" : "set";
            if (impl.SetterPragmaDisable != null)
                w.Append(impl.SetterPragmaDisable);
            w.Line($"\t\t\t\t{setterKeyword}");
            w.Line("\t\t\t\t{");
            w.Line($"\t\t\t\t\t{impl.InterceptorName}.RecordSet(value);");
            w.Line($"\t\t\t\t\tif ({impl.InterceptorName}.OnSet is {{ }} onSet) {{ onSet(this, value); return; }}");
            w.Line($"\t\t\t\t\tif (Strict) throw global::KnockOff.StubException.NotConfigured(\"{impl.SimpleInterfaceName}\", \"{impl.MemberName}\");");
            w.Line($"\t\t\t\t\t{impl.InterceptorName}.Value = value;");
            w.Line("\t\t\t\t}");
            if (impl.SetterPragmaRestore != null)
                w.Line(impl.SetterPragmaRestore);
        }

        w.Line("\t\t\t}");
        w.Line();
    }

    private static void RenderIndexerImplementation(CodeWriter w, InlineInterfaceImplementation impl)
    {
        w.Line($"\t\t\t{impl.ReturnType} {impl.InterfaceFullName}.this[{impl.ParameterDeclarations}]");
        w.Line("\t\t\t{");

        if (impl.HasGetter)
        {
            w.Line("\t\t\t\tget");
            w.Line("\t\t\t\t{");
            w.Line($"\t\t\t\t\t{impl.InterceptorName}.RecordGet({impl.ArgumentList});");
            w.Line($"\t\t\t\t\tif ({impl.InterceptorName}.OnGet is {{ }} onGet) return onGet({impl.OnCallArgs});");
            w.Line($"\t\t\t\t\tif (Strict) throw global::KnockOff.StubException.NotConfigured(\"{impl.SimpleInterfaceName}\", \"this[]\");");
            w.Line($"\t\t\t\t\treturn {impl.InterceptorName}.Backing.TryGetValue({impl.KeyArg}, out var v) ? v : {impl.DefaultExpression};");
            w.Line("\t\t\t\t}");
        }

        if (impl.HasSetter)
        {
            w.Line("\t\t\t\tset");
            w.Line("\t\t\t\t{");
            w.Line($"\t\t\t\t\t{impl.InterceptorName}.RecordSet({impl.ArgumentList}, value);");
            w.Line($"\t\t\t\t\tif ({impl.InterceptorName}.OnSet is {{ }} onSet) {{ onSet({impl.OnCallArgs}, value); return; }}");
            w.Line($"\t\t\t\t\tif (Strict) throw global::KnockOff.StubException.NotConfigured(\"{impl.SimpleInterfaceName}\", \"this[]\");");
            w.Line($"\t\t\t\t\t{impl.InterceptorName}.Backing[{impl.KeyArg}] = value;");
            w.Line("\t\t\t\t}");
        }

        w.Line("\t\t\t}");
        w.Line();
    }

    private static void RenderMethodImplementation(CodeWriter w, InlineInterfaceImplementation impl)
    {
        if (impl.DelegationTarget != null)
        {
            // Delegation implementation
            var returnKeyword = impl.IsVoid ? "" : "return ";
            w.Line($"\t\t\t{impl.ReturnType} {impl.InterfaceFullName}.{impl.MemberName}({impl.ParameterDeclarations})");
            w.Line("\t\t\t{");
            w.Line($"\t\t\t\t{returnKeyword}(({impl.DelegationTarget.TargetInterfaceFullName})this).{impl.DelegationTarget.TargetMemberName}({impl.DelegationTarget.CastArguments});");
            w.Line("\t\t\t}");
            w.Line();
            return;
        }

        if (impl.IsGenericMethod)
        {
            RenderGenericMethodImplementation(w, impl);
        }
        else
        {
            RenderNonGenericMethodImplementation(w, impl);
        }
    }

    private static void RenderNonGenericMethodImplementation(CodeWriter w, InlineInterfaceImplementation impl)
    {
        w.Line($"\t\t\t{impl.ReturnType} {impl.InterfaceFullName}.{impl.MemberName}({impl.ParameterDeclarations})");
        w.Line("\t\t\t{");

        // Initialize out parameters first
        foreach (var outParamInit in impl.OutParameterInitializations)
        {
            w.Line($"\t\t\t\t{outParamInit}");
        }

        // Record the call
        w.Line($"\t\t\t\t{impl.InterceptorName}.RecordCall({impl.RecordCallArgs});");

        // Check for OnCall callback
        if (impl.IsVoid)
        {
            w.Line($"\t\t\t\tif ({impl.InterceptorName}.OnCall is {{ }} onCall) {{ onCall({impl.OnCallArgs}); return; }}");
            w.Line($"\t\t\t\tif (Strict) throw global::KnockOff.StubException.NotConfigured(\"{impl.SimpleInterfaceName}\", \"{impl.MemberName}\");");
        }
        else if (impl.DefaultStrategy == DefaultValueStrategy.ThrowException)
        {
            w.Line($"\t\t\t\tif ({impl.InterceptorName}.OnCall is {{ }} onCall) return onCall({impl.OnCallArgs});");
            w.Line($"\t\t\t\tif (Strict) throw global::KnockOff.StubException.NotConfigured(\"{impl.SimpleInterfaceName}\", \"{impl.MemberName}\");");
            w.Line($"\t\t\t\tthrow new global::System.InvalidOperationException(\"No implementation provided for {impl.MemberName}. Set {impl.InterceptorName}.OnCall.\");");
        }
        else
        {
            w.Line($"\t\t\t\tif ({impl.InterceptorName}.OnCall is {{ }} onCall) return onCall({impl.OnCallArgs});");
            w.Line($"\t\t\t\tif (Strict) throw global::KnockOff.StubException.NotConfigured(\"{impl.SimpleInterfaceName}\", \"{impl.MemberName}\");");
            w.Line($"\t\t\t\treturn {impl.DefaultExpression};");
        }

        w.Line("\t\t\t}");
        w.Line();
    }

    private static void RenderGenericMethodImplementation(CodeWriter w, InlineInterfaceImplementation impl)
    {
        w.Line($"\t\t\t{impl.ReturnType} {impl.InterfaceFullName}.{impl.MemberName}{impl.TypeParameterDecl}({impl.ParameterDeclarations}){impl.ConstraintClauses}");
        w.Line("\t\t\t{");

        // Initialize out parameters first
        foreach (var outParamInit in impl.OutParameterInitializations)
        {
            w.Line($"\t\t\t\t{outParamInit}");
        }

        // Get the typed handler via Of<T>()
        w.Line($"\t\t\t\tvar typedHandler = {impl.InterceptorName}{impl.OfTypeAccess};");

        // Record the call
        if (string.IsNullOrEmpty(impl.NonGenericArgList))
        {
            w.Line("\t\t\t\ttypedHandler.RecordCall();");
        }
        else
        {
            w.Line($"\t\t\t\ttypedHandler.RecordCall({impl.NonGenericArgList});");
        }

        // Check for OnCall callback
        w.Line($"\t\t\t\tif (typedHandler.OnCall is {{ }} onCallCallback)");
        if (impl.IsVoid)
        {
            w.Line($"\t\t\t\t{{ onCallCallback({impl.OnCallArgs}); return; }}");
        }
        else
        {
            w.Line($"\t\t\t\t\treturn onCallCallback({impl.OnCallArgs});");
        }

        // Strict mode check
        w.Line($"\t\t\t\tif (Strict) throw global::KnockOff.StubException.NotConfigured(\"{impl.SimpleInterfaceName}\", \"{impl.MemberName}\");");

        // Default behavior
        if (!impl.IsVoid)
        {
            // Check for Task/ValueTask types
            if (impl.ReturnType == "global::System.Threading.Tasks.Task")
            {
                w.Line("\t\t\t\treturn global::System.Threading.Tasks.Task.CompletedTask;");
            }
            else if (impl.ReturnType == "global::System.Threading.Tasks.ValueTask")
            {
                w.Line("\t\t\t\treturn default;");
            }
            else if (impl.IsNullable)
            {
                w.Line("\t\t\t\treturn default!;");
            }
            else
            {
                w.Line($"\t\t\t\treturn {impl.DefaultExpression};");
            }
        }

        w.Line("\t\t\t}");
        w.Line();
    }

    private static void RenderEventImplementation(CodeWriter w, InlineInterfaceImplementation impl)
    {
        w.Line($"\t\t\tevent {impl.ReturnType}? {impl.InterfaceFullName}.{impl.MemberName}");
        w.Line("\t\t\t{");
        w.Line($"\t\t\t\tadd => {impl.InterceptorName}.RecordAdd(value);");
        w.Line($"\t\t\t\tremove => {impl.InterceptorName}.RecordRemove(value);");
        w.Line("\t\t\t}");
        w.Line();
    }

    #endregion

    #region Delegate Stub Rendering

    private static void RenderDelegateStub(CodeWriter w, InlineDelegateStubModel del)
    {
        // Generate handler class first
        w.Line($"\t\t/// <summary>Interceptor for {del.StubClassName} delegate.</summary>");
        w.Line($"\t\tpublic sealed class {del.InterceptorClassName}");
        w.Line("\t\t{");

        // CallCount and WasCalled
        w.Line("\t\t\t/// <summary>Number of times this delegate was invoked.</summary>");
        w.Line("\t\t\tpublic int CallCount { get; private set; }");
        w.Line();
        w.Line("\t\t\t/// <summary>Whether this delegate was invoked at least once.</summary>");
        w.Line("\t\t\tpublic bool WasCalled => CallCount > 0;");
        w.Line();

        // LastCallArg/LastCallArgs
        if (del.LastCallArgType != null)
        {
            w.Line($"\t\t\t/// <summary>The argument from the last invocation.</summary>");
            w.Line($"\t\t\tpublic {del.LastCallArgType} LastCallArg {{ get; private set; }}");
            w.Line();
        }
        else if (del.LastCallArgsType != null)
        {
            w.Line($"\t\t\t/// <summary>The arguments from the last invocation.</summary>");
            w.Line($"\t\t\tpublic {del.LastCallArgsType} LastCallArgs {{ get; private set; }}");
            w.Line();
        }

        // OnCall callback
        w.Line($"\t\t\t/// <summary>Callback invoked when delegate is called.</summary>");
        w.Line($"\t\t\tpublic {del.OnCallType}? OnCall {{ get; set; }}");
        w.Line();

        // RecordCall method
        if (del.Parameters.Count == 0)
        {
            w.Line("\t\t\tpublic void RecordCall() { CallCount++; }");
        }
        else if (del.Parameters.Count == 1)
        {
            var param = del.Parameters.GetArray()![0];
            w.Line($"\t\t\tpublic void RecordCall({param.Type} {param.Name}) {{ CallCount++; LastCallArg = {param.Name}; }}");
        }
        else
        {
            var paramList = string.Join(", ", del.Parameters.Select(p => $"{p.Type} {p.Name}"));
            var argList = string.Join(", ", del.Parameters.Select(p => p.Name));
            w.Line($"\t\t\tpublic void RecordCall({paramList}) {{ CallCount++; LastCallArgs = ({argList}); }}");
        }
        w.Line();

        // Reset method
        w.Append("\t\t\tpublic void Reset() { CallCount = 0; ");
        if (del.LastCallArgType != null)
            w.Append("LastCallArg = default; ");
        else if (del.LastCallArgsType != null)
            w.Append("LastCallArgs = default; ");
        w.Line("OnCall = null; }");

        w.Line("\t\t}");
        w.Line();

        // Generate stub class
        w.Line($"\t\t/// <summary>Stub for {del.DelegateType} delegate.</summary>");
        w.Line($"\t\tpublic sealed class {del.StubClassName}{del.TypeParameterList} : global::KnockOff.IKnockOffStub{del.ConstraintClauses}");
        w.Line("\t\t{");

        // Strict property
        w.Line("\t\t\t/// <summary>When true, unconfigured method calls throw StubException instead of returning default. Not yet implemented for delegate stubs.</summary>");
        w.Line("\t\t\tpublic bool Strict { get; set; }");
        w.Line();

        // Interceptor property
        w.Line($"\t\t\t/// <summary>Interceptor for tracking and configuring delegate behavior.</summary>");
        w.Line($"\t\t\tpublic {del.InterceptorClassName} Interceptor {{ get; }} = new();");
        w.Line();

        // Private Invoke method
        w.Line($"\t\t\tprivate {del.ReturnType} Invoke({del.InvokeParameterDeclarations})");
        w.Line("\t\t\t{");
        if (del.Parameters.Count > 0)
        {
            w.Line($"\t\t\t\tInterceptor.RecordCall({del.InvokeArgumentList});");
        }
        else
        {
            w.Line("\t\t\t\tInterceptor.RecordCall();");
        }
        if (del.IsVoid)
        {
            var onCallArgs = del.Parameters.Count > 0 ? $"this, {del.InvokeArgumentList}" : "this";
            w.Line($"\t\t\t\tif (Interceptor.OnCall is {{ }} onCall) onCall({onCallArgs});");
        }
        else
        {
            var onCallArgs = del.Parameters.Count > 0 ? $"this, {del.InvokeArgumentList}" : "this";
            w.Line($"\t\t\t\tif (Interceptor.OnCall is {{ }} onCall) return onCall({onCallArgs});");
            w.Line($"\t\t\t\treturn {del.DefaultExpression};");
        }
        w.Line("\t\t\t}");
        w.Line();

        // Implicit conversion operator
        w.Line($"\t\t\t/// <summary>Implicit conversion to {del.DelegateType}.</summary>");
        w.Line($"\t\t\tpublic static implicit operator {del.DelegateType}({del.StubClassName}{del.TypeParameterList} stub) => stub.Invoke;");

        w.Line("\t\t}");
        w.Line();
    }

    #endregion

    #region Class Stub Rendering

    private static void RenderClassStub(CodeWriter w, InlineClassStubModel cls)
    {
        // Delegate to ClassRenderer for full rendering
        ClassRenderer.Render(w, cls, baseIndent: 2);
    }

    #endregion

    #region Partial Property Rendering

    private static void RenderPartialProperty(CodeWriter w, InlinePartialPropertyModel prop)
    {
        var accessMod = string.IsNullOrEmpty(prop.AccessModifier) ? "" : $"{prop.AccessModifier} ";

        w.Line();
        w.Line($"\tprivate readonly Stubs.{prop.StubTypeName} {prop.BackingFieldName} = new();");
        w.Line($"\t/// <summary>Auto-instantiated stub for {prop.StubTypeName}.</summary>");
        w.Line($"\t{accessMod}partial Stubs.{prop.StubTypeName} {prop.PropertyName} {{ get => {prop.BackingFieldName}; }}");
    }

    #endregion

    #region Helper Methods

    private static string FormatTypeParameterList(EquatableArray<TypeParameterModel> typeParameters)
    {
        if (typeParameters.Count == 0)
            return "";

        var names = string.Join(", ", typeParameters.Select(tp => tp.Name));
        return $"<{names}>";
    }

    private static string FormatConstraints(EquatableArray<TypeParameterModel> typeParameters)
    {
        if (typeParameters.Count == 0)
            return "";

        var clauses = typeParameters
            .Where(tp => !string.IsNullOrEmpty(tp.Constraints))
            .Select(tp => $" where {tp.Name} : {tp.Constraints}");

        return string.Join("", clauses);
    }

    #endregion
}
