// <auto-generated/> - Partial class extracted from KnockOffGenerator.cs
#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

namespace KnockOff;

public partial class KnockOffGenerator
{
	/// <summary>
	/// Transform: extract interface types from ALL generic attribute arguments on this class.
	/// ForAttributeWithMetadataName triggers once per node, with context.Attributes containing
	/// ALL matching attributes on that node.
	/// </summary>
	private static InlineStubClassInfo? TransformInlineStubClass(GeneratorAttributeSyntaxContext context)
	{
		var classDeclaration = (ClassDeclarationSyntax)context.TargetNode;
		var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);

		if (classSymbol is null)
			return null;

		// Get namespace
		var ns = classSymbol.ContainingNamespace;
		var namespaceName = ns.IsGlobalNamespace ? "" : ns.ToDisplayString();

		// Get containing types chain (for nested class support)
		var containingTypes = GetContainingTypes(classSymbol);

		// Collect diagnostics
		var diagnostics = new List<DiagnosticInfo>();
		var filePath = classDeclaration.SyntaxTree.FilePath;

		// Check for existing "Stubs" nested type (KO1003)
		var existingStubsType = classSymbol.GetTypeMembers("Stubs").FirstOrDefault();
		if (existingStubsType is not null)
		{
			var location = classDeclaration.Identifier.GetLocation();
			var lineSpan = location.GetLineSpan();
			diagnostics.Add(new DiagnosticInfo(
				"KO1003",
				filePath,
				lineSpan.StartLinePosition.Line,
				lineSpan.StartLinePosition.Character,
				Array.Empty<string>()));
		}

		// Track names for collision detection
		// Key: simpleName, Value: list of (typeSuffix, fullName) pairs
		var nameToTypeSuffixes = new Dictionary<string, List<(string typeSuffix, string fullName)>>();

		// Process ALL [KnockOff<T>] attributes on this class
		// First pass: collect all interfaces and track name collisions
		var interfaceEntries = new List<(INamedTypeSymbol symbol, InterfaceInfo info)>();
		var delegates = new List<DelegateInfo>();
		var classes = new List<ClassStubInfo>();
		var stubTypeNames = new HashSet<string>();

		foreach (var attributeData in context.Attributes)
		{
			ITypeSymbol? typeArg = null;
			bool isOpenGeneric = false;
			EquatableArray<TypeParameterInfo> openGenericTypeParams = default;

			// Get attribute location for diagnostics
			var attrLocation = attributeData.ApplicationSyntaxReference?.GetSyntax()?.GetLocation();
			var attrLineSpan = attrLocation?.GetLineSpan() ?? default;

			// Path 1: Generic attribute [KnockOff<T>] - extract from TypeArguments
			if (attributeData.AttributeClass is INamedTypeSymbol attrType && attrType.IsGenericType)
			{
				typeArg = attrType.TypeArguments.FirstOrDefault();
			}
			// Path 2: Non-generic attribute [KnockOff(typeof(T))] - extract from ConstructorArguments
			else if (attributeData.ConstructorArguments.Length > 0
				&& attributeData.ConstructorArguments[0].Value is INamedTypeSymbol ctorTypeArg)
			{
				typeArg = ctorTypeArg;

				// Check if this is an open generic (unbound) type
				if (ctorTypeArg.IsUnboundGenericType)
				{
					isOpenGeneric = true;
					openGenericTypeParams = SymbolHelpers.ExtractTypeParameters(ctorTypeArg.TypeParameters);
				}
			}

			if (typeArg is null)
				continue;

			// Extract Strict property from attribute (default false)
			var strict = false;
			foreach (var namedArg in attributeData.NamedArguments)
			{
				if (namedArg.Key == "Strict" && namedArg.Value.Value is bool strictValue)
				{
					strict = strictValue;
					break;
				}
			}

			// Check if type argument is an interface, class, or delegate (KO1001)
			if (typeArg.TypeKind != TypeKind.Interface && typeArg.TypeKind != TypeKind.Delegate && typeArg.TypeKind != TypeKind.Class)
			{
				diagnostics.Add(new DiagnosticInfo(
					"KO1001",
					filePath,
					attrLineSpan.StartLinePosition.Line,
					attrLineSpan.StartLinePosition.Character,
					new[] { typeArg.ToDisplayString() }));
				continue;
			}

			// Track name for collision detection
			var simpleName = typeArg.Name;
			var fullName = typeArg.ToDisplayString();
			var typeSuffix = typeArg is INamedTypeSymbol namedType
				? SymbolHelpers.GetTypeArgumentsSuffix(namedType)
				: "";

			if (!nameToTypeSuffixes.TryGetValue(simpleName, out var entries))
			{
				entries = new List<(string, string)>();
				nameToTypeSuffixes[simpleName] = entries;
			}
			// Track unique combinations of (typeSuffix, fullName)
			if (!entries.Any(e => e.fullName == fullName))
				entries.Add((typeSuffix, fullName));

			// Get interface info
			if (typeArg.TypeKind == TypeKind.Interface && typeArg is INamedTypeSymbol namedInterface)
			{
				var interfaceInfo = ExtractInterfaceInfo(namedInterface, classSymbol.ContainingAssembly, typeSuffix, strict, isOpenGeneric, openGenericTypeParams);
				interfaceEntries.Add((namedInterface, interfaceInfo));
				stubTypeNames.Add(namedInterface.Name); // e.g., "IUserService"
			}
			// Get delegate info
			else if (typeArg.TypeKind == TypeKind.Delegate && typeArg is INamedTypeSymbol namedDelegate)
			{
				// For open generic delegates, use OriginalDefinition to get the Invoke method
				var delegateSource = isOpenGeneric ? namedDelegate.OriginalDefinition : namedDelegate;
				var delegateInfo = DelegateInfo.Extract(delegateSource, isOpenGeneric, openGenericTypeParams);
				if (delegateInfo is not null)
				{
					delegates.Add(delegateInfo);
					stubTypeNames.Add(namedDelegate.Name); // e.g., "IsUniqueRule"
				}
			}
			// Get class info for class stubbing via inheritance
			else if (typeArg.TypeKind == TypeKind.Class && typeArg is INamedTypeSymbol namedClass)
			{
				// For open generic classes, use OriginalDefinition to get members
				var classSource = isOpenGeneric ? namedClass.OriginalDefinition : namedClass;
				var classInfo = ExtractClassInfo(classSource, namedClass, classSymbol.ContainingAssembly, filePath, attrLineSpan, diagnostics, isOpenGeneric, openGenericTypeParams);
				if (classInfo is not null)
				{
					classes.Add(classInfo);
					stubTypeNames.Add(namedClass.Name); // e.g., "UserService"
				}
			}
		}

		// Detect collisions and update NeedsSuffix
		// Collision = same simple name with different type suffixes (e.g., IList<string> and IList<int>)
		var needsSuffixNames = new HashSet<string>();
		foreach (var kvp in nameToTypeSuffixes)
		{
			// Check for same name with different type suffixes
			var distinctSuffixes = kvp.Value.Select(e => e.typeSuffix).Distinct().ToList();
			if (distinctSuffixes.Count > 1)
			{
				needsSuffixNames.Add(kvp.Key);
			}
			// Also check for KO1002 - same simple name from different namespaces (non-generic collision)
			else if (kvp.Value.Count > 1 && string.IsNullOrEmpty(distinctSuffixes.FirstOrDefault()))
			{
				var location = classDeclaration.Identifier.GetLocation();
				var lineSpan = location.GetLineSpan();
				diagnostics.Add(new DiagnosticInfo(
					"KO1002",
					filePath,
					lineSpan.StartLinePosition.Line,
					lineSpan.StartLinePosition.Character,
					new[] { kvp.Key }));
			}
		}

		// Second pass: create final interface list with NeedsSuffix set
		var interfaces = new List<InterfaceInfo>();
		foreach (var (symbol, info) in interfaceEntries)
		{
			var needsSuffix = needsSuffixNames.Contains(symbol.Name);
			if (needsSuffix)
			{
				// Create new record with NeedsSuffix = true
				interfaces.Add(info with { NeedsSuffix = true });
				// Add the suffixed name to stubTypeNames for partial property detection
				stubTypeNames.Add(info.StubClassName);
			}
			else
			{
				interfaces.Add(info);
			}
		}

		// If there are blocking diagnostics (KO1002, KO1003), still return to report them
		// but code generation will be skipped

		if (interfaces.Count == 0 && delegates.Count == 0 && classes.Count == 0 && diagnostics.Count == 0)
			return null;

		// Detect partial properties that return Stubs.{TypeName}
		var partialProperties = DetectPartialProperties(classDeclaration, stubTypeNames);

		return new InlineStubClassInfo(
			Namespace: namespaceName,
			ClassName: classSymbol.Name,
			ContainingTypes: containingTypes,
			Interfaces: new EquatableArray<InterfaceInfo>(interfaces.ToArray()),
			Delegates: new EquatableArray<DelegateInfo>(delegates.ToArray()),
			Classes: new EquatableArray<ClassStubInfo>(classes.ToArray()),
			PartialProperties: new EquatableArray<PartialPropertyInfo>(partialProperties.ToArray()),
			Diagnostics: new EquatableArray<DiagnosticInfo>(diagnostics.ToArray()));
	}

	/// <summary>
	/// Detects partial properties in the class declaration that return Stubs.{InterfaceName}.
	/// The stubTypeNames set includes both regular names (e.g., "IUserService") and suffixed
	/// names (e.g., "IListString") for collision avoidance scenarios.
	/// </summary>
	private static List<PartialPropertyInfo> DetectPartialProperties(
		ClassDeclarationSyntax classDeclaration,
		HashSet<string> stubTypeNames)
	{
		var partialProperties = new List<PartialPropertyInfo>();

		foreach (var member in classDeclaration.Members)
		{
			if (member is not PropertyDeclarationSyntax property)
				continue;

			// Check if the property has the partial modifier
			if (!property.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
				continue;

			// Check if property type is Stubs.{SomeName}
			var typeText = property.Type.ToString();
			if (!typeText.StartsWith("Stubs."))
				continue;

			var stubTypeName = typeText.Substring(6); // Remove "Stubs." prefix
			if (!stubTypeNames.Contains(stubTypeName))
				continue;

			// Property matches - extract info
			var accessModifier = GetAccessModifier(property.Modifiers);
			var hasGetter = property.AccessorList?.Accessors.Any(a => a.IsKind(SyntaxKind.GetAccessorDeclaration)) ?? false;
			var hasSetter = property.AccessorList?.Accessors.Any(a => a.IsKind(SyntaxKind.SetAccessorDeclaration)) ?? false;

			// If no accessor list but has expression body, it's a getter
			if (property.ExpressionBody != null)
			{
				hasGetter = true;
			}

			partialProperties.Add(new PartialPropertyInfo(
				PropertyName: property.Identifier.Text,
				StubTypeName: stubTypeName,
				AccessModifier: accessModifier,
				HasGetter: hasGetter,
				HasSetter: hasSetter));
		}

		return partialProperties;
	}

	/// <summary>
	/// Extracts access modifier from property modifiers.
	/// </summary>
	private static string GetAccessModifier(SyntaxTokenList modifiers)
	{
		var accessParts = new List<string>();
		foreach (var mod in modifiers)
		{
			if (mod.IsKind(SyntaxKind.PublicKeyword))
				accessParts.Add("public");
			else if (mod.IsKind(SyntaxKind.ProtectedKeyword))
				accessParts.Add("protected");
			else if (mod.IsKind(SyntaxKind.PrivateKeyword))
				accessParts.Add("private");
			else if (mod.IsKind(SyntaxKind.InternalKeyword))
				accessParts.Add("internal");
		}
		return string.Join(" ", accessParts);
	}

	/// <summary>
	/// Extracts interface info for inline stubs (reuses same InterfaceInfo as explicit pattern).
	/// </summary>
	private static InterfaceInfo ExtractInterfaceInfo(
		INamedTypeSymbol iface,
		IAssemblySymbol knockOffAssembly,
		string typeSuffix = "",
		bool strict = false,
		bool isOpenGeneric = false,
		EquatableArray<TypeParameterInfo> typeParameters = default)
	{
		var members = new List<InterfaceMemberInfo>();
		var events = new List<EventMemberInfo>();

		// For unbound generic types, GetMembers() returns empty - use OriginalDefinition instead
		var memberSource = isOpenGeneric && iface.IsUnboundGenericType
			? iface.OriginalDefinition
			: iface;

		var ifaceFullName = iface.ToDisplayString(FullyQualifiedWithNullability);
		foreach (var member in memberSource.GetMembers())
		{
			// Skip internal members from external assemblies
			if (!IsMemberAccessible(member, knockOffAssembly))
				continue;

			if (member is IPropertySymbol property)
			{
				members.Add(InterfaceMemberInfo.FromProperty(property, ifaceFullName));
			}
			else if (member is IMethodSymbol method && method.MethodKind == MethodKind.Ordinary)
			{
				members.Add(InterfaceMemberInfo.FromMethod(method, ifaceFullName));
			}
			else if (member is IEventSymbol eventSymbol)
			{
				events.Add(EventMemberInfo.FromEvent(eventSymbol, ifaceFullName));
			}
		}

		// Also get inherited interface members
		foreach (var baseInterface in iface.AllInterfaces)
		{
			var baseIfaceFullName = baseInterface.ToDisplayString(FullyQualifiedWithNullability);
			foreach (var member in baseInterface.GetMembers())
			{
				if (!IsMemberAccessible(member, knockOffAssembly))
					continue;

				if (member is IPropertySymbol property)
				{
					members.Add(InterfaceMemberInfo.FromProperty(property, baseIfaceFullName));
				}
				else if (member is IMethodSymbol method && method.MethodKind == MethodKind.Ordinary)
				{
					members.Add(InterfaceMemberInfo.FromMethod(method, baseIfaceFullName));
				}
				else if (member is IEventSymbol eventSymbol)
				{
					events.Add(EventMemberInfo.FromEvent(eventSymbol, baseIfaceFullName));
				}
			}
		}

		var simpleName = GetSimpleInterfaceName(iface.Name);

		return new InterfaceInfo(
			iface.ToDisplayString(FullyQualifiedWithNullability),
			iface.Name,
			simpleName,
			new EquatableArray<InterfaceMemberInfo>(members.ToArray()),
			new EquatableArray<EventMemberInfo>(events.ToArray()),
			TypeSuffix: typeSuffix,
			Strict: strict,
			IsOpenGeneric: isOpenGeneric,
			TypeParameters: typeParameters);
	}

	/// <summary>
	/// Extracts class info for class stubbing via inheritance.
	/// Returns null if the class cannot be stubbed (sealed, static, built-in, etc.).
	/// </summary>
	/// <param name="classSource">The class to extract members from (may be OriginalDefinition for open generics)</param>
	/// <param name="classType">The original class type (used for display names and diagnostics)</param>
	private static ClassStubInfo? ExtractClassInfo(
		INamedTypeSymbol classSource,
		INamedTypeSymbol classType,
		IAssemblySymbol knockOffAssembly,
		string filePath,
		Microsoft.CodeAnalysis.FileLinePositionSpan attrLineSpan,
		List<DiagnosticInfo> diagnostics,
		bool isOpenGeneric = false,
		EquatableArray<TypeParameterInfo> typeParameters = default)
	{
		var className = classType.Name;
		var classFullName = classType.ToDisplayString(FullyQualifiedWithNullability);

		// KO2005: Cannot stub static class
		if (classType.IsStatic)
		{
			diagnostics.Add(new DiagnosticInfo(
				"KO2005",
				filePath,
				attrLineSpan.StartLinePosition.Line,
				attrLineSpan.StartLinePosition.Character,
				new[] { classFullName }));
			return null;
		}

		// KO2001: Cannot stub sealed class
		if (classType.IsSealed)
		{
			diagnostics.Add(new DiagnosticInfo(
				"KO2001",
				filePath,
				attrLineSpan.StartLinePosition.Line,
				attrLineSpan.StartLinePosition.Character,
				new[] { classFullName }));
			return null;
		}

		// KO2006: Cannot stub built-in types (string, object, ValueType, Enum, Delegate, Array)
		if (IsBuiltInType(classType))
		{
			diagnostics.Add(new DiagnosticInfo(
				"KO2006",
				filePath,
				attrLineSpan.StartLinePosition.Line,
				attrLineSpan.StartLinePosition.Character,
				new[] { classFullName }));
			return null;
		}

		// KO2002: Must have accessible constructors
		// For open generics, use classSource (OriginalDefinition) to get constructors
		var accessibleConstructors = classSource.InstanceConstructors
			.Where(c => c.DeclaredAccessibility == Accessibility.Public ||
						c.DeclaredAccessibility == Accessibility.Protected ||
						c.DeclaredAccessibility == Accessibility.ProtectedOrInternal ||
						(c.DeclaredAccessibility == Accessibility.Internal &&
						 SymbolEqualityComparer.Default.Equals(c.ContainingAssembly, knockOffAssembly)))
			.ToList();

		if (accessibleConstructors.Count == 0)
		{
			diagnostics.Add(new DiagnosticInfo(
				"KO2002",
				filePath,
				attrLineSpan.StartLinePosition.Line,
				attrLineSpan.StartLinePosition.Character,
				new[] { classFullName }));
			return null;
		}

		// Extract constructors
		var constructors = new List<ClassConstructorInfo>();
		foreach (var ctor in accessibleConstructors)
		{
			var ctorParams = new List<ParameterInfo>();
			foreach (var param in ctor.Parameters)
			{
				ctorParams.Add(new ParameterInfo(
					param.Name,
					param.Type.ToDisplayString(FullyQualifiedWithNullability),
					param.RefKind));
			}

			var accessModifier = ctor.DeclaredAccessibility switch
			{
				Accessibility.Public => "public",
				Accessibility.Protected => "protected",
				Accessibility.ProtectedOrInternal => "protected internal",
				Accessibility.Internal => "internal",
				_ => "protected"
			};

			constructors.Add(new ClassConstructorInfo(
				new EquatableArray<ParameterInfo>(ctorParams.ToArray()),
				accessModifier));
		}

		// Extract virtual/abstract members (properties, methods, indexers)
		var members = new List<ClassMemberInfo>();
		var events = new List<EventMemberInfo>();

		// Get all members including inherited ones
		// For open generics, use classSource (OriginalDefinition) to get members
		foreach (var member in GetAllVirtualMembers(classSource))
		{
			// Skip internal members from external assemblies
			if (!IsMemberAccessible(member, knockOffAssembly))
				continue;

			if (member is IPropertySymbol property)
			{
				// Only include virtual/abstract/override properties that aren't sealed
				if ((property.IsVirtual || property.IsAbstract || property.IsOverride) && !property.IsSealed)
				{
					members.Add(ClassMemberInfo.FromProperty(property));
				}
			}
			else if (member is IMethodSymbol method && method.MethodKind == MethodKind.Ordinary)
			{
				// Only include virtual/abstract/override methods that aren't sealed
				if ((method.IsVirtual || method.IsAbstract || method.IsOverride) && !method.IsSealed)
				{
					members.Add(ClassMemberInfo.FromMethod(method));
				}
			}
			else if (member is IEventSymbol eventSymbol)
			{
				// Only include virtual/abstract/override events that aren't sealed
				if ((eventSymbol.IsVirtual || eventSymbol.IsAbstract || eventSymbol.IsOverride) && !eventSymbol.IsSealed)
				{
					events.Add(EventMemberInfo.FromEvent(eventSymbol, classFullName));
				}
			}
		}

		// KO2004: Warning if no virtual/abstract members to intercept
		if (members.Count == 0 && events.Count == 0)
		{
			diagnostics.Add(new DiagnosticInfo(
				"KO2004",
				filePath,
				attrLineSpan.StartLinePosition.Line,
				attrLineSpan.StartLinePosition.Character,
				new[] { classFullName }));
			// Continue - this is just a warning, we still generate the stub
		}

		return new ClassStubInfo(
			classFullName,
			className,
			new EquatableArray<ClassMemberInfo>(members.ToArray()),
			new EquatableArray<ClassConstructorInfo>(constructors.ToArray()),
			new EquatableArray<EventMemberInfo>(events.ToArray()),
			IsOpenGeneric: isOpenGeneric,
			TypeParameters: typeParameters);
	}

	/// <summary>
	/// Checks if a type is a built-in type that cannot be stubbed.
	/// </summary>
	private static bool IsBuiltInType(INamedTypeSymbol type)
	{
		var ns = type.ContainingNamespace?.ToDisplayString();
		if (ns != "System")
			return false;

		// String, Object, Array, Delegate, MulticastDelegate, ValueType, Enum
		return type.Name is "String" or "Object" or "Array" or "Delegate" or "MulticastDelegate" or "ValueType" or "Enum";
	}

	/// <summary>
	/// Gets all virtual/abstract/override members from a class and its base classes.
	/// </summary>
	private static IEnumerable<ISymbol> GetAllVirtualMembers(INamedTypeSymbol classType)
	{
		var seenSignatures = new HashSet<string>();

		// Walk up the inheritance hierarchy
		var current = classType;
		while (current != null && current.SpecialType != SpecialType.System_Object)
		{
			foreach (var member in current.GetMembers())
			{
				// Create a signature to detect duplicates from overrides
				var signature = GetMemberSignature(member);
				if (signature != null && seenSignatures.Add(signature))
				{
					yield return member;
				}
			}
			current = current.BaseType;
		}
	}

	/// <summary>
	/// Gets a unique signature for a member to detect duplicates.
	/// </summary>
	private static string? GetMemberSignature(ISymbol member)
	{
		return member switch
		{
			IPropertySymbol prop => prop.IsIndexer
				? $"indexer[{string.Join(",", prop.Parameters.Select(p => p.Type.ToDisplayString()))}]"
				: $"property:{prop.Name}",
			IMethodSymbol method when method.MethodKind == MethodKind.Ordinary =>
				$"method:{method.Name}({string.Join(",", method.Parameters.Select(p => p.Type.ToDisplayString()))})",
			IEventSymbol evt => $"event:{evt.Name}",
			_ => null
		};
	}

	/// <summary>
	/// Transform: extract all interface members and user-defined methods
	/// </summary>
	private static KnockOffTypeInfo? TransformClass(GeneratorAttributeSyntaxContext context)
	{
		var classDeclaration = (ClassDeclarationSyntax)context.TargetNode;
		var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);

		if (classSymbol is null)
			return null;

		// Extract Strict property from [KnockOff] attribute (default false)
		var strict = false;
		foreach (var attributeData in context.Attributes)
		{
			foreach (var namedArg in attributeData.NamedArguments)
			{
				if (namedArg.Key == "Strict" && namedArg.Value.Value is bool strictValue)
				{
					strict = strictValue;
					break;
				}
			}
		}

		// Get namespace
		var ns = classSymbol.ContainingNamespace;
		var namespaceName = ns.IsGlobalNamespace ? "" : ns.ToDisplayString();

		// Get containing types chain (for nested class support)
		var containingTypes = GetContainingTypes(classSymbol);

		// Extract class type parameters for generic standalone stubs
		var classTypeParameters = SymbolHelpers.ExtractTypeParameters(classSymbol.TypeParameters);

		var diagnostics = new List<DiagnosticInfo>();
		var filePath = classDeclaration.SyntaxTree.FilePath;

		// Get directly implemented interfaces (what user declared in base list)
		var directInterfaces = classSymbol.Interfaces;
		if (directInterfaces.Length == 0)
			return null;

		// Check for multiple unrelated interfaces (KO0010)
		// Find root interfaces - those not inherited by any other declared interface
		var rootInterfaces = FindRootInterfaces(directInterfaces);
		if (rootInterfaces.Count > 1)
		{
			var location = classDeclaration.Identifier.GetLocation();
			var lineSpan = location.GetLineSpan();
			var interfaceNames = string.Join(" and ", rootInterfaces.Select(i => i.Name));
			diagnostics.Add(new DiagnosticInfo(
				"KO0010",
				filePath,
				lineSpan.StartLinePosition.Line,
				lineSpan.StartLinePosition.Character,
				new[] { interfaceNames }));

			// Return with diagnostics but no generation
			return new KnockOffTypeInfo(
				Namespace: namespaceName,
				ClassName: classSymbol.Name,
				ContainingTypes: containingTypes,
				TypeParameters: classTypeParameters,
				Interfaces: new EquatableArray<InterfaceInfo>(Array.Empty<InterfaceInfo>()),
				UserMethods: new EquatableArray<UserMethodInfo>(Array.Empty<UserMethodInfo>()),
				Diagnostics: new EquatableArray<DiagnosticInfo>(diagnostics.ToArray()),
				FlatMembers: new EquatableArray<InterfaceMemberInfo>(Array.Empty<InterfaceMemberInfo>()),
				FlatEvents: new EquatableArray<EventMemberInfo>(Array.Empty<EventMemberInfo>()),
				Strict: strict);
		}

		// For generic standalone stubs, validate type parameter arity matches interface (KO0008)
		if (classTypeParameters.Count > 0)
		{
			// The root interface (we've already validated there's only one) must have matching arity
			var rootInterface = rootInterfaces[0];
			var interfaceArity = rootInterface.TypeParameters.Length;

			if (classTypeParameters.Count != interfaceArity)
			{
				var location = classDeclaration.Identifier.GetLocation();
				var lineSpan = location.GetLineSpan();
				diagnostics.Add(new DiagnosticInfo(
					"KO0008",
					filePath,
					lineSpan.StartLinePosition.Line,
					lineSpan.StartLinePosition.Character,
					new[] {
						classSymbol.Name,
						classTypeParameters.Count.ToString(),
						rootInterface.Name,
						interfaceArity.ToString()
					}));

				// Return with diagnostics but no generation
				return new KnockOffTypeInfo(
					Namespace: namespaceName,
					ClassName: classSymbol.Name,
					ContainingTypes: containingTypes,
					TypeParameters: classTypeParameters,
					Interfaces: new EquatableArray<InterfaceInfo>(Array.Empty<InterfaceInfo>()),
					UserMethods: new EquatableArray<UserMethodInfo>(Array.Empty<UserMethodInfo>()),
					Diagnostics: new EquatableArray<DiagnosticInfo>(diagnostics.ToArray()),
					FlatMembers: new EquatableArray<InterfaceMemberInfo>(Array.Empty<InterfaceMemberInfo>()),
					FlatEvents: new EquatableArray<EventMemberInfo>(Array.Empty<EventMemberInfo>()),
					Strict: strict);
			}
		}

		// Get all implemented interfaces (includes inheritance chain)
		var allInterfaces = classSymbol.AllInterfaces;

		// Get the KnockOff class's assembly for accessibility checks
		var knockOffAssembly = classSymbol.ContainingAssembly;

		var interfaceInfos = new List<InterfaceInfo>();

		foreach (var iface in allInterfaces)
		{
			var members = new List<InterfaceMemberInfo>();
			var events = new List<EventMemberInfo>();

			var ifaceFullName = iface.ToDisplayString(FullyQualifiedWithNullability);
			foreach (var member in iface.GetMembers())
			{
				// Skip internal members from external assemblies
				if (!IsMemberAccessible(member, knockOffAssembly))
					continue;

				if (member is IPropertySymbol property)
				{
					members.Add(InterfaceMemberInfo.FromProperty(property, ifaceFullName));
				}
				else if (member is IMethodSymbol method && method.MethodKind == MethodKind.Ordinary)
				{
					members.Add(InterfaceMemberInfo.FromMethod(method, ifaceFullName));
				}
				else if (member is IEventSymbol eventSymbol)
				{
					events.Add(EventMemberInfo.FromEvent(eventSymbol, ifaceFullName));
				}
			}

			// Also get inherited interface members (Bug 4 fix)
			// This ensures IEnumerable<T> stubs also implement IEnumerable.GetEnumerator(), etc.
			foreach (var baseInterface in iface.AllInterfaces)
			{
				var baseIfaceFullName = baseInterface.ToDisplayString(FullyQualifiedWithNullability);
				foreach (var member in baseInterface.GetMembers())
				{
					if (!IsMemberAccessible(member, knockOffAssembly))
						continue;

					if (member is IPropertySymbol property)
					{
						members.Add(InterfaceMemberInfo.FromProperty(property, baseIfaceFullName));
					}
					else if (member is IMethodSymbol method && method.MethodKind == MethodKind.Ordinary)
					{
						members.Add(InterfaceMemberInfo.FromMethod(method, baseIfaceFullName));
					}
					else if (member is IEventSymbol eventSymbol)
					{
						events.Add(EventMemberInfo.FromEvent(eventSymbol, baseIfaceFullName));
					}
				}
			}

			if (members.Count > 0 || events.Count > 0)
			{
				// Extract simple interface name for AsXYZ() generation
				var simpleName = GetSimpleInterfaceName(iface.Name);

				interfaceInfos.Add(new InterfaceInfo(
					iface.ToDisplayString(FullyQualifiedWithNullability),
					iface.Name,
					simpleName,
					new EquatableArray<InterfaceMemberInfo>(members.ToArray()),
					new EquatableArray<EventMemberInfo>(events.ToArray())));
			}
		}

		// Get user-defined methods that could override interface methods
		var userMethods = GetUserDefinedMethods(classSymbol, interfaceInfos);

		// Create flat, deduplicated collections for the new v10.9+ API
		var (flatMembers, flatEvents) = FlattenAndDeduplicateMembers(interfaceInfos, allInterfaces);

		// Detect cross-interface signature conflicts (KO0100)
		// Same method name + same parameter types from DIFFERENT interfaces = conflict
		var methods = flatMembers.Where(m => !m.IsProperty && !m.IsIndexer).ToList();
		var conflictGroups = methods
			.GroupBy(m => GetMethodSignature(m))  // Group by name + param types (not return type)
			.Where(g => g.Count() > 1)  // Multiple methods with same signature
			.Where(g => g.Select(m => m.DeclaringInterfaceFullName).Distinct().Count() > 1)  // From DIFFERENT interfaces
			.ToList();

		foreach (var conflict in conflictGroups)
		{
			var interfaces = string.Join(", ", conflict.Select(m => ExtractSimpleTypeName(m.DeclaringInterfaceFullName)).Distinct());
			var location = classDeclaration.Identifier.GetLocation();
			var lineSpan = location.GetLineSpan();
			diagnostics.Add(new DiagnosticInfo(
				"KO0100",
				filePath,
				lineSpan.StartLinePosition.Line,
				lineSpan.StartLinePosition.Character,
				new[] { conflict.Key, interfaces }));
		}

		// If there are blocking diagnostics (KO0100), return early - code generation will be skipped
		if (diagnostics.Any(d => d.Id == "KO0100"))
		{
			return new KnockOffTypeInfo(
				Namespace: namespaceName,
				ClassName: classSymbol.Name,
				ContainingTypes: containingTypes,
				TypeParameters: classTypeParameters,
				Interfaces: new EquatableArray<InterfaceInfo>(Array.Empty<InterfaceInfo>()),
				UserMethods: new EquatableArray<UserMethodInfo>(Array.Empty<UserMethodInfo>()),
				Diagnostics: new EquatableArray<DiagnosticInfo>(diagnostics.ToArray()),
				FlatMembers: new EquatableArray<InterfaceMemberInfo>(Array.Empty<InterfaceMemberInfo>()),
				FlatEvents: new EquatableArray<EventMemberInfo>(Array.Empty<EventMemberInfo>()),
				Strict: strict);
		}

		return new KnockOffTypeInfo(
			Namespace: namespaceName,
			ClassName: classSymbol.Name,
			ContainingTypes: containingTypes,
			TypeParameters: classTypeParameters,
			Interfaces: new EquatableArray<InterfaceInfo>(interfaceInfos.ToArray()),
			UserMethods: userMethods,
			Diagnostics: new EquatableArray<DiagnosticInfo>(diagnostics.ToArray()),
			FlatMembers: new EquatableArray<InterfaceMemberInfo>(flatMembers),
			FlatEvents: new EquatableArray<EventMemberInfo>(flatEvents),
			Strict: strict);
	}

	/// <summary>
	/// Flattens all members from all interfaces into a single collection with deduplication.
	/// - Diamond inheritance: same member via multiple paths = one entry
	/// - `new` keyword hiding: keep only the most-derived member
	/// </summary>
	private static (InterfaceMemberInfo[] members, EventMemberInfo[] events) FlattenAndDeduplicateMembers(
		List<InterfaceInfo> interfaceInfos,
		ImmutableArray<INamedTypeSymbol> allInterfaces)
	{
		// Build interface inheritance lookup for determining "most derived"
		var interfaceInheritance = new Dictionary<string, HashSet<string>>();
		foreach (var iface in allInterfaces)
		{
			var fullName = iface.ToDisplayString(FullyQualifiedWithNullability);
			interfaceInheritance[fullName] = new HashSet<string>(
				iface.AllInterfaces.Select(i => i.ToDisplayString(FullyQualifiedWithNullability)));
		}

		// Deduplicate members by name + signature
		var memberMap = new Dictionary<string, InterfaceMemberInfo>();
		foreach (var iface in interfaceInfos)
		{
			foreach (var member in iface.Members)
			{
				var key = GetMemberKey(member);
				if (memberMap.TryGetValue(key, out var existing))
				{
					// Keep the most-derived version
					if (IsDerivedFrom(member.DeclaringInterfaceFullName, existing.DeclaringInterfaceFullName, interfaceInheritance))
					{
						memberMap[key] = member; // member's interface derives from existing's interface
					}
					// If existing derives from member's interface, keep existing (already in map)
				}
				else
				{
					memberMap[key] = member;
				}
			}
		}

		// Deduplicate events by name
		var eventMap = new Dictionary<string, EventMemberInfo>();
		foreach (var iface in interfaceInfos)
		{
			foreach (var evt in iface.Events)
			{
				var key = evt.Name;
				if (eventMap.TryGetValue(key, out var existing))
				{
					if (IsDerivedFrom(evt.DeclaringInterfaceFullName, existing.DeclaringInterfaceFullName, interfaceInheritance))
					{
						eventMap[key] = evt;
					}
				}
				else
				{
					eventMap[key] = evt;
				}
			}
		}

		return (memberMap.Values.ToArray(), eventMap.Values.ToArray());
	}

	/// <summary>
	/// Generates a unique key for a member based on name and signature.
	/// </summary>
	private static string GetMemberKey(InterfaceMemberInfo member)
	{
		if (member.IsProperty || member.IsIndexer)
		{
			// For properties/indexers, key is name + indexer params
			var indexerParams = member.IndexerParameters.Count > 0
				? $"[{string.Join(",", member.IndexerParameters.Select(p => p.Type))}]"
				: "";
			return $"prop:{member.Name}{indexerParams}";
		}
		else
		{
			// For methods, key is name + parameter types
			var paramTypes = string.Join(",", member.Parameters.Select(p => p.Type));
			return $"method:{member.Name}({paramTypes})";
		}
	}

	/// <summary>
	/// Gets method signature for conflict detection: name + parameter types (not return type).
	/// </summary>
	private static string GetMethodSignature(InterfaceMemberInfo member)
	{
		var paramTypes = string.Join(",", member.Parameters.Select(p => p.Type));
		return $"{member.Name}({paramTypes})";
	}

	/// <summary>
	/// Returns true if interfaceA derives from interfaceB.
	/// </summary>
	private static bool IsDerivedFrom(string interfaceA, string interfaceB, Dictionary<string, HashSet<string>> inheritanceLookup)
	{
		if (inheritanceLookup.TryGetValue(interfaceA, out var baseInterfaces))
		{
			return baseInterfaces.Contains(interfaceB);
		}
		return false;
	}

	/// <summary>
	/// Finds root interfaces - those not inherited by any other interface in the collection.
	/// For example, if someone declares ": IEntityBase, IValidateBase" and IValidateBase is
	/// in IEntityBase's hierarchy, only IEntityBase is a root.
	/// </summary>
	private static List<INamedTypeSymbol> FindRootInterfaces(ImmutableArray<INamedTypeSymbol> interfaces)
	{
		var roots = new List<INamedTypeSymbol>();

		foreach (var iface in interfaces)
		{
			var isInheritedByAnother = false;

			// Check if any other interface in the list inherits from this one
			foreach (var other in interfaces)
			{
				if (SymbolEqualityComparer.Default.Equals(iface, other))
					continue;

				// Does 'other' inherit from 'iface'?
				if (other.AllInterfaces.Any(i => SymbolEqualityComparer.Default.Equals(i, iface)))
				{
					isInheritedByAnother = true;
					break;
				}
			}

			if (!isInheritedByAnother)
			{
				roots.Add(iface);
			}
		}

		return roots;
	}

	/// <summary>
	/// Gets the chain of containing types for nested class support.
	/// Returns types from outermost to innermost.
	/// </summary>
	private static EquatableArray<ContainingTypeInfo> GetContainingTypes(INamedTypeSymbol classSymbol)
	{
		var containingTypes = new List<ContainingTypeInfo>();
		var current = classSymbol.ContainingType;

		while (current != null)
		{
			var keyword = current.TypeKind switch
			{
				TypeKind.Class => current.IsRecord ? "record" : "class",
				TypeKind.Struct => current.IsRecord ? "record struct" : "struct",
				TypeKind.Interface => "interface",
				_ => "class"
			};

			var accessibility = current.DeclaredAccessibility switch
			{
				Accessibility.Public => "public",
				Accessibility.Internal => "internal",
				Accessibility.Private => "private",
				Accessibility.Protected => "protected",
				Accessibility.ProtectedOrInternal => "protected internal",
				Accessibility.ProtectedAndInternal => "private protected",
				_ => ""
			};

			containingTypes.Insert(0, new ContainingTypeInfo(
				current.Name,
				keyword,
				accessibility));

			current = current.ContainingType;
		}

		return new EquatableArray<ContainingTypeInfo>(containingTypes.ToArray());
	}

	/// <summary>
	/// Gets simple name for AsXYZ() method (strips leading 'I' if followed by uppercase)
	/// </summary>
	private static string GetSimpleInterfaceName(string interfaceName)
	{
		// If starts with 'I' followed by uppercase letter, strip the 'I'
		if (interfaceName.Length > 1 &&
			interfaceName[0] == 'I' &&
			char.IsUpper(interfaceName[1]))
		{
			return interfaceName.Substring(1);
		}
		return interfaceName;
	}

	/// <summary>
	/// Extracts the simple type name from a fully qualified name.
	/// E.g., "global::MyNamespace.IUserService" -> "IUserService"
	/// </summary>
	private static string ExtractSimpleTypeName(string fullName)
	{
		// Remove global:: prefix if present
		var name = fullName;
		if (name.StartsWith("global::"))
			name = name.Substring(8);

		// Find the last dot to get the simple name
		var lastDot = name.LastIndexOf('.');
		if (lastDot >= 0)
			return name.Substring(lastDot + 1);

		return name;
	}

	/// <summary>
	/// Checks if a member is accessible from the KnockOff class.
	/// Internal members are only accessible from the same assembly.
	/// </summary>
	private static bool IsMemberAccessible(ISymbol member, IAssemblySymbol knockOffAssembly)
	{
		// Internal or ProtectedAndInternal members are only accessible from the same assembly
		if (member.DeclaredAccessibility == Accessibility.Internal ||
			member.DeclaredAccessibility == Accessibility.ProtectedAndInternal)
		{
			var memberAssembly = member.ContainingAssembly;
			return SymbolEqualityComparer.Default.Equals(memberAssembly, knockOffAssembly);
		}

		// Public and Protected members are accessible
		return true;
	}
}
