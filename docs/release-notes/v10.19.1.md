# KnockOff v10.19.1

**Release Date:** 2026-01-15
**Breaking Changes:** No

---

## Summary

Bug fix for inline stubs with method overloads that have incompatible signatures (different return types or parameter type mismatches from generic interface inheritance).

---

## What's New

### Bug Fix: Method Overloads with Different Return Types

When an interface has method overloads where one returns `T` and another returns `Task<T>`, inline stubs now correctly generate separate interceptors for each.

**Before:** Single interceptor caused compile error:

```csharp
public interface IFactory
{
    Task<IArea?> Fetch(long id);      // Async
    IArea Fetch(SampleEntity entity); // Sync
}

// Generated code had ONE Fetch interceptor typed for Task<IArea?>,
// causing CS0266 when sync overload tried to return Task<T> as T
```

**After:** Separate numbered interceptors with correct types:

```csharp
var stub = new Stubs.IFactory();
stub.Fetch1.OnCall = (ko, id) => Task.FromResult<IArea?>(result); // Async
stub.Fetch2.OnCall = (ko, entity) => result;                       // Sync
```

### Bug Fix: Generic Interface Inheritance Type Mismatch

When an interface inherits from a generic interface that also has a non-generic base (e.g., `IRule<T> : IRule`), inline stubs now correctly generate separate interceptors for each interface level.

**Before:** Single interceptor caused parameter type mismatch:

```csharp
public interface IRule { Task<IResult> Execute(ITarget target, CancellationToken? token); }
public interface IRule<T> : IRule { Task<IResult> Execute(T target, CancellationToken? token); }
public interface IMyRule : IRule<ISpecificTarget> { }

// Generated code had ONE Execute interceptor typed for ISpecificTarget,
// causing CS1503 when IRule.Execute passed ITarget to method expecting ISpecificTarget
```

**After:** Separate numbered interceptors with correct parameter types:

```csharp
var stub = new Stubs.IMyRule();
stub.Execute1.OnCall = (ko, target, ct) => result; // Takes ISpecificTarget
stub.Execute2.OnCall = (ko, target, ct) => result; // Takes ITarget
```

---

## Technical Details

The fix adds intelligent overload grouping in `InlineModelBuilder`:

1. Methods are grouped by name
2. Compatibility is checked - methods can share an interceptor if:
   - Parameter types are compatible (same name â†’ same type)
   - Return types match, OR same parameters (delegation case)
3. Incompatible overloads get separate numbered interceptors (`Method1`, `Method2`)

This preserves the existing behavior for BCL interfaces where methods with same parameters but different return types (like `IEnumerable.GetEnumerator`) use delegation.

---

## Migration Guide

No migration required. This is a drop-in replacement for v10.19.0.

If you previously couldn't stub interfaces with incompatible method overloads, they now work. The interceptor API uses numbered suffixes (`Fetch1`, `Fetch2`) when methods have incompatible signatures.
