# v10.10.0 - Inline Stubs Generic Methods Support

**Release Date:** 2026-01-08
**NuGet:** [KnockOff 10.10.0](https://nuget.org/packages/KnockOff/10.10.0)

## Overview

This release adds generic method support to inline stubs (`[KnockOff<T>]` pattern). Previously, only standalone stubs (`[KnockOff]` on a partial class) supported interfaces with generic methods. Now both patterns support the full `Of<T>()` API for generic method tracking and callbacks.

## New Feature

### Generic Methods in Inline Stubs

Inline stubs now fully support interfaces with generic methods:

```csharp
public interface ISerializer
{
    T Deserialize<T>(string json);
    void Serialize<T>(T value);
}

[KnockOff<ISerializer>]
public partial class MyTests
{
    [Fact]
    public void Deserialize_TracksCallsByType()
    {
        var stub = new Stubs.ISerializer();
        ISerializer serializer = stub;

        serializer.Deserialize<User>("{\"name\":\"Alice\"}");
        serializer.Deserialize<Order>("{\"id\":123}");
        serializer.Deserialize<User>("{\"name\":\"Bob\"}");

        // Track calls per type argument
        Assert.Equal(2, stub.Deserialize.Of<User>().CallCount);
        Assert.Equal(1, stub.Deserialize.Of<Order>().CallCount);

        // Aggregate tracking across all types
        Assert.Equal(3, stub.Deserialize.TotalCallCount);
        Assert.True(stub.Deserialize.WasCalled);
    }

    [Fact]
    public void Deserialize_OnCall_ReturnsConfiguredValue()
    {
        var stub = new Stubs.ISerializer();
        ISerializer serializer = stub;

        var expected = new User { Name = "Test" };
        stub.Deserialize.Of<User>().OnCall = (ko, json) => expected;

        var result = serializer.Deserialize<User>("{}");

        Assert.Same(expected, result);
    }
}
```

### Features Included

- **`Of<T>()` pattern** - Get typed handler for specific type arguments
- **Per-type tracking** - `CallCount`, `WasCalled`, `LastCallArg` tracked separately per type
- **Aggregate tracking** - `TotalCallCount`, `WasCalled`, `CalledTypeArguments` across all types
- **Type-specific callbacks** - `OnCall` delegates per type argument combination
- **Multiple type parameters** - Full support for `Method<T1, T2>()` patterns with `Of<T1, T2>()`
- **Constraint preservation** - Type constraints (`where T : class`, `where T : new()`) properly enforced
- **Smart defaults** - Value types return `default`, reference types with parameterless ctors are instantiated

### Why This Matters

This unblocks scenarios where you need to stub interfaces with generic methods using the inline pattern:

```csharp
// Previously failed with: "The type or namespace name 'T' could not be found"
[KnockOff<IRuleManager>]  // Now works!
public partial class RuleTests
{
    [Fact]
    public void Test()
    {
        var stub = new Stubs.IRuleManager();
        // Use stub for testing...
    }
}
```

## Technical Details

The generator now produces the same two-layer handler pattern for inline stubs that was already available for standalone stubs:

1. **Outer interceptor class** - Contains `Of<T>()` method and aggregate tracking
2. **Nested `TypedHandler<T>` class** - Contains per-type tracking and callbacks

```csharp
// Generated structure (simplified)
public sealed class ISerializer_DeserializeInterceptor
{
    private readonly Dictionary<Type, object> _typedHandlers = new();

    public DeserializeTypedHandler<T> Of<T>() { ... }

    public int TotalCallCount => _typedHandlers.Values.Sum(h => h.CallCount);
    public bool WasCalled => _typedHandlers.Values.Any(h => h.WasCalled);

    public sealed class DeserializeTypedHandler<T> : IGenericMethodCallTracker
    {
        public int CallCount { get; private set; }
        public string? LastCallArg { get; private set; }
        public DeserializeDelegate? OnCall { get; set; }
        // ...
    }
}
```

---

**Full Changelog**: https://github.com/NeatooDotNet/KnockOff/compare/v10.9.0...v10.10.0
