# v10.6.0 - Generic Methods Support

**Release Date:** 2026-01-04
**NuGet:** [KnockOff 10.6.0](https://nuget.org/packages/KnockOff/10.6.0)

## Overview

Adds full support for generic methods using the `.Of<T>()` pattern, enabling type-specific behavior configuration and call tracking.

## New Feature

### Generic Method Handlers

Generic methods now generate a two-tier handler structure with the `.Of<T>()` pattern:

```csharp
public interface ISerializer
{
    T Deserialize<T>(string json);
    TOut Convert<TIn, TOut>(TIn input);
}

[KnockOff]
public partial class SerializerKnockOff : ISerializer { }
```

Configure behavior per type argument:

```csharp
var knockOff = new SerializerKnockOff();

// Configure for specific type
knockOff.ISerializer.Deserialize.Of<User>().OnCall = (ko, json) =>
    JsonSerializer.Deserialize<User>(json)!;

// Different behavior for different types
knockOff.ISerializer.Deserialize.Of<Order>().OnCall = (ko, json) =>
    new Order { Id = 123 };
```

### Per-Type Call Tracking

Track calls separately for each type argument:

```csharp
ISerializer service = knockOff;

service.Deserialize<User>("{...}");
service.Deserialize<User>("{...}");
service.Deserialize<Order>("{...}");

// Per-type tracking
Assert.Equal(2, knockOff.ISerializer.Deserialize.Of<User>().CallCount);
Assert.Equal(1, knockOff.ISerializer.Deserialize.Of<Order>().CallCount);

// Aggregate tracking
Assert.Equal(3, knockOff.ISerializer.Deserialize.TotalCallCount);
Assert.True(knockOff.ISerializer.Deserialize.WasCalled);
```

### Called Type Arguments

See which type arguments were used:

```csharp
var calledTypes = knockOff.ISerializer.Deserialize.CalledTypeArguments;
// Returns: [typeof(User), typeof(Order)]
```

### Multiple Type Parameters

Methods with multiple type parameters use tuple-based tracking:

```csharp
knockOff.ISerializer.Convert.Of<string, int>().OnCall = (ko, s) => s.Length;
knockOff.ISerializer.Convert.Of<int, string>().OnCall = (ko, i) => i.ToString();

var calledTypes = knockOff.ISerializer.Convert.CalledTypeArguments;
// Returns: [(typeof(string), typeof(int)), (typeof(int), typeof(string))]
```

### Constraint Propagation

Type constraints are preserved on the `.Of<T>()` method:

```csharp
public interface IFactory
{
    T Create<T>() where T : class, IEntity, new();
}

// Constraints enforced at compile time
knockOff.IFactory.Create.Of<MyEntity>().OnCall = (ko) => new MyEntity();
```

### Smart Defaults

Unconfigured generic methods use smart defaults at runtime:
- **Value types**: Return `default(T)` (0, false, etc.)
- **Types with `new()` constraint**: Return `new T()`
- **Nullable return types**: Return `null`
- **Other types**: Throw `InvalidOperationException` with helpful message

### Parameter Tracking

Non-generic parameters are tracked in the typed handler:

```csharp
service.Deserialize<User>("{\"name\":\"Alice\"}");
service.Deserialize<User>("{\"name\":\"Bob\"}");

Assert.Equal("{\"name\":\"Bob\"}", knockOff.ISerializer.Deserialize.Of<User>().LastCallArg);
Assert.Equal(2, knockOff.ISerializer.Deserialize.Of<User>().AllCalls.Count);
```

## Handler API

| Member | Description |
|--------|-------------|
| `.Of<T>()` | Get typed handler for specific type argument(s) |
| `.TotalCallCount` | Total calls across all type arguments |
| `.WasCalled` | True if called with any type argument |
| `.CalledTypeArguments` | List of all type arguments used |
| `.Reset()` | Clear all typed handlers |

### Typed Handler Members

| Member | Description |
|--------|-------------|
| `.CallCount` | Calls with this type argument |
| `.WasCalled` | True if called with this type argument |
| `.OnCall` | Callback to configure return value |
| `.LastCallArg` | Last non-generic argument (if any) |
| `.AllCalls` | All non-generic arguments (if any) |
| `.Reset()` | Clear this typed handler |

## Technical Details

- Handler classes use `Dictionary<Type, object>` for runtime type-keyed storage
- Multiple type parameters use tuple keys: `Dictionary<(Type, Type), object>`
- Smart defaults use reflection to check for parameterless constructors
- Constraints propagated to both `.Of<T>()` method and nested typed handler class

---

**Full Changelog**: https://github.com/NeatooDotNet/KnockOff/compare/v10.5.2...v10.6.0
