# v10.5.0 - Interface Spy Architecture

**Release Date:** 2026-01-03
**NuGet:** [KnockOff 10.5.0](https://nuget.org/packages/KnockOff/10.5.0)

## Overview

Major architectural redesign introducing **interface spy properties** for cleaner multi-interface support, **separate overload handlers** for simpler callbacks, and **property-based OnCall** syntax.

## Breaking Changes

### 1. `Spy` Replaced with Interface Spy Properties

Each interface now gets its own spy property for tracking and configuration.

**Before:**
```csharp
knockOff.Spy.GetUser.WasCalled
knockOff.Spy.Name.SetCount
```

**After:**
```csharp
knockOff.IUserService.GetUser.WasCalled
knockOff.IUserService.Name.SetCount
```

**Migration:** Replace `Spy.` with the interface name (e.g., `IUserService.`).

### 2. `OnCall` Is Now a Property (Not a Method)

Callbacks now use property assignment instead of method invocation.

**Before:**
```csharp
knockOff.Spy.GetById.OnCall((RepoKnockOff ko, int id) => new User { Id = id });
```

**After:**
```csharp
knockOff.IRepository.GetById.OnCall = (ko, id) => new User { Id = id };
```

**Benefits:**
- Simpler syntax without explicit type annotations for most cases
- Clearer assignment semantics
- Better IntelliSense support

### 3. Overloaded Methods Have Separate Handlers (1-Based Suffix)

Each method overload now gets its own dedicated handler with independent tracking.

**Before:**
```csharp
// Unified handler with nullable params and delegate casting
knockOff.Spy.Process.OnCall(
    (ServiceKnockOff.ProcessHandler.ProcessDelegate1)
    ((ko, data, priority) => { }));

// Tracking had nullable wrappers
Assert.Null(knockOff.Spy.Process.AllCalls[0].priority);
```

**After:**
```csharp
// Each overload has its own handler (1-based numbering)
knockOff.IService.Process1.OnCall = (ko, data) => { };           // Process(string)
knockOff.IService.Process2.OnCall = (ko, data, priority) => { }; // Process(string, int)

// Tracking is per-overload with proper types
Assert.Equal(5, knockOff.IService.Process2.LastCallArgs.Value.priority); // int, not int?
```

**Benefits:**
- No delegate casting required
- Proper types (no nullable wrappers)
- Clear which overload was called
- Independent tracking per overload

**Note:** Methods without overloads don't get a suffix.

### 4. Backing Fields Are Interface-Prefixed

Backing fields now include the interface name for clarity with multiple interfaces.

**Before:**
```csharp
knockOff.NameBacking = "value";
knockOff.StringIndexerBacking["key"] = value;
```

**After:**
```csharp
knockOff.IUserService_NameBacking = "value";
knockOff.IPropertyStore_StringIndexerBacking["key"] = value;
```

### 5. Multi-Param Callbacks Use Individual Parameters

Callbacks now receive parameters individually instead of as a tuple.

**Before:**
```csharp
knockOff.Spy.Create.OnCall((RepoKnockOff ko, (string name, int value) args) =>
    new Entity { Name = args.name });
```

**After:**
```csharp
knockOff.IRepository.Create.OnCall = (ko, name, value) =>
    new Entity { Name = name };
```

### 6. Handler Class Naming

Handler class names now include the interface prefix.

**Before:** `GetUserHandler`
**After:** `IUserService_GetUserHandler`

## New Features

### Smart Default Return Values

Unconfigured methods now return sensible defaults instead of throwing exceptions:

| Return Type | Default Value | Example |
|-------------|---------------|---------|
| Value types | `default` | `int` → `0`, `bool` → `false` |
| Nullable refs | `null` | `string?` → `null` |
| Types with `new()` | `new T()` | `List<T>` → empty list |
| Collection interfaces | concrete type | `IList<T>` → `new List<T>()` |
| Other non-nullable | throws | `string`, `IDisposable` |

```csharp
var knockOff = new ServiceKnockOff();
IService service = knockOff;

// No configuration needed - returns sensible defaults
var count = service.GetCount();           // 0 (value type)
var items = service.GetItems();           // new List<string>() (has new())
var lookup = service.GetLookup();         // new Dictionary<string,int>()
var list = service.GetIList();            // new List<string>() (IList<T> → List<T>)
var optional = service.GetOptional();     // null (nullable ref)

// Still throws for types that can't be safely defaulted
service.GetDisposable();  // throws - can't instantiate IDisposable
```

**Collection Interface Mapping:**

| Interface | Concrete Type |
|-----------|---------------|
| `IEnumerable<T>` | `List<T>` |
| `ICollection<T>` | `List<T>` |
| `IList<T>` | `List<T>` |
| `IReadOnlyList<T>` | `List<T>` |
| `IReadOnlyCollection<T>` | `List<T>` |
| `IDictionary<K,V>` | `Dictionary<K,V>` |
| `IReadOnlyDictionary<K,V>` | `Dictionary<K,V>` |
| `ISet<T>` | `HashSet<T>` |

### Multiple Interfaces with Separate Spies

Each interface gets its own spy property, making multi-interface stubs clearer:

```csharp
[KnockOff]
public partial class DataContextKnockOff : IRepository, IUnitOfWork { }

// Each interface tracked separately
Assert.True(knockOff.IRepository.Save.WasCalled);
Assert.True(knockOff.IUnitOfWork.Commit.WasCalled);

// Configure each interface independently
knockOff.IRepository.GetById.OnCall = (ko, id) => new User { Id = id };
knockOff.IUnitOfWork.CommitAsync.OnCall = (ko) => Task.CompletedTask;
```

### Simplified Overload Callbacks

No more delegate casting for overloaded methods:

```csharp
public interface ICalculator
{
    int Calculate(int value);
    int Calculate(int a, int b);
}

// Simple property assignment
knockOff.ICalculator.Calculate1.OnCall = (ko, value) => value * 2;
knockOff.ICalculator.Calculate2.OnCall = (ko, a, b) => a + b;

// Clear tracking per overload
Assert.Equal(1, knockOff.ICalculator.Calculate1.CallCount);
Assert.Equal(2, knockOff.ICalculator.Calculate2.CallCount);
```

## Migration Guide

### Quick Search & Replace

1. Replace `Spy.` with interface spy property:
   - `knockOff.Spy.` → `knockOff.IYourInterface.`

2. Replace `.OnCall((` with `.OnCall = (` (remove explicit types for most cases):
   - `.OnCall((ServiceKnockOff ko, int id) =>` → `.OnCall = (ko, id) =>`

3. Update backing field references:
   - `knockOff.PropertyBacking` → `knockOff.IInterface_PropertyBacking`

4. Update overloaded method handlers:
   - `Spy.Process.OnCall((Delegate0)...)` → `IService.Process1.OnCall = ...`
   - `Spy.Process.OnCall((Delegate1)...)` → `IService.Process2.OnCall = ...`

### Example Migration

**Before (v10.4.x):**
```csharp
var knockOff = new UserServiceKnockOff();

knockOff.Spy.GetUser.OnCall((UserServiceKnockOff ko, int id) =>
    new User { Id = id });
knockOff.Spy.Name.OnGet = (ko) => "Test";
knockOff.NameBacking = "Default";

Assert.True(knockOff.Spy.GetUser.WasCalled);
Assert.Equal(1, knockOff.Spy.Name.GetCount);
```

**After (v10.5.0):**
```csharp
var knockOff = new UserServiceKnockOff();

knockOff.IUserService.GetUser.OnCall = (ko, id) =>
    new User { Id = id };
knockOff.IUserService.Name.OnGet = (ko) => "Test";
knockOff.IUserService_NameBacking = "Default";

Assert.True(knockOff.IUserService.GetUser.WasCalled);
Assert.Equal(1, knockOff.IUserService.Name.GetCount);
```

## Out/Ref Parameters

Out and ref parameters still require explicit delegate types (C# language requirement):

```csharp
knockOff.IParser.TryParse.OnCall =
    (IParser_TryParseHandler.TryParseDelegate)((ko, string input, out int result) =>
    {
        return int.TryParse(input, out result);
    });
```

## Documentation

- Synced 68 code snippets from `KnockOff.Documentation.Samples` to documentation
- All code examples in docs are now compiled and tested
- Added snippet markers for automatic sync via `scripts/extract-snippets.ps1`

---

**Full Changelog**: https://github.com/NeatooDotNet/KnockOff/compare/v10.4.1...v10.5.0
