# v10.21.0 - Interceptor API Redesign

**Release Date:** 2026-01-16

## Summary

Major API redesign for standalone stubs. The `OnCall()` method now returns tracking objects, enabling method overloading support via compiler overload resolution.

## Breaking Changes

Standalone stubs now use `OnCall()` as a **method** returning `IMethodTracking`:

```csharp
// Before
stub.DoWork.OnCall = (ko) => result;
var count = stub.DoWork.CallCount;

// After
var tracking = stub.DoWork.OnCall((ko) => result);
var count = tracking.CallCount;
```

## New Features

### Method Overloading Support

Overloaded methods on the same interface now work via compiler overload resolution:

```csharp
public interface IFormatter
{
    string Format(string input);
    string Format(string input, bool uppercase);
    string Format(string input, int maxLength);
}

[KnockOff]
public partial class FormatterStub : IFormatter { }

var stub = new FormatterStub();

// Compiler resolves based on lambda parameter types
stub.Format.OnCall((ko, input) => input.ToUpper());
stub.Format.OnCall((ko, input, uppercase) => uppercase ? input.ToUpper() : input);
stub.Format.OnCall((ko, input, maxLength) => input[..Math.Min(input.Length, maxLength)]);

IFormatter svc = stub;
svc.Format("hello");           // Uses first overload
svc.Format("hello", true);     // Uses second overload
svc.Format("hello", 3);        // Uses third overload
```

### Times Constraints

Verify call counts with `Times`:

```csharp
var tracking = stub.Save.OnCall((ko, entity) => { });

service.Save(entity1);
service.Save(entity2);

Assert.True(Times.Exactly(2).Verify(tracking.CallCount));
Assert.True(Times.AtLeast(1).Verify(tracking.CallCount));
```

Available constraints:
- `Times.Once` - Exactly one call
- `Times.Exactly(n)` - Exactly n calls
- `Times.AtLeast(n)` - At least n calls
- `Times.AtMost(n)` - At most n calls
- `Times.Forever` - Any number of calls (default)

### Call Sequencing

Configure different behaviors for successive calls:

```csharp
stub.GetNext.OnCall((ko) => 1, Times.Once)
    .ThenCall((ko) => 2, Times.Once)
    .ThenCall((ko) => 3, Times.Forever);

ISequence svc = stub;
Assert.Equal(1, svc.GetNext());  // First call
Assert.Equal(2, svc.GetNext());  // Second call
Assert.Equal(3, svc.GetNext());  // Third and subsequent
```

### IMethodTracking Interface

All `OnCall()` methods return tracking objects:

```csharp
public interface IMethodTracking<T>
{
    bool WasCalled { get; }
    int CallCount { get; }
    T LastArg { get; }
    void Reset();
}

public interface IMethodTrackingArgs<T>
{
    bool WasCalled { get; }
    int CallCount { get; }
    T LastArgs { get; }  // Tuple for multiple parameters
    void Reset();
}
```

### Improved KO0100 Diagnostic

KO0100 now only fires for identical signatures across different interfaces:

```csharp
// OK - same interface, different signatures
public interface IService
{
    void Process(int value);
    void Process(string value);
}

// KO0100 - different interfaces, SAME signature
public interface IFoo { void Process(int value); }
public interface IBar { void Process(int value); }

[KnockOff]
public partial class Stub : IFoo, IBar { }  // Error: Can't distinguish which interface's method was called
```

## Migration Guide

### Standalone Stubs

| Before | After |
|--------|-------|
| `stub.Method.OnCall = callback` | `var tracking = stub.Method.OnCall(callback)` |
| `stub.Method.CallCount` | `tracking.CallCount` |
| `stub.Method.WasCalled` | `tracking.WasCalled` |
| `stub.Method.LastCallArg` | `tracking.LastArg` |
| `stub.Method1.OnCall = ...` | `stub.Method.OnCall((ko, param) => ...)` |

### Inline Stubs

No changes required. Inline stubs continue to use property-based `OnCall`.
