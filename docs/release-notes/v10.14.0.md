# v10.14.0 - Generic Standalone Stubs

**Release Date:** 2026-01-11

## Summary

This release adds support for **generic standalone stubs** - stub classes with their own type parameters that implement generic interfaces. This enables creating reusable stub classes that work with any type argument.

## New Feature: Generic Standalone Stubs

Previously, stubbing generic interfaces required creating separate concrete stubs for each type:

```csharp
// Before: separate stub for each type
[KnockOff]
public partial class UserRepositoryStub : IRepository<User> { }

[KnockOff]
public partial class OrderRepositoryStub : IRepository<Order> { }
```

Now you can create a single generic stub class:

```csharp
// After: one reusable generic stub
[KnockOff]
public partial class RepositoryStub<T> : IRepository<T> where T : class { }

// Use with any type
var userRepo = new RepositoryStub<User>();
var orderRepo = new RepositoryStub<Order>();
```

### Usage

```csharp
var stub = new RepositoryStub<User>();
IRepository<User> repo = stub;

// Configure behavior
stub.GetById.OnCall = (ko, id) => new User { Id = id, Name = $"User-{id}" };
stub.Save.OnCall = (ko, entity) => { /* save logic */ };

// Use in tests
var user = repo.GetById(42);
repo.Save(new User { Id = 1 });

// Verify calls
Assert.Equal(1, stub.GetById.CallCount);
Assert.Equal(1, stub.Save.CallCount);
```

### Multiple Type Parameters

```csharp
public interface ICache<TKey, TValue> where TKey : notnull where TValue : class
{
    TValue? Get(TKey key);
    void Set(TKey key, TValue value);
}

[KnockOff]
public partial class CacheStub<TKey, TValue> : ICache<TKey, TValue>
    where TKey : notnull
    where TValue : class { }

// Usage
var cache = new CacheStub<string, User>();
cache.Get.OnCall = (ko, key) => new User { Name = key };
```

### Constraints

Type parameter constraints must match between stub class and interface:

```csharp
public interface IRepository<T> where T : class { }

// Correct: matching constraint
[KnockOff]
public partial class RepositoryStub<T> : IRepository<T> where T : class { }
```

## New Diagnostic: KO0008

**KO0008: Type parameter count mismatch**

Reports an error when a generic standalone stub has a different number of type parameters than the interface it implements.

```csharp
public interface IRepository<T> { }

// Error KO0008: Generic standalone stub 'BadStub<T, TExtra>' has 2 type parameter(s)
// but interface 'IRepository<T>' has 1. Type parameter count must match exactly.
[KnockOff]
public partial class BadStub<T, TExtra> : IRepository<T> { }
```

**Fix:** Ensure stub class has same number of type parameters as interface:

```csharp
[KnockOff]
public partial class GoodStub<T> : IRepository<T> { }
```

## Documentation

- **docs/guides/generics.md** - New "Generic Standalone Stubs" section
- **docs/diagnostics.md** - New file documenting all KnockOff diagnostics
- **README.md** - Added generic standalone stubs to Features table

## Choosing Between Patterns

| Pattern | When to Use |
|---------|-------------|
| **Concrete stubs** (`UserRepoStub : IRepository<User>`) | One-off stubs, specific test scenarios |
| **Generic stubs** (`RepoStub<T> : IRepository<T>`) | Reusable across multiple entity types |

Both patterns are fully supported and generate identical interceptor APIs.

## Upgrade Notes

No breaking changes. Existing concrete stubs continue to work unchanged.
