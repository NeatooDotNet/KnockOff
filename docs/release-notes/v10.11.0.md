# v10.11.0 - Mixed Generic/Non-Generic Overload Fix

**Release Date:** 2026-01-09
**NuGet:** [KnockOff 10.11.0](https://nuget.org/packages/KnockOff/10.11.0)

## Overview

This release fixes a bug where interfaces with both generic and non-generic overloads of the same method name would generate broken code. The generator now correctly creates separate interceptors for each overload type.

## Bug Fix

### Mixed Overloads Now Work

Previously, interfaces like `IRuleManager` with both `RunRule(IRule r, token)` and `RunRule<T>(token)` would fail to compile because the generator incorrectly merged them into a single generic interceptor.

**Before (broken):**
```csharp
// Only one interceptor generated - wrong!
public IRuleManager_RunRuleInterceptor RunRule { get; }

// Non-generic implementation tried to call generic API
RunRule.RecordCall(r, token);  // Error: no such method
```

**After (fixed):**
```csharp
// Two separate interceptors
public IRuleManager_RunRuleInterceptor RunRule { get; }        // Non-generic
public IRuleManager_RunRuleGenericInterceptor RunRuleGeneric { get; }  // Generic

// Each implementation uses correct interceptor
RunRule.RecordCall(r, token);           // Non-generic calls
RunRuleGeneric.Of<T>().RecordCall(...); // Generic calls
```

### Usage Example

```csharp
[KnockOff<IRuleManager>]
public partial class RuleManagerTests
{
    [Fact]
    public async Task RunRule_NonGeneric_TracksCall()
    {
        var stub = new Stubs.IRuleManager();
        IRuleManager ruleManager = stub;

        await ruleManager.RunRule(someRule, null);

        // Non-generic overload uses RunRule interceptor
        Assert.True(stub.RunRule.WasCalled);
        Assert.Equal(1, stub.RunRule.CallCount);
    }

    [Fact]
    public async Task RunRule_Generic_TracksCall()
    {
        var stub = new Stubs.IRuleManager();
        IRuleManager ruleManager = stub;

        await ruleManager.RunRule<MyRule>(null);

        // Generic overload uses RunRuleGeneric interceptor with Of<T>()
        Assert.True(stub.RunRuleGeneric.WasCalled);
        Assert.True(stub.RunRuleGeneric.Of<MyRule>().WasCalled);
    }
}
```

## Technical Details

The fix introduces infrastructure for detecting and splitting "mixed" method groups:

1. **Detection**: `IsMixedMethodGroup()` identifies groups with both generic and non-generic overloads
2. **Splitting**: `SplitMixedGroup()` creates separate sub-groups with appropriate naming
3. **Generation**: Both inline stubs and flat API now generate two interceptor classes and properties for mixed groups
4. **Routing**: Method implementations are routed to the correct interceptor based on whether the specific overload is generic

### Naming Convention

For a method named `RunRule` with mixed overloads:
- Non-generic overloads use `RunRule` interceptor
- Generic overloads use `RunRuleGeneric` interceptor (suffix added)

## Additional Fix

Fixed a bug where generic async methods (`Task`/`ValueTask` return types) would not properly return the callback result when `OnCall` was set.

---

**Full Changelog**: https://github.com/NeatooDotNet/KnockOff/compare/v10.10.1...v10.11.0
