# v10.9.0 - Flat API & Class Stub Composition

**Release Date:** TBD
**NuGet:** [KnockOff 10.9.0](https://nuget.org/packages/KnockOff/10.9.0)

## Overview

This release introduces a unified flat API across all stub types and refactors class stubs to use composition. These changes simplify the API surface and make standalone stubs consistent with inline stubs.

## Breaking Changes

### 1. Flat API Access (Standalone Stubs)

**Before (v10.8.0):** Interceptors were accessed via interface-named properties:

```csharp
var stub = new UserServiceKnockOff();
stub.IUserService.GetUser.WasCalled;
stub.IUserService.GetUser.OnCall = (ko, id) => new User { Id = id };
stub.IUserService.Name.SetCount;
```

**After (v10.9.0):** Interceptors are accessed directly on the stub:

```csharp
var stub = new UserServiceKnockOff();
stub.GetUser.WasCalled;
stub.GetUser.OnCall = (ko, id) => new User { Id = id };
stub.Name.SetCount;
```

### 2. Single Interface Constraint

Standalone stubs must now implement exactly **one interface** (plus its inheritance chain).

```csharp
// Valid - single interface
[KnockOff]
public partial class UserServiceKnockOff : IUserService { }

// Valid - interface with inheritance chain
[KnockOff]
public partial class EntityKnockOff : IEntityBase { }  // IEntityBase : IValidateBase : INotifyPropertyChanged

// INVALID - multiple unrelated interfaces (emits KO0010)
[KnockOff]
public partial class MultiKnockOff : IUserService, ILogger { }
```

**Alternative for multiple interfaces:** Use inline stubs instead:

```csharp
[KnockOff<IUserService>]
[KnockOff<ILogger>]
public partial class MyTests
{
    [Fact]
    public void Test()
    {
        var userService = new Stubs.IUserService();
        var logger = new Stubs.ILogger();
        // ...
    }
}
```

### 3. Class Stub Composition Pattern

**Before (v10.8.0):** Class stubs inherited from the target class and accessed interceptors via `.Interceptor`:

```csharp
var stub = new Stubs.UserService();
stub.Interceptor.GetUser.OnCall = (ko, id) => new User { Id = id };
UserService service = stub;  // Direct assignment
```

**After (v10.9.0):** Class stubs use composition with direct interceptor access and `.Object` property:

```csharp
var stub = new Stubs.UserService();
stub.GetUser.OnCall = (ko, id) => new User { Id = id };  // Direct access!
UserService service = stub.Object;  // Use .Object for type
```

### 4. Event API Simplified

Event interceptors now use `AddCount`/`RemoveCount` instead of `SubscribeCount`/`UnsubscribeCount`, and `Raise()` always requires parameters:

```csharp
// Before
Assert.Equal(1, stub.ISource.DataReceived.SubscribeCount);
stub.ISource.DataReceived.Raise("data");

// After
Assert.Equal(1, stub.DataReceived.AddCount);
stub.DataReceived.Raise(null, "data");  // sender required for EventHandler<T>
```

## Migration Guide

### Find/Replace Patterns

| Pattern | Replace With |
|---------|--------------|
| `stub.IInterface.` | `stub.` |
| `stub.Interceptor.Member` | `stub.Member` |
| `TargetClass x = stub;` | `TargetClass x = stub.Object;` |
| `.SubscribeCount` | `.AddCount` |
| `.UnsubscribeCount` | `.RemoveCount` |
| `.Raise(e)` | `.Raise(null, e)` (for EventHandler<T>) |
| `.Raise()` | `.Raise(null, EventArgs.Empty)` (for EventHandler) |

### Multiple Interface Stubs

If you have stubs implementing multiple interfaces, split them:

```csharp
// Before
[KnockOff]
public partial class DataContextKnockOff : IRepository, IUnitOfWork { }

// After - option 1: separate stubs
[KnockOff]
public partial class RepositoryKnockOff : IRepository { }

[KnockOff]
public partial class UnitOfWorkKnockOff : IUnitOfWork { }

// After - option 2: inline stubs
[KnockOff<IRepository>]
[KnockOff<IUnitOfWork>]
public partial class DataContextTests { }
```

## Benefits

1. **Simpler API**: `stub.Method` instead of `stub.IInterface.Method`
2. **Consistent**: Standalone, inline, and class stubs now use identical access patterns
3. **No naming conflicts**: Interceptor properties can match class member names
4. **Flattened hierarchy**: All members from inherited interfaces accessible at the same level
5. **Clearer semantics**: Stub is configuration, `.Object` is the instance (for class stubs)

## Unified API Examples

All stub types now follow the same pattern:

```csharp
// Standalone interface stub
var userStub = new UserServiceKnockOff();
userStub.GetUser.OnCall = (ko, id) => new User();
IUserService service = userStub;

// Inline interface stub
var inlineStub = new Stubs.IUserService();
inlineStub.GetUser.OnCall = (ko, id) => new User();
IUserService service = inlineStub;

// Class stub - SAME pattern for interceptors!
var emailStub = new Stubs.EmailService();
emailStub.Send.OnCall = (ko, to, subj, body) => { };
EmailService service = emailStub.Object;  // .Object to get instance
```

## Technical Details (Class Stubs)

The composition pattern generates:

1. **Wrapper class** - Contains interceptor properties directly
2. **`.Object` property** - Returns the actual class instance
3. **Nested `Impl` class** - Inherits from target, intercepts calls

```csharp
// Generated structure (simplified)
public class UserServiceStub
{
    public UserService_GetUserInterceptor GetUser { get; } = new();

    public UserService Object { get; }

    public UserServiceStub() => Object = new Impl(this);

    private sealed class Impl : UserService
    {
        private readonly UserServiceStub _stub;

        public override User GetUser(int id)
        {
            _stub.GetUser.RecordCall(id);
            if (_stub.GetUser.OnCall is { } onCall) return onCall(_stub, id);
            return base.GetUser(id);
        }
    }
}
```

## New Diagnostic

| Code | Description |
|------|-------------|
| KO0010 | KnockOff stubs should implement a single interface |

---

**Full Changelog**: https://github.com/NeatooDotNet/KnockOff/compare/v10.8.0...v10.9.0
