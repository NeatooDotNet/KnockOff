# v10.17.0 - Fluent Strict Mode API

**Release Date:** 2026-01-13

## Summary

This release adds a fluent `.Strict()` extension method for enabling strict mode on any stub type. All generated stubs now implement the `IKnockOffStub` interface.

## New Feature: Fluent Strict Mode

The recommended way to enable strict mode is now the fluent `.Strict()` extension method:

```csharp
// Standalone stub
var stub = new UserServiceKnockOff().Strict();

// Inline stub
var stub = new Stubs.IUserService().Strict();
```

The extension method:
- Works with any stub type (standalone, inline interface, inline class, inline delegate)
- Returns the same instance for fluent chaining
- Sets `Strict = true` on the stub

### Previous Approaches Still Work

All previous approaches remain supported:

```csharp
// Property setter (standalone)
var stub = new UserServiceKnockOff();
stub.Strict = true;

// Constructor parameter (inline)
var stub = new Stubs.IUserService(strict: true);

// Attribute default
[KnockOff(Strict = true)]
public partial class StrictUserServiceKnockOff : IUserService { }
```

## New Types

### IKnockOffStub Interface

All generated stubs now implement `IKnockOffStub`:

```csharp
namespace KnockOff;

public interface IKnockOffStub
{
    bool Strict { get; set; }
}
```

This marker interface enables the `.Strict()` extension method and opens the door for future stub-wide operations.

### StubExtensions Class

```csharp
namespace KnockOff;

public static class StubExtensions
{
    public static T Strict<T>(this T stub) where T : IKnockOffStub
    {
        stub.Strict = true;
        return stub;
    }
}
```

## Breaking Changes

None. This is a purely additive release.

## Upgrade Notes

- Inline stubs now use a settable `Strict` property instead of a readonly field, enabling the extension method
- Class and delegate stubs now have a `Strict` property (no-op for now, enables future strict mode support)
